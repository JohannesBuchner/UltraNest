

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ultranest.integrator &mdash; UltraNest 2.1.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/icon.ico"/>
  
  
  
    <link rel="canonical" href="https://johannesbuchner.github.io/UltraNest/_modules/ultranest/integrator.html"/>
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
          

          
            <a href="../../index.html" class="icon icon-home"> UltraNest
          

          
            
            <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                2.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">UltraNest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../method.html">Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage-spectral-line.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance.html">Tour of the features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../issues.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Release Notes</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-line.html">Time series fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-modelcomparison.html">Model comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-highd.html">Higher-dimensional fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-intrinsic-distribution.html">Tutorial: intrinsic distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-line.html">Tutorial: fitting a line</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-outliers.html">Tutorial: distribution with outliers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-bayesian-workflow.html">Bayesian workflow</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">UltraNest</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ultranest.integrator</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ultranest.integrator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Ultranest calculates the Bayesian evidence and posterior samples of arbitrary models.&quot;&quot;&quot;</span>

<span class="c1"># Some parts are from the Nestle library by Kyle Barbary (https://github.com/kbarbary/nestle)</span>
<span class="c1"># Some parts are from the nnest library by Adam Moss (https://github.com/adammoss/nnest)</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">logaddexp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">create_logger</span><span class="p">,</span> <span class="n">make_run_dir</span><span class="p">,</span> <span class="n">resample_equal</span><span class="p">,</span> <span class="n">vol_prefactor</span><span class="p">,</span> <span class="n">vectorize</span>
<span class="kn">from</span> <span class="nn">ultranest.mlfriends</span> <span class="k">import</span> <span class="n">MLFriends</span><span class="p">,</span> <span class="n">AffineLayer</span><span class="p">,</span> <span class="n">ScalingLayer</span><span class="p">,</span> <span class="n">find_nearby</span>
<span class="kn">from</span> <span class="nn">.store</span> <span class="k">import</span> <span class="n">HDF5PointStore</span><span class="p">,</span> <span class="n">NullPointStore</span>
<span class="kn">from</span> <span class="nn">.viz</span> <span class="k">import</span> <span class="n">get_default_viz_callback</span><span class="p">,</span> <span class="n">nicelogger</span>
<span class="kn">from</span> <span class="nn">.netiter</span> <span class="k">import</span> <span class="n">PointPile</span><span class="p">,</span> <span class="n">MultiCounter</span><span class="p">,</span> <span class="n">BreadthFirstIterator</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">count_tree_between</span><span class="p">,</span> <span class="n">find_nodes_before</span><span class="p">,</span> <span class="n">logz_sequence</span>
<span class="kn">from</span> <span class="nn">.netiter</span> <span class="k">import</span> <span class="n">dump_tree</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ReactiveNestedSampler&#39;</span><span class="p">,</span> <span class="s1">&#39;NestedSampler&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_cumsum_range</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">dp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;From probabilities pi compute the quantile indices of `dp` and ``1-dp``.&quot;&quot;&quot;</span>
    <span class="n">ci</span> <span class="o">=</span> <span class="n">pi</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="n">ilo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ci</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ilo</span> <span class="o">=</span> <span class="n">ilo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ilo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">ihi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ci</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">dp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ihi</span> <span class="o">=</span> <span class="n">ihi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ihi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span>


<span class="k">def</span> <span class="nf">_sequentialize_width_sequence</span><span class="p">(</span><span class="n">minimal_widths</span><span class="p">,</span> <span class="n">min_width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Turn a list of required tree width into an ordered sequence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    minimal_widths: list of (Llo, Lhi, width)</span>
<span class="sd">        Defines the required width between Llo and Lhi.</span>
<span class="sd">    min_width: int</span>
<span class="sd">        Minimum width everywhere.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ---------</span>
<span class="sd">    Lsequence: list of (L, width)</span>
<span class="sd">        A sequence of L points and the expected tree width at and above it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Lpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">L</span> <span class="k">for</span> <span class="n">L</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">minimal_widths</span><span class="p">]</span> <span class="o">+</span>
                        <span class="p">[</span><span class="n">L</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">minimal_widths</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Lpoints</span><span class="p">))</span> <span class="o">*</span> <span class="n">min_width</span>

    <span class="k">for</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="n">minimal_widths</span><span class="p">:</span>
        <span class="c1"># all Lpoints within that range should be maximized to width</span>
        <span class="c1"># mask = np.logical_and(Lpoints &gt;= Llo, Lpoints &lt;= Lhi)</span>
        <span class="c1"># the following allows segments to specify -inf..L ranges</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">Lpoints</span> <span class="o">&lt;</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lpoints</span> <span class="o">&gt;</span> <span class="n">Lhi</span><span class="p">)</span>
        <span class="n">widths</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">widths</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

    <span class="c1"># the width has to monotonically increase to the maximum from both sides</span>
    <span class="c1"># so we fill up any intermediate dips</span>
    <span class="n">max_width</span> <span class="o">=</span> <span class="n">widths</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">widths</span> <span class="o">==</span> <span class="n">max_width</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">widest</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mid</span><span class="p">):</span>
        <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">widest</span><span class="p">,</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">widest</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">widest</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">widest</span><span class="p">,</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">widest</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Lpoints</span><span class="p">,</span> <span class="n">widths</span><span class="p">))</span>


<div class="viewcode-block" id="NestedSampler"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler">[docs]</a><span class="k">class</span> <span class="nc">NestedSampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple Nested sampler for reference.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">param_names</span><span class="p">,</span>
                 <span class="n">loglike</span><span class="p">,</span>
                 <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">derived_param_names</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">resume</span><span class="o">=</span><span class="s1">&#39;subfolder&#39;</span><span class="p">,</span>
                 <span class="n">run_num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">log_dir</span><span class="o">=</span><span class="s1">&#39;logs/test&#39;</span><span class="p">,</span>
                 <span class="n">num_live_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                 <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">wrapped_params</span><span class="o">=</span><span class="p">[],</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up nested sampler.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        param_names: list of str, names of the parameters.</span>
<span class="sd">            Length gives dimensionality of the sampling problem.</span>
<span class="sd">        loglike: function</span>
<span class="sd">            log-likelihood function.</span>
<span class="sd">            Receives multiple parameter vectors, returns vector of likelihood.</span>
<span class="sd">        transform: function</span>
<span class="sd">            parameter transform from unit cube to physical parameters.</span>
<span class="sd">            Receives multiple cube vectors, returns multiple parameter vectors.</span>
<span class="sd">        derived_param_names: list of str</span>
<span class="sd">            Additional derived parameters created by transform. (empty by default)</span>
<span class="sd">        log_dir: str</span>
<span class="sd">            where to store output files</span>
<span class="sd">        resume: &#39;resume&#39;, &#39;overwrite&#39; or &#39;subfolder&#39;</span>
<span class="sd">            if &#39;overwrite&#39;, overwrite previous data.</span>
<span class="sd">            if &#39;subfolder&#39;, create a fresh subdirectory in log_dir</span>
<span class="sd">            if &#39;resume&#39; or True, continue previous run if available.</span>
<span class="sd">        wrapped_params: list of bools</span>
<span class="sd">            indicating whether this parameter wraps around (circular parameter).</span>
<span class="sd">        num_live_points: int</span>
<span class="sd">            Number of live points</span>
<span class="sd">        vectorized: bool</span>
<span class="sd">            If true, loglike and transform function can receive arrays</span>
<span class="sd">            of points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span> <span class="o">=</span> <span class="n">num_live_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="s1">&#39;nested&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">=</span> <span class="n">x_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span> <span class="o">=</span> <span class="n">derived_param_names</span>
        <span class="n">num_derived</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span> <span class="o">=</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_derived</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volfactor</span> <span class="o">=</span> <span class="n">vol_prefactor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrapped_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wrapped_params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">resume</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">,</span> <span class="s1">&#39;subfolder&#39;</span><span class="p">,</span> <span class="s1">&#39;resume&#39;</span><span class="p">),</span> <span class="s2">&quot;resume should be one of &#39;overwrite&#39; &#39;subfolder&#39; or &#39;resume&#39;&quot;</span>
        <span class="n">append_run_num</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;subfolder&#39;</span>
        <span class="n">resume</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;resume&#39;</span> <span class="ow">or</span> <span class="n">resume</span> <span class="o">==</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">loglike</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Error in transform function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)))</span>
        <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;Error in transform function: u was modified!&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;Error in loglikelihood function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;Error in loglikelihood function: returned non-finite number: </span><span class="si">%s</span><span class="s2"> for input u=</span><span class="si">%s</span><span class="s2"> p=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">safe_loglike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s1">&#39;loglikelihood returned non-finite value:&#39;</span><span class="p">,</span>
                   <span class="n">logl</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)],</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">),:])</span>
            <span class="k">return</span> <span class="n">logl</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span> <span class="o">=</span> <span class="n">safe_loglike</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="k">import</span> <span class="n">MPI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="n">make_run_dir</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">run_num</span><span class="p">,</span> <span class="n">append_run_num</span><span class="o">=</span><span class="n">append_run_num</span><span class="p">)</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;run_dir&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Num live points [</span><span class="si">%d</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="c1"># self.pointstore = TextPointStore(os.path.join(self.logs[&#39;results&#39;], &#39;points.tsv&#39;), 2 + self.x_dim + self.num_params)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">HDF5PointStore</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;points.hdf5&#39;</span><span class="p">),</span>
                <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="k">if</span> <span class="n">resume</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">NullPointStore</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>

<div class="viewcode-block" id="NestedSampler.run"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_interval_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Explore parameter space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update_interval_iter:</span>
<span class="sd">            Update region after this many iterations.</span>
<span class="sd">        update_interval_ncall:</span>
<span class="sd">            Update region after update_interval_ncall likelihood calls.</span>
<span class="sd">        log_interval:</span>
<span class="sd">            Update stdout status line every log_interval iterations</span>
<span class="sd">        dlogz:</span>
<span class="sd">            Target evidence uncertainty.</span>
<span class="sd">        max_iters:</span>
<span class="sd">            maximum number of integration iterations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">update_interval_ncall</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">update_interval_ncall</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">update_interval_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">update_interval_ncall</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">update_interval_iter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">update_interval_iter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">log_interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">log_interval</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;log_interval must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="n">viz_callback</span> <span class="o">=</span> <span class="n">get_default_viz_callback</span><span class="p">()</span>

        <span class="n">prev_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_logl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="c1"># try to resume:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Resuming...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">):</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">prev_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">prev_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">])</span>
                    <span class="n">prev_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">prev_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_v</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>

            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">use_point_stack</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">assert</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="c1">#self.logger.info(&#39;Using MPI with rank [%d]&#39;, self.mpi_rank)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active_v</span><span class="p">):</span>
                        <span class="n">chunks</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chunks</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">recv_active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">active_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_active_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_active_logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">active_v</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">+</span> <span class="n">active_u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">active_v</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">))</span>
                <span class="n">active_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">active_v</span><span class="p">))</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_u</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">active_v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active_u</span> <span class="o">=</span> <span class="n">prev_u</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="n">prev_v</span>
            <span class="n">active_logl</span> <span class="o">=</span> <span class="n">prev_logl</span>

        <span class="n">saved_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">saved_v</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Stored points for posterior results</span>
        <span class="n">saved_logl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">saved_logwt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Information, initially 0.</span>
        <span class="n">logz</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e300</span>  <span class="c1"># ln(Evidence Z), initially Z=0</span>
        <span class="n">logvol</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>
        <span class="n">logz_remain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">active_logl</span><span class="p">)</span>
        <span class="n">fraction_remain</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">ncall</span> <span class="o">=</span> <span class="n">num_live_points_missing</span>  <span class="c1"># number of calls we already made</span>
        <span class="n">first_time</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">transformLayer</span> <span class="o">=</span> <span class="n">AffineLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformLayer</span> <span class="o">=</span> <span class="n">ScalingLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
        <span class="n">transformLayer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">MLFriends</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">transformLayer</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting sampling ...&#39;</span><span class="p">)</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ndraw</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">next_update_interval_ncall</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">next_update_interval_iter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">max_iters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">:</span>

            <span class="c1"># Worst object in collection and its weight (= volume * likelihood)</span>
            <span class="n">worst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">active_logl</span><span class="p">)</span>
            <span class="n">logwt</span> <span class="o">=</span> <span class="n">logvol</span> <span class="o">+</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span>

            <span class="c1"># Update evidence Z and information h.</span>
            <span class="n">logz_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="n">logz</span><span class="p">,</span> <span class="n">logwt</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logwt</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">logz</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">logz</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span>
            <span class="n">logz</span> <span class="o">=</span> <span class="n">logz_new</span>

            <span class="c1"># Add worst object to samples.</span>
            <span class="n">saved_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_u</span><span class="p">[</span><span class="n">worst</span><span class="p">]))</span>
            <span class="n">saved_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_v</span><span class="p">[</span><span class="n">worst</span><span class="p">]))</span>
            <span class="n">saved_logwt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logwt</span><span class="p">)</span>
            <span class="n">saved_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">])</span>

            <span class="c1"># expected_vol = np.exp(-it / self.num_live_points)</span>

            <span class="c1"># The new likelihood constraint is that of the worst object.</span>
            <span class="n">loglstar</span> <span class="o">=</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ncall</span> <span class="o">&gt;</span> <span class="n">next_update_interval_ncall</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="n">next_update_interval_iter</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
                    <span class="n">nextregion</span> <span class="o">=</span> <span class="n">region</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># rebuild space</span>
                    <span class="c1"># print()</span>
                    <span class="c1"># print(&quot;rebuilding space...&quot;, active_u.shape, active_u)</span>
                    <span class="n">nextTransformLayer</span> <span class="o">=</span> <span class="n">transformLayer</span><span class="o">.</span><span class="n">create_new</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">)</span>
                    <span class="n">nextregion</span> <span class="o">=</span> <span class="n">MLFriends</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">nextTransformLayer</span><span class="p">)</span>

                <span class="c1"># print(&quot;computing maxradius...&quot;)</span>
                <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">compute_enlargement</span><span class="p">(</span><span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">))</span>
                <span class="c1"># print(&quot;MLFriends built. r=%f&quot; % r**0.5)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                    <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">)</span>
                    <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">)</span>

                <span class="n">nextregion</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">nextregion</span><span class="o">.</span><span class="n">enlarge</span> <span class="o">=</span> <span class="n">f</span>
                <span class="c1"># force shrinkage of volume</span>
                <span class="c1"># this is to avoid re-connection of dying out nodes</span>
                <span class="k">if</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">():</span>
                    <span class="n">region</span> <span class="o">=</span> <span class="n">nextregion</span>
                    <span class="n">transformLayer</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span>
                <span class="n">region</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">it</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">volfactor</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="n">viz_callback</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">active_v</span><span class="p">,</span> <span class="n">logl</span><span class="o">=</span><span class="n">active_logl</span><span class="p">),</span>
                        <span class="n">info</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">it</span><span class="p">,</span> <span class="n">ncall</span><span class="o">=</span><span class="n">ncall</span><span class="p">,</span> <span class="n">logz</span><span class="o">=</span><span class="n">logz</span><span class="p">,</span> <span class="n">logz_remain</span><span class="o">=</span><span class="n">logz_remain</span><span class="p">,</span>
                        <span class="n">paramnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">,</span> <span class="n">logvol</span><span class="o">=</span><span class="n">logvol</span><span class="p">),</span>
                        <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">transformLayer</span><span class="o">=</span><span class="n">transformLayer</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                <span class="n">next_update_interval_ncall</span> <span class="o">=</span> <span class="n">ncall</span> <span class="o">+</span> <span class="n">update_interval_ncall</span>
                <span class="n">next_update_interval_iter</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">update_interval_iter</span>
                <span class="n">first_time</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_point_stack</span><span class="p">:</span>
                    <span class="c1"># root checks the point store</span>
                    <span class="n">next_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">stored_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">loglstar</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">stored_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">stored_point</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                        <span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>  <span class="c1"># and informs everyone</span>
                        <span class="n">use_point_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">use_point_stack</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">next_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">next_point</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># assert not use_point_stack</span>

                    <span class="c1"># unpack</span>
                    <span class="n">likes</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">]</span>
                    <span class="n">samplesv</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
                    <span class="c1"># skip if we already know it is not useful</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">likes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="mi">1</span>

                <span class="k">while</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                    <span class="c1"># get new samples</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">father</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">ndraw</span><span class="p">)</span>
                    <span class="n">nu</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
                        <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">nc</span> <span class="o">+=</span> <span class="n">nu</span>
                        <span class="n">accepted</span> <span class="o">=</span> <span class="n">logl</span> <span class="o">&gt;</span> <span class="n">loglstar</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:]</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:]</span>
                        <span class="n">logl</span> <span class="o">=</span> <span class="n">logl</span><span class="p">[</span><span class="n">accepted</span><span class="p">]</span>
                        <span class="n">father</span> <span class="o">=</span> <span class="n">father</span><span class="p">[</span><span class="n">accepted</span><span class="p">]</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                        <span class="n">recv_father</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">father</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_father</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_father</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">father</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_father</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">ncall</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span>
                        <span class="n">ncall</span> <span class="o">+=</span> <span class="n">nc</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">logli</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">samplesv</span><span class="p">,</span> <span class="n">likes</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">loglstar</span><span class="p">,</span> <span class="n">logli</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ui</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">vi</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                <span class="k">if</span> <span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">loglstar</span><span class="p">:</span>
                    <span class="n">active_u</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">active_v</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">samplesv</span><span class="p">[</span><span class="n">ib</span><span class="p">,:]</span>
                    <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>

                    <span class="c1"># if we keep the region informed about the new live points</span>
                    <span class="c1"># then the region follows the live points even if maxradius is not updated</span>
                    <span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">worst</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">active_u</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span>
                    <span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">[</span><span class="n">worst</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">worst</span><span class="p">,:])</span>

                    <span class="c1"># if we track the cluster assignment, then in the next round</span>
                    <span class="c1"># the ids with the same members are likely to have the same id</span>
                    <span class="c1"># this is imperfect</span>
                    <span class="c1"># transformLayer.clusterids[worst] = transformLayer.clusterids[father[ib]]</span>
                    <span class="c1"># so we just mark the replaced ones as &quot;unassigned&quot;</span>
                    <span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Shrink interval</span>
            <span class="n">logvol</span> <span class="o">-=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span>
            <span class="n">logz_remain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">active_logl</span><span class="p">)</span> <span class="o">-</span> <span class="n">it</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span>
            <span class="n">fraction_remain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="n">logz</span><span class="p">,</span> <span class="n">logz_remain</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz</span>

            <span class="k">if</span> <span class="n">it</span> <span class="o">%</span> <span class="n">log_interval</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="c1"># nicelogger(self.paramnames, active_u, active_v, active_logl, it, ncall, logz, logz_remain, region=region)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Z=</span><span class="si">%.1g</span><span class="s1">+</span><span class="si">%.1g</span><span class="s1"> | Like=</span><span class="si">%.1g</span><span class="s1">..</span><span class="si">%.1g</span><span class="s1"> | it/evals=</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1"> eff=</span><span class="si">%.4f%%</span><span class="s1">  </span><span class="se">\r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">logz</span><span class="p">,</span> <span class="n">logz_remain</span><span class="p">,</span> <span class="n">loglstar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">active_logl</span><span class="p">),</span> <span class="n">it</span><span class="p">,</span>
                    <span class="n">ncall</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">ncall</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">it</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ncall</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                <span class="c1"># if efficiency becomes low, bulk-process larger arrays</span>
                <span class="n">ndraw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">16384</span><span class="p">,</span> <span class="nb">round</span><span class="p">((</span><span class="n">ncall</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)))</span>

            <span class="c1"># Stopping criterion</span>
            <span class="k">if</span> <span class="n">fraction_remain</span> <span class="o">&lt;</span> <span class="n">dlogz</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">logvol</span> <span class="o">=</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_v</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">):</span>
            <span class="n">logwt</span> <span class="o">=</span> <span class="n">logvol</span> <span class="o">+</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">logz_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="n">logz</span><span class="p">,</span> <span class="n">logwt</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logwt</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">logz</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">logz</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span>
            <span class="n">logz</span> <span class="o">=</span> <span class="n">logz_new</span>
            <span class="n">saved_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_u</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">saved_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_v</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">saved_logwt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logwt</span><span class="p">)</span>
            <span class="n">saved_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">saved_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_u</span><span class="p">)</span>
        <span class="n">saved_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_v</span><span class="p">)</span>
        <span class="n">saved_wt</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_logwt</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz</span><span class="p">)</span>
        <span class="n">saved_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">)</span>
        <span class="n">logzerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;final.csv&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;niter&#39;</span><span class="p">,</span> <span class="s1">&#39;ncall&#39;</span><span class="p">,</span> <span class="s1">&#39;logz&#39;</span><span class="p">,</span> <span class="s1">&#39;logzerr&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncall</span><span class="p">,</span> <span class="n">logz</span><span class="p">,</span> <span class="n">logzerr</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;niter: </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2"> ncall: </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2"> nsamples: </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2"> logz: </span><span class="si">{:6.3f}</span><span class="s2"> +/- </span><span class="si">{:6.3f}</span><span class="se">\n</span><span class="s2"> h: </span><span class="si">{:6.3f}</span><span class="s2">&quot;</span>
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncall</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">saved_v</span><span class="p">),</span> <span class="n">logz</span><span class="p">,</span> <span class="n">logzerr</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">resample_equal</span><span class="p">(</span><span class="n">saved_v</span><span class="p">,</span> <span class="n">saved_wt</span> <span class="o">/</span> <span class="n">saved_wt</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
            <span class="n">ncall</span><span class="o">=</span><span class="n">ncall</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">it</span><span class="p">,</span> <span class="n">logz</span><span class="o">=</span><span class="n">logz</span><span class="p">,</span> <span class="n">logzerr</span><span class="o">=</span><span class="n">logzerr</span><span class="p">,</span>
            <span class="n">weighted_samples</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">saved_u</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">saved_v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">saved_wt</span><span class="p">,</span> <span class="n">logw</span><span class="o">=</span><span class="n">saved_logwt</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">saved_logl</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span></div>

<div class="viewcode-block" id="NestedSampler.print_results"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler.print_results">[docs]</a>    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logZ</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">posterior</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give summary of marginal likelihood and parameters.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;logZ = </span><span class="si">%(logz).3f</span><span class="s1"> +- </span><span class="si">%(logzerr).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="n">med</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sigma</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">.</span><span class="si">%d</span><span class="s1">f&#39;</span> <span class="o">%</span> <span class="n">i</span>
            <span class="n">fmts</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;    </span><span class="si">%-20s</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">fmt</span> <span class="o">+</span> <span class="s2">&quot; +- &quot;</span> <span class="o">+</span> <span class="n">fmt</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fmts</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">med</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span></div>

<div class="viewcode-block" id="NestedSampler.plot"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make corner plot.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="kn">import</span> <span class="nn">corner</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;weighted_samples&#39;</span><span class="p">][</span><span class="s1">&#39;v&#39;</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;weighted_samples&#39;</span><span class="p">][</span><span class="s1">&#39;w&#39;</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">/=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">cumsumweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">cumsumweights</span> <span class="o">&gt;</span> <span class="mf">1e-4</span>

            <span class="n">corner</span><span class="o">.</span><span class="n">corner</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">,:],</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                    <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">,</span> <span class="n">show_titles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;corner.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ReactiveNestedSampler"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler">[docs]</a><span class="k">class</span> <span class="nc">ReactiveNestedSampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nested sampler with reactive exploration strategy.</span>

<span class="sd">    Storage &amp; resume capable, optionally MPI parallelised.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">param_names</span><span class="p">,</span>
                 <span class="n">loglike</span><span class="p">,</span>
                 <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">derived_param_names</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">wrapped_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">resume</span><span class="o">=</span><span class="s1">&#39;subfolder&#39;</span><span class="p">,</span>
                 <span class="n">run_num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">log_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_test_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">draw_multiple</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">num_bootstraps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                 <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise nested sampler.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        param_names: list of str, names of the parameters.</span>
<span class="sd">            Length gives dimensionality of the sampling problem.</span>

<span class="sd">        loglike: function</span>
<span class="sd">            log-likelihood function.</span>
<span class="sd">            Receives multiple parameter vectors, returns vector of likelihood.</span>
<span class="sd">        transform: function</span>
<span class="sd">            parameter transform from unit cube to physical parameters.</span>
<span class="sd">            Receives multiple cube vectors, returns multiple parameter vectors.</span>

<span class="sd">        derived_param_names: list of str</span>
<span class="sd">            Additional derived parameters created by transform. (empty by default)</span>

<span class="sd">        log_dir: str</span>
<span class="sd">            where to store output files</span>
<span class="sd">        resume: &#39;resume&#39;, &#39;overwrite&#39; or &#39;subfolder&#39;</span>
<span class="sd">            if &#39;overwrite&#39;, overwrite previous data.</span>
<span class="sd">            if &#39;subfolder&#39;, create a fresh subdirectory in log_dir</span>
<span class="sd">            if &#39;resume&#39; or True, continue previous run if available.</span>

<span class="sd">        wrapped_params: list of bools</span>
<span class="sd">            indicating whether this parameter wraps around (circular parameter).</span>

<span class="sd">        num_test_samples: int</span>
<span class="sd">            test transform and likelihood with this number of</span>
<span class="sd">            random points for errors first. Useful to catch bugs.</span>

<span class="sd">        draw_multiple: bool</span>
<span class="sd">            draw more points if efficiency goes down.</span>
<span class="sd">            If set to False, few points are sampled at once.</span>

<span class="sd">        num_bootstraps: int</span>
<span class="sd">            number of logZ estimators and MLFriends region</span>
<span class="sd">            bootstrap rounds.</span>

<span class="sd">        vectorized: bool</span>
<span class="sd">            If true, loglike and transform function can receive arrays</span>
<span class="sd">            of points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="s1">&#39;reactive-nested&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">=</span> <span class="n">x_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span> <span class="o">=</span> <span class="n">derived_param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_bootstraps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_bootstraps</span><span class="p">)</span>
        <span class="n">num_derived</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span> <span class="o">=</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_derived</span>
        <span class="k">if</span> <span class="n">wrapped_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrapped_params</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;wrapped_params has the number of entries:&quot;</span><span class="p">,</span> <span class="n">wrapped_params</span><span class="p">,</span> <span class="s2">&quot;, expected&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wrapped_params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="k">import</span> <span class="n">MPI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setup_distributed_seeds</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="n">resume</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">,</span> <span class="s1">&#39;subfolder&#39;</span><span class="p">,</span> <span class="s1">&#39;resume&#39;</span><span class="p">),</span> <span class="s2">&quot;resume should be one of &#39;overwrite&#39; &#39;subfolder&#39; or &#39;resume&#39;&quot;</span>
        <span class="n">append_run_num</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;subfolder&#39;</span>
        <span class="n">resume</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;resume&#39;</span> <span class="ow">or</span> <span class="n">resume</span> <span class="o">==</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="n">make_run_dir</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">run_num</span><span class="p">,</span> <span class="n">append_run_num</span><span class="o">=</span><span class="n">append_run_num</span><span class="p">)</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;run_dir&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="s1">&#39;ultranest&#39;</span><span class="p">,</span> <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span> <span class="o">=</span> <span class="n">PointPile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="c1"># self.pointstore = TextPointStore(os.path.join(self.logs[&#39;results&#39;], &#39;points.tsv&#39;), 2 + self.x_dim + self.num_params)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">HDF5PointStore</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;points.hdf5&#39;</span><span class="p">),</span>
                <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="k">if</span> <span class="n">resume</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">NullPointStore</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">loglike</span><span class="p">)</span>
            <span class="n">draw_multiple</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span> <span class="o">=</span> <span class="n">draw_multiple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_likelihood_function</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="p">,</span> <span class="n">num_test_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_setup_distributed_seeds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>

        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># from http://arxiv.org/abs/1005.4117</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(((</span><span class="n">seed</span> <span class="o">*</span> <span class="mi">181</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">-</span> <span class="mi">83</span><span class="p">)</span> <span class="o">*</span> <span class="mi">359</span><span class="p">))</span> <span class="o">%</span> <span class="mi">104729</span><span class="p">))</span>
            <span class="c1"># print(&#39;setting seed:&#39;, self.mpi_rank, seed)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_likelihood_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="p">,</span> <span class="n">num_test_samples</span><span class="p">,</span> <span class="n">make_safe</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the transform and log-likelihood functions.</span>

<span class="sd">        Tests with `num_test_samples` whether they work and give the correct output.</span>

<span class="sd">        if make_safe is set, make functions safer by accepting misformed</span>
<span class="sd">        return shapes and non-finite likelihood values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do some checks on the likelihood function</span>
        <span class="c1"># this makes debugging easier by failing early with meaningful errors</span>

        <span class="c1"># if we are resuming, check that last sample still gives same result</span>
        <span class="n">num_resume_test_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">num_test_samples</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span><span class="p">:</span>
            <span class="n">num_resume_test_samples</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">num_test_samples</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">num_test_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># test with num_test_samples random points</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_test_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Error in transform function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;Error in transform function: u was modified!&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;Error in loglikelihood function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;Error in loglikelihood function: returned non-finite number: </span><span class="si">%s</span><span class="s2"> for input u=</span><span class="si">%s</span><span class="s2"> p=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span> <span class="ow">and</span> <span class="n">num_resume_test_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># test that last sample gives the same likelihood value</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">lastrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lastrow</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Cannot resume: problem has different dimensionality&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lastrow</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
            <span class="n">lastL</span> <span class="o">=</span> <span class="n">lastrow</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lastu</span> <span class="o">=</span> <span class="n">lastrow</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">lastu</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">lastp</span> <span class="o">=</span> <span class="n">lastrow</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Testing resume consistency: </span><span class="si">%s</span><span class="s2">: u=</span><span class="si">%s</span><span class="s2"> -&gt; p=</span><span class="si">%s</span><span class="s2"> -&gt; L=</span><span class="si">%s</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">lastrow</span><span class="p">,</span> <span class="n">lastu</span><span class="p">,</span> <span class="n">lastp</span><span class="p">,</span> <span class="n">lastL</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lastp</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Trying to resume from previous run, but transform function gives different result: </span><span class="si">%s</span><span class="s2"> gave </span><span class="si">%s</span><span class="s2">, now </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">lastu</span><span class="p">,</span> <span class="n">lastp</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lastp</span><span class="p">),</span> <span class="s2">&quot;Cannot resume because transform function changed. To start from scratch, delete &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;run_dir&#39;</span><span class="p">])</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">lastL</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Trying to resume from previous run, but likelihood function gives different result: </span><span class="si">%s</span><span class="s2"> gave </span><span class="si">%s</span><span class="s2">, now </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">lastu</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lastL</span><span class="p">,</span> <span class="n">logl</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">lastL</span><span class="p">),</span> <span class="s2">&quot;Cannot resume because loglikelihood function changed. To start from scratch, delete &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;run_dir&#39;</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">safe_loglike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">logl</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">logl</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">))]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e100</span>
            <span class="k">return</span> <span class="n">logl</span>

        <span class="k">if</span> <span class="n">make_safe</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span> <span class="o">=</span> <span class="n">safe_loglike</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span> <span class="o">=</span> <span class="n">loglike</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">make_safe</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">safe_transform</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">safe_transform</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

        <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
        <span class="n">lims</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="n">lims</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lims</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">volfactor</span> <span class="o">=</span> <span class="n">vol_prefactor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_widen_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weighted_parents</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure that at parents have `nnodes_needed` live points (parallel arcs).</span>

<span class="sd">        If not, fill up by sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndone</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weighted_parents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndone</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No parents, so widening roots&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_widen_roots</span><span class="p">(</span><span class="n">nnodes_needed</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># select parents with weight 1/parent_weights</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="n">weighted_parents</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># preferentially select nodes with few parents, as those</span>
            <span class="c1"># have most weight</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weighted_parents</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span> <span class="o">/</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">weighted_parents</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">weighted_parents</span><span class="p">,</span> <span class="n">weights</span>

        <span class="c1"># sort from low to high</span>
        <span class="n">parents</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">))</span>
        <span class="n">Lmin</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Lmin</span><span class="p">):</span>
            <span class="c1"># some of the parents were born by sampling from the entire</span>
            <span class="c1"># prior volume. So we can efficiently apply a solution:</span>
            <span class="c1"># expand the roots</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;parent value is -inf, so widening roots&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_widen_roots</span><span class="p">(</span><span class="n">nnodes_needed</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># double until we reach the necessary points</span>
        <span class="c1"># this is probably 1, from (2K - K) / K</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">nnodes_needed</span> <span class="o">-</span> <span class="n">ndone</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Will add </span><span class="si">%d</span><span class="s1"> live points (x</span><span class="si">%d</span><span class="s1">) at L=</span><span class="si">%.1g</span><span class="s1"> ...&#39;</span><span class="p">,</span> <span class="n">nnodes_needed</span> <span class="o">-</span> <span class="n">ndone</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">)</span>

        <span class="c1"># add points where necessary (parents can have multiple entries)</span>
        <span class="n">target_min_num_children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
            <span class="n">orign</span> <span class="o">=</span> <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
            <span class="n">target_min_num_children</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">orign</span> <span class="o">+</span> <span class="n">nsamples</span>

        <span class="k">return</span> <span class="n">target_min_num_children</span>

    <span class="k">def</span> <span class="nf">_widen_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nroots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure root has `nroots` children.</span>

<span class="sd">        Sample from prior to fill up (if needed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Widening roots to </span><span class="si">%d</span><span class="s1"> live points (have </span><span class="si">%d</span><span class="s1"> already) ...&#39;</span><span class="p">,</span> <span class="n">nroots</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
        <span class="n">nnewroots</span> <span class="o">=</span> <span class="n">nroots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nnewroots</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># nothing to do</span>
            <span class="k">return</span>

        <span class="n">prev_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_logl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_rowid</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">:</span>
            <span class="c1"># try to resume:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Resuming...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nnewroots</span><span class="p">):</span>
                <span class="n">rowid</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">prev_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">prev_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">])</span>
                <span class="n">prev_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">])</span>
                <span class="n">prev_rowid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowid</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="n">prev_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_v</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>

            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="n">nnewroots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling </span><span class="si">%d</span><span class="s1"> live points from prior ...&#39;</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active_v</span><span class="p">):</span>
                        <span class="n">chunks</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="n">num_live_points_missing</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chunks</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),),</span> <span class="p">(</span><span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="n">recv_active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">active_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_active_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_active_logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,),</span> <span class="p">(</span><span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="n">num_live_points_missing</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">active_v</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,),</span> <span class="p">(</span><span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">):</span>
                    <span class="n">rowid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="n">active_u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">active_v</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">))</span>
                <span class="n">active_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">active_v</span><span class="p">))</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_u</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">),</span> <span class="p">(</span><span class="n">active_u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">),</span> <span class="p">(</span><span class="n">active_v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nnewroots</span><span class="p">,),</span> <span class="p">(</span><span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nnewroots</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active_u</span> <span class="o">=</span> <span class="n">prev_u</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="n">prev_v</span>
            <span class="n">active_logl</span> <span class="o">=</span> <span class="n">prev_logl</span>

        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">logl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_v</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span> <span class="o">+=</span> <span class="n">roots</span>

    <span class="k">def</span> <span class="nf">_adaptive_strategy_advice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">parallel_values</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">minimal_widths</span><span class="p">,</span> <span class="n">frac_remain</span><span class="p">,</span> <span class="n">Lepsilon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if integration is done.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Llo, Lhi: floats</span>
<span class="sd">            range where more sampling is needed</span>
<span class="sd">            if done, both are nan</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        Lmin: float</span>
<span class="sd">            current loglikelihood threshold</span>
<span class="sd">        parallel_values: array of floats</span>
<span class="sd">            loglikelihoods of live points</span>
<span class="sd">        main_iterator: BreadthFirstIterator</span>
<span class="sd">            current tree exploration iterator</span>
<span class="sd">        minimal_widths: list</span>
<span class="sd">            current width required</span>
<span class="sd">        frac_remain: float</span>
<span class="sd">            maximum fraction of integral in remainder for termination</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">parallel_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Ls</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># Ls = [node.value] + [n.value for rootid2, n in parallel_nodes]</span>
        <span class="n">Lmax</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Lmin</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># all points the same, stop</span>
        <span class="k">if</span> <span class="n">Lmax</span> <span class="o">-</span> <span class="n">Lmin</span> <span class="o">&lt;</span> <span class="n">Lepsilon</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># max remainder contribution is Lmax + weight, to be added to main_iterator.logZ</span>
        <span class="c1"># the likelihood that would add an equal amount as main_iterator.logZ is:</span>
        <span class="n">logZmax</span> <span class="o">=</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZremain</span>
        <span class="n">Lnext</span> <span class="o">=</span> <span class="n">logZmax</span> <span class="o">-</span> <span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">frac_remain</span><span class="p">))</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">))</span>
        <span class="n">L1</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Lmax1</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Ls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Lnext</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Lnext</span><span class="p">,</span> <span class="n">Lmax1</span><span class="p">),</span> <span class="n">L1</span><span class="p">)</span>

        <span class="c1"># if the remainder dominates, return that range</span>
        <span class="k">if</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZremain</span> <span class="o">&gt;</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">Lnext</span>

        <span class="k">if</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">remainder_fraction</span> <span class="o">&gt;</span> <span class="n">frac_remain</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">Lnext</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">_find_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">dlogz</span><span class="p">,</span> <span class="n">dKL</span><span class="p">,</span> <span class="n">min_ess</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ask each strategy which log-likelihood interval needs more exploration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (Llo_Z, Lhi_Z): floats</span>
<span class="sd">            interval where dlogz strategy requires more samples.</span>
<span class="sd">        (Llo_KL, Lhi_KL): floats</span>
<span class="sd">            interval where posterior uncertainty strategy requires more samples.</span>
<span class="sd">        (Llo_ess, Lhi_ess): floats</span>
<span class="sd">            interval where effective sample strategy requires more samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        saved_logl: array of float</span>
<span class="sd">            loglikelihood values in integration</span>
<span class="sd">        main_iterator: BreadthFirstIterator</span>
<span class="sd">            current tree exploration iterator</span>
<span class="sd">        dlogz: float</span>
<span class="sd">            required logZ accuracy (smaller is stricter)</span>
<span class="sd">        dKL: float</span>
<span class="sd">            required Kulback-Leibler information gain between bootstrapped</span>
<span class="sd">            nested sampling incarnations (smaller is stricter).</span>
<span class="sd">        min_ess: float</span>
<span class="sd">            required number of effective samples (higher is stricter).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">saved_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">)</span>
        <span class="n">logw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logweights</span><span class="p">)</span> <span class="o">+</span> <span class="n">saved_logl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span>
        <span class="n">ref_logw</span> <span class="o">=</span> <span class="n">logw</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">other_logw</span> <span class="o">=</span> <span class="n">logw</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">Llo_ess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lhi_ess</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">ref_logw</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">w</span> <span class="o">/=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ess</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ess</span> <span class="o">&lt;</span> <span class="n">min_ess</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">min_ess</span><span class="p">)</span>
            <span class="n">Llo_ess</span> <span class="o">=</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">Lhi_ess</span> <span class="o">=</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">Lhi_ess</span> <span class="o">&gt;</span> <span class="n">Llo_ess</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Effective samples strategy wants to improve: </span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2"> (ESS = </span><span class="si">%.1f</span><span class="s2">, need &gt;</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                             <span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Lhi_ess</span><span class="p">,</span> <span class="n">ess</span><span class="p">,</span> <span class="n">min_ess</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">min_ess</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Effective samples strategy satisfied (ESS = </span><span class="si">%.1f</span><span class="s2">, need &gt;</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                             <span class="n">ess</span><span class="p">,</span> <span class="n">min_ess</span><span class="p">)</span>

        <span class="c1"># compute KL divergence</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">KL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">other_logw</span><span class="p">),</span> <span class="n">exp</span><span class="p">(</span><span class="n">other_logw</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">other_logw</span> <span class="o">-</span> <span class="n">ref_logw</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">KLtot</span> <span class="o">=</span> <span class="n">KL</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dKLtot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">KLtot</span> <span class="o">-</span> <span class="n">KLtot</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">KL</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">/=</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">Llo_KL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lhi_KL</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">dKLi</span><span class="p">,</span> <span class="n">logwi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dKLtot</span><span class="p">,</span> <span class="n">other_logw</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">dKLi</span> <span class="o">&gt;</span> <span class="n">dKL</span><span class="p">:</span>
                <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span> <span class="o">=</span> <span class="n">_get_cumsum_range</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mi">400</span><span class="p">)</span>
                <span class="c1"># ilo and ihi are most likely missing in this iterator</span>
                <span class="c1"># --&gt; select the one before/after in this iterator</span>
                <span class="n">ilos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logwi</span><span class="p">[:</span><span class="n">ilo</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ihis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logwi</span><span class="p">[</span><span class="n">ihi</span><span class="p">:]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ilo2</span> <span class="o">=</span> <span class="n">ilos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ilos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">ihi2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ihi</span> <span class="o">+</span> <span class="n">ihis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ihis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                <span class="c1"># self.logger.info(&#39;   - KL[%d] = %.2f: need to improve near %.2f..%.2f --&gt; %.2f..%.2f&#39; % (i, dKLi, saved_logl[ilo], saved_logl[ihi], saved_logl[ilo2], saved_logl[ihi2]))</span>
                <span class="n">Llo_KL</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Llo_KL</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">ilo2</span><span class="p">])</span>
                <span class="n">Lhi_KL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lhi_KL</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">ihi2</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">Lhi_KL</span> <span class="o">&gt;</span> <span class="n">Llo_KL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Posterior uncertainty strategy wants to improve: </span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2"> (KL: </span><span class="si">%.2f</span><span class="s2">+-</span><span class="si">%.2f</span><span class="s2"> nat, need &lt;</span><span class="si">%.2f</span><span class="s2"> nat)&quot;</span><span class="p">,</span>
                             <span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">,</span> <span class="n">KLtot</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">dKLtot</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dKL</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Posterior uncertainty strategy is satisfied (KL: </span><span class="si">%.2f</span><span class="s2">+-</span><span class="si">%.2f</span><span class="s2"> nat, need &lt;</span><span class="si">%.2f</span><span class="s2"> nat)&quot;</span><span class="p">,</span>
                             <span class="n">KLtot</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">dKLtot</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dKL</span><span class="p">)</span>

        <span class="n">Llo_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lhi_Z</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># compute difference between lnZ cumsum</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">logw</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">/=</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">deltalogZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">)</span>

        <span class="n">tail_fraction</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">istail</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">logzerr_tail</span> <span class="o">=</span> <span class="n">logaddexp</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">tail_fraction</span><span class="p">)</span> <span class="o">+</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">)</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">deltalogZ</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">logzerr_tail</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">deltalogZi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">deltalogZ</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">deltalogZi</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">:</span>
                    <span class="c1"># break up samples with too much weight</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_logw</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
                    <span class="c1"># if self.log:</span>
                    <span class="c1">#     self.logger.info(&#39;   - deltalogZi[%d] = %.2f: need to improve near %.2f..%.2f&#39; % (</span>
                    <span class="c1">#         i, deltalogZi, saved_logl[samples].min(), saved_logl[samples].max()))</span>
                    <span class="n">Llo_Z</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Llo_Z</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                    <span class="n">Lhi_Z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lhi_Z</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">Lhi_Z</span> <span class="o">&gt;</span> <span class="n">Llo_Z</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Evidency uncertainty strategy wants to improve: </span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2"> (dlogz from </span><span class="si">%.2f</span><span class="s2"> to </span><span class="si">%.2f</span><span class="s2">, need &lt;</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                             <span class="n">Llo_Z</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">,</span> <span class="n">deltalogZ</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">deltalogZ</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dlogz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Evidency uncertainty strategy is satisfied (dlogz=</span><span class="si">%.2f</span><span class="s2">, need &lt;</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                             <span class="n">deltalogZ</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dlogz</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  logZ error budget: single: </span><span class="si">%.2f</span><span class="s1"> bs:</span><span class="si">%.2f</span><span class="s1"> tail:</span><span class="si">%.2f</span><span class="s1"> total:</span><span class="si">%.2f</span><span class="s1"> required:&lt;</span><span class="si">%.2f</span><span class="s1">&#39;</span><span class="p">,</span>
                         <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="p">,</span> <span class="n">logzerr_tail</span><span class="p">,</span>
                         <span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">logzerr_tail</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dlogz</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">Llo_Z</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Lhi_ess</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pump_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">,</span> <span class="n">active_u</span><span class="p">,</span> <span class="n">active_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get new samples at `Lmin` with attribute `.stepsampler`.&quot;&quot;&quot;</span>
        <span class="c1"># tlive = self.region.transformLayer.transform(ulive)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">logl</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span><span class="o">.</span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span>
            <span class="n">Lmin</span><span class="o">=</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">us</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">Ls</span><span class="o">=</span><span class="n">active_values</span><span class="p">,</span>
            <span class="n">ndraw</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">logl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">logl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">u</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">logl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="n">nc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span> <span class="o">+=</span> <span class="n">ndraw</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="n">quality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span><span class="o">.</span><span class="n">nsteps</span>
            <span class="k">for</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">logli</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">logli</span><span class="p">,</span> <span class="n">quality</span><span class="p">]</span> <span class="o">+</span> <span class="n">ui</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">vi</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_refill_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get new samples from region.&quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">father</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">ndraw</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span><span class="p">:</span>
                <span class="n">nu</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="n">father</span> <span class="o">=</span> <span class="n">father</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">nc</span> <span class="o">+=</span> <span class="n">nu</span>
        <span class="n">accepted</span> <span class="o">=</span> <span class="n">logl</span> <span class="o">&gt;</span> <span class="n">Lmin</span>
        <span class="k">if</span> <span class="n">nit</span> <span class="o">&gt;=</span> <span class="mi">100000</span> <span class="o">/</span> <span class="n">ndraw</span> <span class="ow">and</span> <span class="n">nit</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100000</span> <span class="o">//</span> <span class="n">ndraw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_slow_warned</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s1">&#39;sampling-stuck-it</span><span class="si">%d</span><span class="s1">.npz&#39;</span> <span class="o">%</span> <span class="n">nit</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">unormed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span> <span class="n">maxradiussq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span>
                <span class="n">sample_u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">sample_v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">sample_logl</span><span class="o">=</span><span class="n">logl</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Sampling from region seems inefficient. You can try increasing nlive, frac_remain, dlogz, dKL, decrease min_ess). [</span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> accepted, it=</span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">accepted</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">))</span>
            <span class="n">logl_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">logl_region</span> <span class="o">==</span> <span class="n">Lmin</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Region cannot sample a higher point. All remaining live points have the same value.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">logl_region</span> <span class="o">&gt;</span> <span class="n">Lmin</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Region cannot sample a higher point. Perhaps you are resuming from a different problem? Delete the output files and start again.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_slow_warned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:]</span>
        <span class="n">logl</span> <span class="o">=</span> <span class="n">logl</span><span class="p">[</span><span class="n">accepted</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="n">nc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span> <span class="o">+=</span> <span class="n">ndraw</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">logli</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">logli</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ui</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">vi</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_create_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">active_u</span><span class="p">,</span> <span class="n">active_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw a new point above likelihood threshold `Lmin`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        Lmin: float</span>
<span class="sd">            loglikelihood threshold to draw above</span>
<span class="sd">        ndraw: float</span>
<span class="sd">            number of points to try to sample at once</span>
<span class="sd">        active_u: array of floats</span>
<span class="sd">            current live points</span>
<span class="sd">        active_values</span>
<span class="sd">            loglikelihoods of current live points</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ib</span>
            <span class="k">if</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">:</span>
                <span class="c1"># root checks the point store</span>
                <span class="n">next_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">stored_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">Lmin</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stored_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">stored_point</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>  <span class="c1"># and informs everyone</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">next_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">next_point</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># unpack</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
                <span class="c1"># skip if we already know it is not useful</span>
                <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;None of the live points satisfies the current region!&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span> <span class="n">active_u</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">):</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_refill_samples</span><span class="p">(</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">)</span>
                    <span class="n">nit</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">):</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pump_region</span><span class="p">(</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">,</span> <span class="n">active_u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_values</span><span class="o">=</span><span class="n">active_values</span><span class="p">)</span>
                    <span class="n">nit</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Lmin</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">logl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_update_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">active_u</span><span class="p">,</span> <span class="n">active_node_ids</span><span class="p">,</span>
        <span class="n">bootstrap_rootids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active_rootids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nbootstraps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">minvol</span><span class="o">=</span><span class="mf">0.</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a new MLFriends region from `active_u`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        active_u: array of floats</span>
<span class="sd">            current live points</span>
<span class="sd">        active_node_ids: 2d array of ints</span>
<span class="sd">            which bootstrap initialisation the points belong to.</span>
<span class="sd">        active_rootids: 2d array of ints</span>
<span class="sd">            roots active in each bootstrap initialisation</span>
<span class="sd">        bootstrap_rootids: array of ints</span>
<span class="sd">            bootstrap samples. if None, they are drawn fresh.</span>
<span class="sd">        nbootstraps: int</span>
<span class="sd">            number of bootstrap rounds</span>
<span class="sd">        minvol: float</span>
<span class="sd">            expected current minimum volume of region.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        updated: bool</span>
<span class="sd">            True if update was made, False if previous region remained.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">nbootstraps</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if self.log:</span>
            <span class="c1">#    self.logger.debug(&quot;building first region ...&quot;)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="n">AffineLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="n">ScalingLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">,</span> <span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">MLFriends</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span> <span class="o">=</span> <span class="n">active_node_ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="ow">is</span> <span class="kc">None</span>

            <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">compute_enlargement</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">,</span>
                <span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbootstraps</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">))</span>
            <span class="c1"># rng=np.random.RandomState(self.mpi_rank))</span>
            <span class="c1"># print(&quot;MLFriends built. r=%f&quot; % r**0.5)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">)</span>
                <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="n">r</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">enlarge</span> <span class="o">=</span> <span class="n">f</span>
            <span class="c1"># if self.log:</span>
            <span class="c1">#     self.logger.debug(&quot;building first region ... r=%e, f=%e&quot; % (r, f))</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># verify correctness:</span>
            <span class="c1"># self.region.create_ellipsoid(minvol=minvol)</span>
            <span class="c1"># assert self.region.inside(active_u).all(), self.region.inside(active_u).mean()</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">need_accept</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we have been told that radius is currently invalid</span>
            <span class="c1"># we need to bootstrap back to a valid state</span>

            <span class="c1"># compute radius given current transformLayer</span>
            <span class="n">oldu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">active_u</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">set_transformLayer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="p">)</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">compute_enlargement</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">,</span>
                <span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbootstraps</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">))</span>
            <span class="c1"># rng=np.random.RandomState(self.mpi_rank))</span>
            <span class="c1"># print(&quot;MLFriends built. r=%f&quot; % r**0.5)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">)</span>
                <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="n">r</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">enlarge</span> <span class="o">=</span> <span class="n">f</span>

            <span class="c1"># print(&quot;made first region, r=%e&quot; % (r))</span>

            <span class="c1"># now that we have r, can do clustering</span>
            <span class="c1"># self.transformLayer.nclusters, self.transformLayer.clusterids, _ = update_clusters(</span>
            <span class="c1">#    self.region.u, self.region.unormed, self.region.maxradiussq)</span>
            <span class="c1"># but such reclustering would forget the cluster ids</span>

            <span class="c1"># instead, track the clusters from before by matching manually</span>
            <span class="n">oldt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">oldu</span><span class="p">)</span>
            <span class="n">clusterids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">active_u</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">nnearby</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ci</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># find points from that cluster</span>
                <span class="n">oldti</span> <span class="o">=</span> <span class="n">oldt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="n">ci</span><span class="p">]</span>
                <span class="c1"># identify which new points are near this cluster</span>
                <span class="n">find_nearby</span><span class="p">(</span><span class="n">oldti</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span> <span class="n">nnearby</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">nnearby</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="c1"># assign the nearby ones to this cluster</span>
                <span class="c1"># if they have not been set yet</span>
                <span class="c1"># if they have, set them to -1</span>
                <span class="n">clusterids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">clusterids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># print(&quot;following clusters, nc=%d&quot; % r, self.transformLayer.nclusters,</span>
            <span class="c1">#    np.unique(clusterids, return_counts=True))</span>

            <span class="c1"># clusters we are unsure about (double assignments) go unassigned</span>
            <span class="n">clusterids</span><span class="p">[</span><span class="n">clusterids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># tell scaling layer the correct cluster information</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">=</span> <span class="n">clusterids</span>

            <span class="c1"># we want the clustering to repeat to remove remaining zeros</span>
            <span class="n">need_accept</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

            <span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">)</span>

            <span class="c1"># verify correctness:</span>
            <span class="c1"># self.region.create_ellipsoid(minvol=minvol)</span>
            <span class="c1"># assert self.region.inside(active_u).all(), self.region.inside(active_u).mean()</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">)</span>
        <span class="c1"># rebuild space</span>
        <span class="c1"># print()</span>
        <span class="c1"># print(&quot;rebuilding space...&quot;, active_u.shape, active_u)</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nextTransformLayer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">create_new</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span> <span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
                <span class="c1"># nextTransformLayer = ScalingLayer(wrapped_dims=self.wrapped_axes)</span>
                <span class="c1"># nextTransformLayer.optimize(active_u, active_u)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">smallest_cluster</span> <span class="o">=</span> <span class="n">cluster_sizes</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">smallest_cluster</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;clustering found some stray points [need_accept=</span><span class="si">%s</span><span class="s2">] </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">need_accept</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                <span class="n">nextregion</span> <span class="o">=</span> <span class="n">MLFriends</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">nextTransformLayer</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">unormed</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="k">assert</span> <span class="kc">False</span>
                    <span class="c1"># self.logger.warn(&quot;not updating region because new transform gave inf/nans&quot;)</span>
                    <span class="c1"># self.region.create_ellipsoid(minvol=minvol)</span>
                    <span class="c1"># return updated</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">nclusters</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;overclustered_</span><span class="si">%d</span><span class="s1">.npz&#39;</span> <span class="o">%</span> <span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">nclusters</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found a lot of clusters: </span><span class="si">%d</span><span class="s2"> (</span><span class="si">%d</span><span class="s2"> with &gt;1 members)&quot;</span><span class="p">,</span>
                                         <span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">nclusters</span><span class="p">,</span> <span class="p">(</span><span class="n">cluster_sizes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

                    <span class="c1">#if not os.path.exists(filename):</span>
                    <span class="c1">#    self.logger.info(&quot;A lot of clusters! writing debug output file &#39;%s&#39;&quot;, filename)</span>
                    <span class="c1">#    np.savez(filename,</span>
                    <span class="c1">#        u=nextregion.u, unormed=nextregion.unormed,</span>
                    <span class="c1">#        maxradiussq=nextregion.maxradiussq,</span>
                    <span class="c1">#        u0=self.region.u, unormed0=self.region.unormed,</span>
                    <span class="c1">#        maxradiussq0=self.region.maxradiussq)</span>
                    <span class="c1">#    np.savetxt(&#39;overclustered_u_%d.txt&#39; % nextTransformLayer.nclusters, nextregion.u)</span>
                    <span class="c1"># assert nextTransformLayer.nclusters &lt; 20, nextTransformLayer.nclusters</span>

                <span class="c1"># if self.log:</span>
                <span class="c1">#     self.logger.info(&quot;computing maxradius...&quot;)</span>
                <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">compute_enlargement</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">,</span>
                    <span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbootstraps</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">))</span>
                <span class="c1"># rng=np.random.RandomState(self.mpi_rank))</span>
                <span class="c1"># print(&quot;MLFriends built. r=%f&quot; % r**0.5)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                    <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">)</span>
                    <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">)</span>

                <span class="n">nextregion</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">nextregion</span><span class="o">.</span><span class="n">enlarge</span> <span class="o">=</span> <span class="n">f</span>
                <span class="c1"># verify correctness:</span>
                <span class="n">nextregion</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">active_u</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">active_u</span><span class="p">))</span>
                <span class="c1"># assert nextregion.inside(active_u).all(), (&quot;live points should live in new region, but only %.3f%% do.&quot; % (100 * nextregion.inside(active_u).mean()), active_u)</span>
                <span class="n">good_region</span> <span class="o">=</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="c1"># assert good_region</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good_region</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;constructed region is inconsistent (maxr=</span><span class="si">%f</span><span class="s2">,enlarge=</span><span class="si">%f</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s1">&#39;inconsistent_region.npz&#39;</span><span class="p">,</span>
                        <span class="n">u</span><span class="o">=</span><span class="n">nextregion</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">unormed</span><span class="o">=</span><span class="n">nextregion</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span>
                        <span class="n">maxradiussq</span><span class="o">=</span><span class="n">nextregion</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span>
                        <span class="n">u0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">unormed0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span>
                        <span class="n">maxradiussq0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;inconsistent_region.txt&#39;</span><span class="p">,</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>

                <span class="c1"># good_region = good_region and region.transformLayer.nclusters * 5 &lt; len(active_u)</span>

                <span class="c1"># if self.log:</span>
                <span class="c1">#     self.logger.debug(&quot;building new region ... r=%e, f=%e&quot; % (r, f))</span>
                <span class="c1"># print(&quot;MLFriends computed: r=%e nc=%d&quot; % (r, nextTransformLayer.nclusters))</span>
                <span class="c1"># force shrinkage of volume</span>
                <span class="c1"># this is to avoid re-connection of dying out nodes</span>
                <span class="k">if</span> <span class="n">good_region</span> <span class="ow">and</span> <span class="p">(</span><span class="n">need_accept</span> <span class="ow">or</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">()):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">nextregion</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span> <span class="o">=</span> <span class="n">active_node_ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="c1"># if self.log:</span>
                    <span class="c1">#     self.logger.debug(&quot;region updated: V=%e R=%e&quot; % (self.region.estimate_volume(), r))</span>
                    <span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">need_accept</span><span class="p">,</span> <span class="n">updated</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Warning</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;not updating region&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">FloatingPointError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;not updating region&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;not updating region&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">updated</span>

    <span class="k">def</span> <span class="nf">_expand_nodes_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expand nodes before `Lmin` to have `nnodes_needed`.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Llo: float</span>
<span class="sd">            lowest parent sampled (-np.inf if sampling from root)</span>
<span class="sd">        Lhi: float</span>
<span class="sd">            Lmin</span>
<span class="sd">        target_min_num_children: int</span>
<span class="sd">            number of children that need to be maintained between Llo, Lhi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">parents</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">find_nodes_before</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">)</span>
        <span class="n">target_min_num_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widen_nodes</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Llo</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">)</span>
        <span class="n">Lhi</span> <span class="o">=</span> <span class="n">Lmin</span>
        <span class="k">return</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">target_min_num_children</span>

    <span class="k">def</span> <span class="nf">_should_node_be_expanded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span>
        <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">minimal_widths_sequence</span><span class="p">,</span> <span class="n">target_min_num_children</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">parallel_values</span><span class="p">,</span> <span class="n">max_ncalls</span><span class="p">,</span> <span class="n">max_iters</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if node needs new children.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expand_node: bool</span>
<span class="sd">            True if should sample a new point</span>
<span class="sd">            based on this node (above its likelihood value Lmin).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        it: int</span>
<span class="sd">            current iteration</span>
<span class="sd">        node: node</span>
<span class="sd">            The node to consider</span>
<span class="sd">        parallel_values: array of floats</span>
<span class="sd">            loglikelihoods of live points</span>
<span class="sd">        max_ncalls: int</span>
<span class="sd">            maximum number of likelihood function calls allowed</span>
<span class="sd">        max_iters: int</span>
<span class="sd">            maximum number of nested sampling iteration allowed</span>
<span class="sd">        Llo, Lhi, minimal_widths_sequence, target_min_num_children:</span>
<span class="sd">            Current strategy parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Lmin</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
        <span class="n">nlive</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parallel_values</span><span class="p">)</span>
        <span class="n">expand_node</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">Lmin</span> <span class="o">&lt;=</span> <span class="n">Lhi</span> <span class="ow">and</span> <span class="n">Llo</span> <span class="o">&lt;=</span> <span class="n">Lhi</span><span class="p">:</span>
            <span class="c1"># we should continue to progress towards Lhi</span>
            <span class="k">while</span> <span class="n">Lmin</span> <span class="o">&gt;</span> <span class="n">minimal_widths_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">minimal_widths_sequence</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># get currently desired width</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">minimal_width_clusters</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># compute number of clusters with more than 1 element</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">nclusters</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_sizes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">minimal_width_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span>

            <span class="n">minimal_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimal_widths_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">minimal_width_clusters</span><span class="p">)</span>

            <span class="c1"># if already has children, no need to expand</span>
            <span class="c1"># if we are wider than the width required</span>
            <span class="c1"># we do not need to expand this one</span>
            <span class="c1"># expand_node = len(node.children) == 0</span>
            <span class="c1"># prefer 1 child, or the number required, if specified</span>
            <span class="n">expand_node</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># some exceptions:</span>
            <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">too_wide</span> <span class="o">=</span> <span class="n">nlive</span> <span class="o">&gt;</span> <span class="n">minimal_width</span>
                <span class="c1"># we have to expand the first iteration,</span>
                <span class="c1"># otherwise the integrator never sets H</span>

                <span class="k">if</span> <span class="n">too_wide</span><span class="p">:</span>
                    <span class="c1"># print(&quot;not expanding, because we are quite wide&quot;, nlive, minimal_width, minimal_widths_sequence)</span>
                    <span class="n">expand_node</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">max_ncalls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">&gt;=</span> <span class="n">max_ncalls</span><span class="p">:</span>
                    <span class="c1"># print(&quot;not expanding, because above max_ncall&quot;)</span>
                    <span class="n">expand_node</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">max_iters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&gt;=</span> <span class="n">max_iters</span><span class="p">:</span>
                    <span class="c1"># print(&quot;not expanding, because above max_iters&quot;)</span>
                    <span class="n">expand_node</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">expand_node</span>

<div class="viewcode-block" id="ReactiveNestedSampler.run"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_interval_iter_fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">show_status</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">viz_callback</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">dKL</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">frac_remain</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="n">Lepsilon</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
            <span class="n">min_ess</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_ncalls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_num_improvement_loops</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">min_num_live_points</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">cluster_num_live_points</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run until target convergence criteria are fulfilled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update_interval_iter_fraction: float</span>
<span class="sd">            Update region after (update_interval_iter_fraction*nlive) iterations.</span>

<span class="sd">        update_interval_ncall: int</span>
<span class="sd">            Update region after update_interval_ncall likelihood calls (not used).</span>

<span class="sd">        log_interval: int</span>
<span class="sd">            Update stdout status line every log_interval iterations</span>

<span class="sd">        show_status: bool</span>
<span class="sd">            show integration progress as a status line.</span>
<span class="sd">            If no output desired, set to False.</span>

<span class="sd">        viz_callback: function</span>
<span class="sd">            callback function when region was rebuilt. Allows to</span>
<span class="sd">            show current state of the live points. </span>
<span class="sd">            See :func:`nicelogger` or :class:`LivePointsWidget`.</span>
<span class="sd">            If no output desired, set to False.</span>

<span class="sd">        dlogz: float</span>
<span class="sd">            Target evidence uncertainty. This is the std</span>
<span class="sd">            between bootstrapped logz integrators.</span>

<span class="sd">        dKL: float</span>
<span class="sd">            Target posterior uncertainty. This is the</span>
<span class="sd">            Kullback-Leibler divergence in nat between bootstrapped integrators.</span>

<span class="sd">        frac_remain: float</span>
<span class="sd">            Integrate until this fraction of the integral is left in the remainder.</span>
<span class="sd">            Set to a low number (1e-2 ... 1e-5) to make sure peaks are discovered.</span>
<span class="sd">            Set to a higher number (0.5) if you know the posterior is simple.</span>

<span class="sd">        Lepsilon: float</span>
<span class="sd">            Terminate when live point likelihoods are all the same,</span>
<span class="sd">            within Lepsilon tolerance. Increase this when your likelihood</span>
<span class="sd">            function is inaccurate, to avoid unnecessary search.</span>

<span class="sd">        min_ess: int</span>
<span class="sd">            Target number of effective posterior samples.</span>

<span class="sd">        max_iters: int</span>
<span class="sd">            maximum number of integration iterations.</span>

<span class="sd">        max_ncalls: int</span>
<span class="sd">            stop after this many likelihood evaluations.</span>

<span class="sd">        max_num_improvement_loops: int</span>
<span class="sd">            run() tries to assess iteratively where more samples are needed.</span>
<span class="sd">            This number limits the number of improvement loops.</span>

<span class="sd">        min_num_live_points: int</span>
<span class="sd">            minimum number of live points throughout the run</span>

<span class="sd">        cluster_num_live_points: int</span>
<span class="sd">            require at least this many live points per detected cluster</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if viz_callback == &#39;auto&#39;:</span>
        <span class="c1">#    viz_callback = get_default_viz_callback()</span>

        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_iter</span><span class="p">(</span>
            <span class="n">update_interval_iter_fraction</span><span class="o">=</span><span class="n">update_interval_iter_fraction</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="n">update_interval_ncall</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="n">log_interval</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="n">dlogz</span><span class="p">,</span> <span class="n">dKL</span><span class="o">=</span><span class="n">dKL</span><span class="p">,</span>
            <span class="n">Lepsilon</span><span class="o">=</span><span class="n">Lepsilon</span><span class="p">,</span> <span class="n">frac_remain</span><span class="o">=</span><span class="n">frac_remain</span><span class="p">,</span>
            <span class="n">min_ess</span><span class="o">=</span><span class="n">min_ess</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="n">max_iters</span><span class="p">,</span>
            <span class="n">max_ncalls</span><span class="o">=</span><span class="n">max_ncalls</span><span class="p">,</span> <span class="n">max_num_improvement_loops</span><span class="o">=</span><span class="n">max_num_improvement_loops</span><span class="p">,</span>
            <span class="n">min_num_live_points</span><span class="o">=</span><span class="n">min_num_live_points</span><span class="p">,</span>
            <span class="n">cluster_num_live_points</span><span class="o">=</span><span class="n">cluster_num_live_points</span><span class="p">,</span>
            <span class="n">show_status</span><span class="o">=</span><span class="n">show_status</span><span class="p">,</span>
            <span class="n">viz_callback</span><span class="o">=</span><span class="n">viz_callback</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;did a run_iter pass!&quot;</span><span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;done iterating.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.run_iter"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.run_iter">[docs]</a>    <span class="k">def</span> <span class="nf">run_iter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_interval_iter_fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">dKL</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">frac_remain</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="n">Lepsilon</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
            <span class="n">min_ess</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_ncalls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_num_improvement_loops</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">min_num_live_points</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">cluster_num_live_points</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
            <span class="n">show_status</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">viz_callback</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate towards convergence.</span>

<span class="sd">        Use as an iterator like so::</span>

<span class="sd">            for result in sampler.run_iter(...):</span>
<span class="sd">                print(&#39;lnZ = %(logz).2f +- %(logzerr).2f&#39; % result)</span>

<span class="sd">        Parameters as described in run() method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># frac_remain=1  means 1:1 -&gt; dlogz=log(0.5)</span>
        <span class="c1"># frac_remain=0.1 means 1:10 -&gt; dlogz=log(0.1)</span>
        <span class="c1"># dlogz_min = log(1./(1 + frac_remain))</span>
        <span class="c1"># dlogz_min = -log1p(frac_remain)</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">frac_remain</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;To achieve the desired logz accuracy, set frac_remain to a value much smaller than </span><span class="si">%s</span><span class="s2"> (currently: </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dlogz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frac_remain</span><span class="p">))</span>

        <span class="c1"># if self.log:</span>
        <span class="c1">#     self.logger.info(&#39;Using MPI with rank [%d]&#39; % (self.mpi_rank))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;PointStore: have </span><span class="si">%d</span><span class="s2"> items&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">assert</span> <span class="n">min_num_live_points</span> <span class="o">&gt;=</span> <span class="n">cluster_num_live_points</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;min_num_live_points(</span><span class="si">%d</span><span class="s1">) cannot be less than cluster_num_live_points(</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min_num_live_points</span><span class="p">,</span> <span class="n">cluster_num_live_points</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_num_live_points</span> <span class="o">=</span> <span class="n">min_num_live_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_num_live_points</span> <span class="o">=</span> <span class="n">cluster_num_live_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_slow_warned</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">viz_callback</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">viz_callback</span> <span class="o">=</span> <span class="n">get_default_viz_callback</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_widen_roots</span><span class="p">(</span><span class="n">min_num_live_points</span><span class="p">)</span>

        <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">strategy_stale</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">minimal_widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target_min_num_children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">improvement_it</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">assert</span> <span class="n">max_iters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_iters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Invalid value for max_iters: </span><span class="si">%s</span><span class="s2">. Set to None or positive number&quot;</span> <span class="o">%</span> <span class="n">max_iters</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">max_ncalls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_ncalls</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Invalid value for max_ncalls: </span><span class="si">%s</span><span class="s2">. Set to None or positive number&quot;</span> <span class="o">%</span> <span class="n">max_ncalls</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span>

            <span class="n">nroots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">update_interval_ncall</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">update_interval_ncall</span> <span class="o">=</span> <span class="n">nroots</span>

            <span class="k">if</span> <span class="n">log_interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">nroots</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">log_interval</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">log_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;log_interval must be &gt;= 1&quot;</span><span class="p">)</span>

            <span class="n">explorer</span> <span class="o">=</span> <span class="n">BreadthFirstIterator</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
            <span class="c1"># Integrating thing</span>
            <span class="n">main_iterator</span> <span class="o">=</span> <span class="n">MultiCounter</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">),</span>
                <span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bootstraps</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">),</span>
                <span class="n">random</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lmax</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">it_at_first_region</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span><span class="p">:</span>
                <span class="n">ndraw</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ndraw</span> <span class="o">=</span> <span class="mi">40</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Llo</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhi</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Exploring (in particular: L=</span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2">) ...&quot;</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">)</span>
            <span class="c1"># print_tree(roots[:5], title=&quot;Tree:&quot;)</span>
            <span class="n">region_sequence</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">minimal_widths_sequence</span> <span class="o">=</span> <span class="n">_sequentialize_width_sequence</span><span class="p">(</span><span class="n">minimal_widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_num_live_points</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;minimal_widths_sequence: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">minimal_widths_sequence</span><span class="p">)</span>

            <span class="n">saved_nodeids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">saved_logl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ncall_at_run_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span>
            <span class="n">ncall_region_at_run_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span>
            <span class="c1"># next_update_interval_ncall = -1</span>
            <span class="n">next_update_interval_iter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">last_status</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1"># we go through each live point (regardless of root) by likelihood value</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">next_node</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">next_node</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">active_nodes</span><span class="p">,</span> <span class="n">active_rootids</span><span class="p">,</span> <span class="n">active_values</span><span class="p">,</span> <span class="n">active_node_ids</span><span class="p">)</span> <span class="o">=</span> <span class="n">next_node</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rootid</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="c1"># this is the likelihood level we have to improve upon</span>
                <span class="n">Lmin</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

                <span class="c1"># if within suggested range, expand</span>
                <span class="k">if</span> <span class="n">strategy_stale</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">Lmin</span> <span class="o">&lt;=</span> <span class="n">Lhi</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhi</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">active_values</span> <span class="o">==</span> <span class="n">Lmin</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="c1"># check with advisor if we want to expand this node</span>
                    <span class="n">Llo_prev</span><span class="p">,</span> <span class="n">Lhi_prev</span> <span class="o">=</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span>
                    <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_strategy_advice</span><span class="p">(</span><span class="n">Lmin</span><span class="p">,</span>
                        <span class="n">active_values</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">minimal_widths</span><span class="p">,</span>
                        <span class="n">frac_remain</span><span class="p">,</span> <span class="n">Lepsilon</span><span class="o">=</span><span class="n">Lepsilon</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhi</span><span class="p">):</span>
                        <span class="n">strategy_altered</span> <span class="o">=</span> <span class="n">Llo</span> <span class="o">!=</span> <span class="n">Llo_prev</span> <span class="ow">or</span> <span class="n">Lhi</span> <span class="o">!=</span> <span class="n">Lhi_prev</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">strategy_altered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Llo_prev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Llo</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhi_prev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhi</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">strategy_altered</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;strategy update: L range to expand: </span><span class="si">%.3f</span><span class="s2">-</span><span class="si">%.3f</span><span class="s2"> have: </span><span class="si">%.2f</span><span class="s2"> logZ=</span><span class="si">%.2f</span><span class="s2"> logZremain=</span><span class="si">%.2f</span><span class="s2">&quot;</span><span class="p">,</span>
                                          <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZremain</span><span class="p">)</span>

                    <span class="c1"># when we are going to the peak, numerical accuracy</span>
                    <span class="c1"># can become an issue. We should try not to get stuck there</span>
                    <span class="n">strategy_stale</span> <span class="o">=</span> <span class="n">Lhi</span> <span class="o">-</span> <span class="n">Llo</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lepsilon</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>

                <span class="n">expand_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_node_be_expanded</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">minimal_widths_sequence</span><span class="p">,</span> <span class="n">target_min_num_children</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">active_values</span><span class="p">,</span> <span class="n">max_ncalls</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">)</span>

                <span class="n">region_fresh</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">expand_node</span><span class="p">:</span>
                    <span class="c1"># sample a new point above Lmin</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">getu</span><span class="p">(</span><span class="n">active_node_ids</span><span class="p">)</span>
                    <span class="n">nlive</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span>
                    <span class="c1"># first we check that the region is up-to-date</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="n">next_update_interval_iter</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">it_at_first_region</span> <span class="o">=</span> <span class="n">it</span>
                        <span class="n">region_fresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_region</span><span class="p">(</span>
                            <span class="n">active_u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_node_ids</span><span class="o">=</span><span class="n">active_node_ids</span><span class="p">,</span>
                            <span class="n">active_rootids</span><span class="o">=</span><span class="n">active_rootids</span><span class="p">,</span>
                            <span class="n">bootstrap_rootids</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">rootids</span><span class="p">[</span><span class="mi">1</span><span class="p">:,],</span>
                            <span class="n">nbootstraps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_bootstraps</span><span class="p">,</span>
                            <span class="n">minvol</span><span class="o">=</span><span class="n">exp</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span><span class="p">))</span>

                        <span class="k">if</span> <span class="n">region_fresh</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span><span class="o">.</span><span class="n">region_changed</span><span class="p">(</span><span class="n">active_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

                        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">nclusters</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_sizes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="n">region_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">nlive</span><span class="p">,</span> <span class="n">nclusters</span><span class="p">))</span>

                        <span class="c1"># next_update_interval_ncall = self.ncall + (update_interval_ncall or nlive)</span>
                        <span class="n">update_interval_iter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">update_interval_iter_fraction</span> <span class="o">*</span> <span class="n">nlive</span><span class="p">))</span>
                        <span class="n">next_update_interval_iter</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">update_interval_iter</span>

                        <span class="c1"># provide nice output to follow what is going on</span>
                        <span class="c1"># but skip if we are resuming</span>
                        <span class="c1">#  and (self.ncall != ncall_at_run_start and it_at_first_region == it)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">viz_callback</span><span class="p">:</span>
                            <span class="n">active_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">getp</span><span class="p">(</span><span class="n">active_node_ids</span><span class="p">)</span>
                            <span class="n">viz_callback</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">active_p</span><span class="p">,</span> <span class="n">logl</span><span class="o">=</span><span class="n">active_values</span><span class="p">),</span>
                                <span class="n">info</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">it</span><span class="p">,</span> <span class="n">ncall</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span>
                                <span class="n">logz</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="n">logz_remain</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZremain</span><span class="p">,</span>
                                <span class="n">logvol</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span><span class="p">,</span>
                                <span class="n">paramnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">,</span>
                                <span class="n">paramlims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_limits</span><span class="p">,</span>
                                <span class="p">),</span>
                                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">transformLayer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="p">,</span>
                                <span class="n">region_fresh</span><span class="o">=</span><span class="n">region_fresh</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">nlive</span> <span class="o">&lt;</span> <span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span> <span class="ow">and</span> <span class="n">improvement_it</span> <span class="o">&lt;</span> <span class="n">max_num_improvement_loops</span><span class="p">:</span>
                        <span class="c1"># make wider here</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%d</span><span class="s2"> clusters, but only have </span><span class="si">%d</span><span class="s2"> live points, want </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">nclusters</span><span class="p">,</span> <span class="n">nlive</span><span class="p">,</span>
                                             <span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span><span class="p">)</span>
                        <span class="k">break</span>

                    <span class="c1"># sample point</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_point</span><span class="p">(</span><span class="n">Lmin</span><span class="o">=</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="o">=</span><span class="n">ndraw</span><span class="p">,</span> <span class="n">active_u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_values</span><span class="o">=</span><span class="n">active_values</span><span class="p">)</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

                    <span class="c1"># identify which point is being replaced (from when we built the region)</span>
                    <span class="n">worst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">id</span>
                    <span class="c1"># if we keep the region informed about the new live points</span>
                    <span class="c1"># then the region follows the live points even if maxradius is not updated</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

                    <span class="c1"># if we track the cluster assignment, then in the next round</span>
                    <span class="c1"># the ids with the same members are likely to have the same id</span>
                    <span class="c1"># this is imperfect</span>
                    <span class="c1"># transformLayer.clusterids[worst] = transformLayer.clusterids[father[ib]]</span>
                    <span class="c1"># so we just mark the replaced ones as &quot;unassigned&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># if self.log:</span>
                    <span class="c1">#     self.logger.debug(&quot;replacing node&quot;, Lmin, &quot;from&quot;, rootid, &quot;with&quot;, L)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="p">(</span><span class="n">region_fresh</span> <span class="ow">or</span> <span class="n">it</span> <span class="o">%</span> <span class="n">log_interval</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">last_status</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">):</span>
                        <span class="c1"># nicelogger(self.paramnames, active_u, active_v, active_logl, it, ncall, logz, logz_remain, region=region)</span>
                        <span class="n">last_status</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="n">ncall_here</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">-</span> <span class="n">ncall_at_run_start</span>
                        <span class="n">it_here</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">it_at_first_region</span>
                        <span class="k">if</span> <span class="n">show_status</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">Lmin</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e8</span><span class="p">:</span>
                                <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;Z=</span><span class="si">%.1g</span><span class="s1">(</span><span class="si">%.2f%%</span><span class="s1">) | Like=</span><span class="si">%.2g</span><span class="s1">..</span><span class="si">%.2g</span><span class="s1"> [</span><span class="si">%.4g</span><span class="s1">..</span><span class="si">%.4g</span><span class="s1">]</span><span class="si">%s</span><span class="s1">| it/evals=</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1"> eff=</span><span class="si">%.4f%%</span><span class="s1"> N=</span><span class="si">%d</span><span class="s1"> </span><span class="se">\r</span><span class="s1">&#39;</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;Z=</span><span class="si">%.1f</span><span class="s1">(</span><span class="si">%.2f%%</span><span class="s1">) | Like=</span><span class="si">%.2f</span><span class="s1">..</span><span class="si">%.2f</span><span class="s1"> [</span><span class="si">%.4f</span><span class="s1">..</span><span class="si">%.4f</span><span class="s1">]</span><span class="si">%s</span><span class="s1">| it/evals=</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1"> eff=</span><span class="si">%.4f%%</span><span class="s1"> N=</span><span class="si">%d</span><span class="s1"> </span><span class="se">\r</span><span class="s1">&#39;</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">txt</span> <span class="o">%</span> <span class="p">(</span>
                                             <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">remainder_fraction</span><span class="p">),</span>
                                             <span class="n">Lmin</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span> <span class="k">if</span> <span class="n">strategy_stale</span> <span class="k">else</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">ncall_here</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">it_here</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ncall_here</span><span class="p">,</span>
                                             <span class="n">nlive</span><span class="p">))</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                        <span class="c1"># if efficiency becomes low, bulk-process larger arrays</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span><span class="p">:</span>
                            <span class="c1"># inefficiency is the number of (region) proposals per successful number of iterations</span>
                            <span class="c1"># but improves by parallelism (because we need only the per-process inefficiency)</span>
                            <span class="c1"># sampling_inefficiency = (self.ncall - ncall_at_run_start + 1) / (it + 1) / self.mpi_size</span>
                            <span class="n">sampling_inefficiency</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span> <span class="o">-</span> <span class="n">ncall_region_at_run_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span>
                            <span class="c1"># (self.ncall - ncall_at_run_start + 1) (self.ncall_region - self.ncall_region_at_run_start) / self.</span>
                            <span class="n">ndraw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">16384</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">sampling_inefficiency</span><span class="p">)))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we do not want to count iterations without work</span>
                    <span class="c1"># otherwise efficiency becomes &gt; 1</span>
                    <span class="n">it_at_first_region</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">saved_nodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">saved_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lmin</span><span class="p">)</span>

                <span class="c1"># inform iterators (if it is their business) about the arc</span>
                <span class="n">main_iterator</span><span class="o">.</span><span class="n">passing_node</span><span class="p">(</span><span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">active_rootids</span><span class="p">,</span> <span class="n">active_values</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># the region radius needs to increase if nlive decreases</span>
                    <span class="c1"># radius is not reliable, so set to inf</span>
                    <span class="c1"># (heuristics do not work in practice)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># ask for the region to be rebuilt</span>
                    <span class="n">next_update_interval_iter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">explorer</span><span class="o">.</span><span class="n">expand_children_of</span><span class="p">(</span><span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Explored until L=</span><span class="si">%.1g</span><span class="s2">  &quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># print_tree(roots[::10])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_update_results</span><span class="p">(</span><span class="n">main_iterator</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">,</span> <span class="n">saved_nodeids</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span>

            <span class="k">if</span> <span class="n">max_ncalls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">&gt;=</span> <span class="n">max_ncalls</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reached maximum number of likelihood calls (</span><span class="si">%d</span><span class="s1"> &gt; </span><span class="si">%d</span><span class="s1">)...&#39;</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span> <span class="n">max_ncalls</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">improvement_it</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">max_num_improvement_loops</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">improvement_it</span> <span class="o">&gt;</span> <span class="n">max_num_improvement_loops</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reached maximum number of improvement loops.&#39;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">ncall_at_run_start</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="ow">and</span> <span class="n">improvement_it</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No changes made. Probably the strategy was to explore in the remainder, but it is irrelevant already; try decreasing frac_remain.&#39;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">Lmax</span> <span class="o">=</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">region_sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Lmin</span><span class="p">,</span> <span class="n">nlive</span><span class="p">,</span> <span class="n">nclusters</span> <span class="o">=</span> <span class="n">region_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nnodes_needed</span> <span class="o">=</span> <span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span>
                <span class="k">if</span> <span class="n">nlive</span> <span class="o">&lt;</span> <span class="n">nnodes_needed</span><span class="p">:</span>
                    <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">target_min_num_children_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_nodes_before</span><span class="p">(</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span> <span class="ow">or</span> <span class="n">nlive</span><span class="p">)</span>
                    <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target_min_num_children_new</span><span class="p">)</span>
                    <span class="c1"># if self.log:</span>
                    <span class="c1">#     print_tree(self.root.children[::10])</span>
                    <span class="n">minimal_widths</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Llo</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">))</span>
                    <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="c1"># self.logger.info(&#39;  logZ = %.4f +- %.4f (main)&#39; % (main_iterator.logZ, main_iterator.logZerr))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  logZ = </span><span class="si">%.4g</span><span class="s1"> +- </span><span class="si">%.4g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ_bs</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="p">)</span>

            <span class="n">saved_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">)</span>
            <span class="p">(</span><span class="n">Llo_Z</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Lhi_ess</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_strategy</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">dlogz</span><span class="o">=</span><span class="n">dlogz</span><span class="p">,</span> <span class="n">dKL</span><span class="o">=</span><span class="n">dKL</span><span class="p">,</span> <span class="n">min_ess</span><span class="o">=</span><span class="n">min_ess</span><span class="p">)</span>
            <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Llo_Z</span><span class="p">)</span>
            <span class="n">Lhi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lhi_ess</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">)</span>
            <span class="c1"># to avoid numerical issues when all likelihood values are the same</span>
            <span class="n">Lhi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Lhi</span><span class="p">,</span> <span class="n">saved_logl</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.001</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="n">recv_Llo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">Llo</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_Llo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_Llo</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_Lhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">Lhi</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_Lhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_Lhi</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">recv_Llo</span><span class="p">)</span>
                <span class="n">Lhi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">recv_Lhi</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Llo</span> <span class="o">&lt;=</span> <span class="n">Lhi</span><span class="p">:</span>
                <span class="c1"># if self.log:</span>
                <span class="c1">#     print_tree(roots, title=&quot;Tree before forking:&quot;)</span>
                <span class="n">parents</span><span class="p">,</span> <span class="n">parent_weights</span> <span class="o">=</span> <span class="n">find_nodes_before</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">Llo</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">count_tree_between</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">)</span>
                <span class="n">nnodes_needed</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Widening from </span><span class="si">%d</span><span class="s1"> to </span><span class="si">%d</span><span class="s1"> live points before L=</span><span class="si">%.1g</span><span class="s1">...&#39;</span><span class="p">,</span>
                                     <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">),</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">Llo</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">Llo</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_widen_nodes</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">parent_weights</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">))</span>
                <span class="n">minimal_widths</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">))</span>
                <span class="c1"># if self.log:</span>
                <span class="c1">#     print_tree(roots, title=&quot;Tree after forking:&quot;)</span>
                <span class="c1"># print(&#39;tree size:&#39;, count_tree(roots))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span></div>

    <span class="k">def</span> <span class="nf">_update_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">,</span> <span class="n">saved_nodeids</span><span class="p">):</span>
        <span class="c1"># print_tree(roots[0:5])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Likelihood function evaluations: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">)</span>
            <span class="c1"># self.logger.info(&#39;Tree size: height=%d width=%d&#39; % count_tree(self.root.children))</span>

        <span class="c1"># points with weights</span>
        <span class="c1"># saved_u = np.array([pp[nodeid].u for nodeid in saved_nodeids])</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logweights</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span><span class="p">)),</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logweights</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span><span class="p">))</span>

        <span class="n">saved_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">)</span>
        <span class="n">saved_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">getu</span><span class="p">(</span><span class="n">saved_nodeids</span><span class="p">)</span>
        <span class="n">saved_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">getp</span><span class="p">(</span><span class="n">saved_nodeids</span><span class="p">)</span>
        <span class="n">saved_logwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logweights</span><span class="p">)</span>
        <span class="n">saved_logwt0</span> <span class="o">=</span> <span class="n">saved_logwt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">saved_logwt_bs</span> <span class="o">=</span> <span class="n">saved_logwt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">logZ_bs</span> <span class="o">=</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">saved_logwt_bs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">saved_nodeids</span><span class="p">),</span> <span class="p">(</span><span class="n">saved_logwt_bs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">saved_nodeids</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="c1"># spread logZ_bs, saved_logwt_bs</span>
            <span class="n">recv_saved_logwt_bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">saved_logwt_bs</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_saved_logwt_bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_saved_logwt_bs</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">saved_logwt_bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_saved_logwt_bs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">recv_logZ_bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">logZ_bs</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">recv_logZ_bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_logZ_bs</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">logZ_bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_logZ_bs</span><span class="p">)</span>

        <span class="n">saved_wt_bs</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">saved_logwt_bs</span> <span class="o">+</span> <span class="n">saved_logl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">logZ_bs</span><span class="p">)</span>
        <span class="n">saved_wt0</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">saved_logwt0</span> <span class="o">+</span> <span class="n">saved_logl</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># compute fraction in tail</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">saved_wt0</span> <span class="o">/</span> <span class="n">saved_wt0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ess</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">tail_fraction</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">istail</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tail_fraction</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logzerr_tail</span> <span class="o">=</span> <span class="n">logaddexp</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">tail_fraction</span><span class="p">)</span> <span class="o">+</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">)</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logzerr_tail</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">logzerr_bs</span> <span class="o">=</span> <span class="p">(</span><span class="n">logZ_bs</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">logzerr_total</span> <span class="o">=</span> <span class="p">(</span><span class="n">logzerr_tail</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">logzerr_bs</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">resample_equal</span><span class="p">(</span><span class="n">saved_v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        
        <span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">),</span>
            <span class="n">logz</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="n">logzerr</span><span class="o">=</span><span class="n">logzerr_total</span><span class="p">,</span>
            <span class="n">logz_bs</span><span class="o">=</span><span class="n">logZ_bs</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
            <span class="n">logzerr_bs</span><span class="o">=</span><span class="n">logzerr_bs</span><span class="p">,</span>
            <span class="n">logz_single</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span>
            <span class="n">logzerr_tail</span><span class="o">=</span><span class="n">logzerr_tail</span><span class="p">,</span>
            <span class="n">logzerr_single</span><span class="o">=</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">all_H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_num_live_points</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">ess</span><span class="o">=</span><span class="n">ess</span><span class="p">,</span>
            <span class="n">paramnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">,</span>
            <span class="n">ncall</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">),</span>
            <span class="n">posterior</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">samples</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="n">stdev</span><span class="o">=</span><span class="n">samples</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="n">median</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="n">errlo</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mf">15.8655</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="n">errup</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mf">84.1345</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="p">),</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing samples and results to disk ...&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;equal_weighted_post.txt&#39;</span><span class="p">),</span>
                <span class="n">samples</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">),</span>
                <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;weighted_post.txt&#39;</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">saved_wt0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="o">-</span><span class="n">saved_logl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">saved_v</span><span class="p">)),</span>
                <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;weighted_post_untransformed.txt&#39;</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">saved_wt0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">saved_logl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">saved_u</span><span class="p">)),</span>
                <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;weighted_post.paramnames&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">],</span> <span class="s1">&#39;results.json&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">],</span> <span class="s1">&#39;post_summary.csv&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> 
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;posterior&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;stdev&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;errlo&#39;</span><span class="p">,</span> <span class="s1">&#39;errup&#39;</span><span class="p">)])],</span>
                    <span class="n">header</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;&quot;</span><span class="si">{0}</span><span class="s1">_mean&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_stdev&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_median&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_errlo&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_errup&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> 
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">]),</span>
                    <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing samples and results to disk ... done&quot;</span><span class="p">)</span>

        <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">weighted_samples</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">saved_v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">saved_wt0</span><span class="p">,</span> <span class="n">logw</span><span class="o">=</span><span class="n">saved_logwt0</span><span class="p">,</span>
                <span class="n">bs_w</span><span class="o">=</span><span class="n">saved_wt_bs</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">saved_logl</span><span class="p">),</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>

<div class="viewcode-block" id="ReactiveNestedSampler.store_tree"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.store_tree">[docs]</a>    <span class="k">def</span> <span class="nf">store_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store tree to disk (results/tree.hdf5).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">dump_tree</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;tree.hdf5&#39;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.print_results"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.print_results">[docs]</a>    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logZ</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">posterior</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give summary of marginal likelihood and parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;logZ = </span><span class="si">%(logz).3f</span><span class="s1"> +- </span><span class="si">%(logzerr).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  single instance: logZ = </span><span class="si">%(logz_single).3f</span><span class="s1"> +- </span><span class="si">%(logzerr_single).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  bootstrapped   : logZ = </span><span class="si">%(logz_bs).3f</span><span class="s1"> +- </span><span class="si">%(logzerr_bs).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  tail           : logZ = +- </span><span class="si">%(logzerr_tail).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                <span class="n">med</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sigma</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">.</span><span class="si">%d</span><span class="s1">f&#39;</span> <span class="o">%</span> <span class="n">i</span>
                <span class="n">fmts</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;    </span><span class="si">%-20s</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">fmt</span> <span class="o">+</span> <span class="s2">&quot; +- &quot;</span> <span class="o">+</span> <span class="n">fmt</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">fmts</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">med</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make corner, run and trace plots.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_corner</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_run</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_trace</span><span class="p">()</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot_corner"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot_corner">[docs]</a>    <span class="k">def</span> <span class="nf">plot_corner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make corner plot.</span>

<span class="sd">        Writes corner plot to plots/ directory if log directory was</span>
<span class="sd">        specified, otherwise show interactively.</span>

<span class="sd">        This does essentially::</span>

<span class="sd">            from ultranest.plot import cornerplot</span>
<span class="sd">            cornerplot(results)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.plot</span> <span class="k">import</span> <span class="n">cornerplot</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making corner plot ...&#39;</span><span class="p">)</span>
        <span class="n">cornerplot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;corner.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making corner plot ... done&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot_trace"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot_trace">[docs]</a>    <span class="k">def</span> <span class="nf">plot_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make trace plot.</span>

<span class="sd">        Write parameter trace diagnostic plots to plots/ directory</span>
<span class="sd">        if log directory specified, otherwise show interactively.</span>

<span class="sd">        This does essentially::</span>

<span class="sd">            from ultranest.plot import traceplot</span>
<span class="sd">            traceplot(results=results, labels=paramnames + derivedparamnames)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.plot</span> <span class="k">import</span> <span class="n">traceplot</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making trace plot ... &#39;</span><span class="p">)</span>
        <span class="n">paramnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span>
        <span class="c1"># get dynesty-compatible sequences</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">logz_sequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="p">)</span>
        <span class="n">traceplot</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">paramnames</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;trace.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making trace plot ... done&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot_run"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot_run">[docs]</a>    <span class="k">def</span> <span class="nf">plot_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make run plot.</span>

<span class="sd">        Write run diagnostic plots to plots/ directory</span>
<span class="sd">        if log directory specified, otherwise show interactively.</span>

<span class="sd">        This does essentially::</span>

<span class="sd">            from ultranest.plot import runplot</span>
<span class="sd">            runplot(results=results)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.plot</span> <span class="k">import</span> <span class="n">runplot</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making run plot ... &#39;</span><span class="p">)</span>
        <span class="c1"># get dynesty-compatible sequences</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">logz_sequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="p">)</span>
        <span class="n">runplot</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">,</span> <span class="n">logplot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;run.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making run plot ... done&#39;</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2020, Johannes Buchner

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>