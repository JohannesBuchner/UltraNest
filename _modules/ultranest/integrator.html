

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ultranest.integrator &mdash; UltraNest 3.3.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/icon.ico"/>
  
  
  
    <link rel="canonical" href="https://johannesbuchner.github.io/UltraNest/_modules/ultranest/integrator.html"/>
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> UltraNest
          

          
            
            <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">UltraNest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../method.html">Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using-ultranest.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../priors.html">Specifying priors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance.html">Tour of the features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../issues.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Release Notes</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-line.html">Time series fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-modelcomparison.html">Model comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-highd.html">Higher-dimensional fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-intrinsic-distribution.html">Tutorial: intrinsic distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-line.html">Tutorial: fitting a line</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-outliers.html">Tutorial: distribution with outliers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-sine-bayesian-workflow.html">Bayesian workflow</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">UltraNest</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ultranest.integrator</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ultranest.integrator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Ultranest calculates the Bayesian evidence and posterior samples of arbitrary models.&quot;&quot;&quot;</span>

<span class="c1"># Some parts are from the Nestle library by Kyle Barbary (https://github.com/kbarbary/nestle)</span>
<span class="c1"># Some parts are from the nnest library by Adam Moss (https://github.com/adammoss/nnest)</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">logaddexp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">create_logger</span><span class="p">,</span> <span class="n">make_run_dir</span><span class="p">,</span> <span class="n">resample_equal</span><span class="p">,</span> <span class="n">vol_prefactor</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">,</span> <span class="n">listify</span> <span class="k">as</span> <span class="n">_listify</span><span class="p">,</span> <span class="n">is_affine_transform</span><span class="p">,</span> <span class="n">normalised_kendall_tau_distance</span>
<span class="kn">from</span> <span class="nn">ultranest.mlfriends</span> <span class="kn">import</span> <span class="n">MLFriends</span><span class="p">,</span> <span class="n">AffineLayer</span><span class="p">,</span> <span class="n">ScalingLayer</span><span class="p">,</span> <span class="n">find_nearby</span><span class="p">,</span> <span class="n">WrappingEllipsoid</span><span class="p">,</span> <span class="n">RobustEllipsoidRegion</span>
<span class="kn">from</span> <span class="nn">.store</span> <span class="kn">import</span> <span class="n">HDF5PointStore</span><span class="p">,</span> <span class="n">TextPointStore</span><span class="p">,</span> <span class="n">NullPointStore</span>
<span class="kn">from</span> <span class="nn">.viz</span> <span class="kn">import</span> <span class="n">get_default_viz_callback</span><span class="p">,</span> <span class="n">nicelogger</span>
<span class="kn">from</span> <span class="nn">.ordertest</span> <span class="kn">import</span> <span class="n">UniformOrderAccumulator</span>
<span class="kn">from</span> <span class="nn">.netiter</span> <span class="kn">import</span> <span class="n">PointPile</span><span class="p">,</span> <span class="n">SingleCounter</span><span class="p">,</span> <span class="n">MultiCounter</span><span class="p">,</span> <span class="n">BreadthFirstIterator</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">count_tree_between</span><span class="p">,</span> <span class="n">find_nodes_before</span><span class="p">,</span> <span class="n">logz_sequence</span>
<span class="kn">from</span> <span class="nn">.netiter</span> <span class="kn">import</span> <span class="n">dump_tree</span><span class="p">,</span> <span class="n">combine_results</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ReactiveNestedSampler&#39;</span><span class="p">,</span> <span class="s1">&#39;NestedSampler&#39;</span><span class="p">,</span> <span class="s1">&#39;read_file&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_cumsum_range</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">dp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute quantile indices from probabilities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    pi: array</span>
<span class="sd">        probability of each item.</span>
<span class="sd">    dp: float</span>
<span class="sd">        Quantile (between 0 and 0.5).</span>

<span class="sd">    Returns:</span>
<span class="sd">    ---------</span>
<span class="sd">    index_lo: int</span>
<span class="sd">        Index of the item corresponding to quantile ``dp``.</span>
<span class="sd">    index_hi: int</span>
<span class="sd">        Index of the item corresponding to quantile ``1-dp``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ci</span> <span class="o">=</span> <span class="n">pi</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="n">ilo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ci</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ilo</span> <span class="o">=</span> <span class="n">ilo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ilo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">ihi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ci</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">dp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ihi</span> <span class="o">=</span> <span class="n">ihi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ihi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span>


<span class="k">def</span> <span class="nf">_sequentialize_width_sequence</span><span class="p">(</span><span class="n">minimal_widths</span><span class="p">,</span> <span class="n">min_width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Turn a list of required tree width into an ordered sequence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    minimal_widths: list of (Llo, Lhi, width)</span>
<span class="sd">        Defines the required width between Llo and Lhi.</span>
<span class="sd">    min_width: int</span>
<span class="sd">        Minimum width everywhere.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ---------</span>
<span class="sd">    Lsequence: list of (L, width)</span>
<span class="sd">        A sequence of L points and the expected tree width at and above it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Lpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_listify</span><span class="p">(</span>
        <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">L</span> <span class="k">for</span> <span class="n">L</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">minimal_widths</span><span class="p">],</span>
        <span class="p">[</span><span class="n">L</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">minimal_widths</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]))</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Lpoints</span><span class="p">))</span> <span class="o">*</span> <span class="n">min_width</span>

    <span class="k">for</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="n">minimal_widths</span><span class="p">:</span>
        <span class="c1"># all Lpoints within that range should be maximized to width</span>
        <span class="c1"># mask = np.logical_and(Lpoints &gt;= Llo, Lpoints &lt;= Lhi)</span>
        <span class="c1"># the following allows segments to specify -inf..L ranges</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">Lpoints</span> <span class="o">&lt;</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lpoints</span> <span class="o">&gt;</span> <span class="n">Lhi</span><span class="p">)</span>
        <span class="n">widths</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">widths</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

    <span class="c1"># the width has to monotonically increase to the maximum from both sides</span>
    <span class="c1"># so we fill up any intermediate dips</span>
    <span class="n">max_width</span> <span class="o">=</span> <span class="n">widths</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">widths</span> <span class="o">==</span> <span class="n">max_width</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">widest</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mid</span><span class="p">):</span>
        <span class="n">widest</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">widest</span><span class="p">,</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">widest</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">widest</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">widest</span><span class="p">,</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Lpoints</span><span class="p">,</span> <span class="n">widths</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_explore_iterator_batch</span><span class="p">(</span><span class="n">explorer</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">num_params</span><span class="p">,</span> <span class="n">pointpile</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">next_node</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">next_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">active_rootids</span><span class="p">,</span> <span class="n">active_values</span><span class="p">,</span> <span class="n">active_node_ids</span><span class="p">)</span> <span class="o">=</span> <span class="n">next_node</span>
        <span class="n">Lmin</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">Lmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_params</span><span class="p">]</span>

            <span class="k">assert</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">x_dim</span><span class="p">,)</span>
            <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_params</span><span class="p">,)</span>
            <span class="k">assert</span> <span class="n">logl</span> <span class="o">&gt;</span> <span class="n">Lmin</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">logl</span><span class="p">))</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="n">batch</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">active_values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">children</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">batchsize</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">batch</span>
            <span class="n">batch</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">explorer</span><span class="o">.</span><span class="n">expand_children_of</span><span class="p">(</span><span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">batch</span>



<span class="k">def</span> <span class="nf">resume_from_similar_file</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
    <span class="n">max_tau</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndraw</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change a stored UltraNest run to a modified loglikelihood/transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_dir: str</span>
<span class="sd">        Folder containing results</span>
<span class="sd">    x_dim: int</span>
<span class="sd">        number of dimensions</span>
<span class="sd">    loglikelihood: function</span>
<span class="sd">        new likelihood function</span>
<span class="sd">    transform: function</span>
<span class="sd">        new transform function</span>
<span class="sd">    verbose: bool</span>
<span class="sd">        show progress</span>
<span class="sd">    ndraw: int</span>
<span class="sd">        set to &gt;1 if functions can take advantage of vectorized computations</span>
<span class="sd">    max_tau: float</span>
<span class="sd">        Allowed dissimilarity in the live point ordering, quantified as</span>
<span class="sd">        normalised Kendall tau distance.</span>
<span class="sd">        </span>
<span class="sd">        max_tau=0 is the very conservative choice of stopping the warm start</span>
<span class="sd">        when the live point order differs.</span>
<span class="sd">        Near 1 are completely different live point orderings.</span>
<span class="sd">        Values in between permit mild disorder.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    sequence: dict</span>
<span class="sd">        contains arrays storing for each iteration estimates of:</span>

<span class="sd">            * logz: log evidence estimate</span>
<span class="sd">            * logzerr: log evidence uncertainty estimate</span>
<span class="sd">            * logvol: log volume estimate</span>
<span class="sd">            * samples_n: number of live points</span>
<span class="sd">            * logwt: log weight</span>
<span class="sd">            * logl: log likelihood</span>

<span class="sd">    final: dict</span>
<span class="sd">        same as ReactiveNestedSampler.results and</span>
<span class="sd">        ReactiveNestedSampler.run return values</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">h5py</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="s1">&#39;points.hdf5&#39;</span><span class="p">)</span>
    <span class="n">filepath2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="s1">&#39;points.hdf5.new&#39;</span><span class="p">)</span>
    <span class="n">fileobj</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">num_params</span> <span class="o">=</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">x_dim</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">][:]</span>
    <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">fileobj</span>

    <span class="n">pointstore2</span> <span class="o">=</span> <span class="n">HDF5PointStore</span><span class="p">(</span><span class="n">filepath2</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>

    <span class="n">pointpile</span> <span class="o">=</span> <span class="n">PointPile</span><span class="p">(</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">num_params</span><span class="p">)</span>
    <span class="n">pointpile2</span> <span class="o">=</span> <span class="n">PointPile</span><span class="p">(</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">num_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">Lmin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; find matching sample from points file &quot;&quot;&quot;</span>
        <span class="c1"># look forward to see if there is an exact match</span>
        <span class="c1"># if we do not use the exact matches</span>
        <span class="c1">#   this causes a shift in the loglikelihoods</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">next_row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
            <span class="n">row_Lmin</span> <span class="o">=</span> <span class="n">next_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">next_row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">row_Lmin</span> <span class="o">&lt;=</span> <span class="n">Lmin</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="n">Lmin</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">roots2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">initial_points_u</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">initial_points_v</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">initial_points_logl</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">logl</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_params</span><span class="p">]</span>
        <span class="n">initial_points_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">initial_points_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">initial_points_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span>

    <span class="n">v2</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_points_u</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">initial_points_v</span><span class="p">),</span> <span class="s1">&#39;transform inconsistent, cannot resume&#39;</span>
    <span class="n">logls_new</span> <span class="o">=</span> <span class="n">loglikelihood</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">logl</span><span class="p">,</span> <span class="n">logl_new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">initial_points_u</span><span class="p">,</span> <span class="n">initial_points_v</span><span class="p">,</span> <span class="n">initial_points_logl</span><span class="p">,</span> <span class="n">logls_new</span><span class="p">):</span>
        <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="n">roots2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointpile2</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl_new</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="n">pointstore2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_listify</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">logl_new</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">batchsize</span> <span class="o">=</span> <span class="n">ndraw</span>
    <span class="n">explorer</span> <span class="o">=</span> <span class="n">BreadthFirstIterator</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
    <span class="n">explorer2</span> <span class="o">=</span> <span class="n">BreadthFirstIterator</span><span class="p">(</span><span class="n">roots2</span><span class="p">)</span>
    <span class="n">main_iterator2</span> <span class="o">=</span> <span class="n">SingleCounter</span><span class="p">()</span>
    <span class="n">main_iterator2</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">=</span> <span class="n">logls_new</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">good_state</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">indices1</span><span class="p">,</span> <span class="n">indices2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">logls_new</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">logls_new</span><span class="p">)))</span>
    <span class="n">last_good_like</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e300</span>
    <span class="n">last_good_state</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-6</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">_explore_iterator_batch</span><span class="p">(</span><span class="n">explorer</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">num_params</span><span class="p">,</span> <span class="n">pointpile</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">batch_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">batch</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">batch_u</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">batch_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">batch_u</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">batch_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">batch</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># print(&quot;calling likelihood with %d points&quot; % len(batch_u))</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">batch_u</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">batch_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">num_params</span><span class="p">,</span> <span class="n">batch_v</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">batch_v</span><span class="p">),</span> <span class="s1">&#39;transform inconsistent, cannot resume&#39;</span>
            <span class="n">logls_new</span> <span class="o">=</span> <span class="n">loglikelihood</span><span class="p">(</span><span class="n">batch_v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no new points</span>
            <span class="n">logls_new</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">active_values</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">:</span>

            <span class="n">next_node2</span> <span class="o">=</span> <span class="n">explorer2</span><span class="o">.</span><span class="n">next_node</span><span class="p">()</span>
            <span class="n">rootid2</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="p">(</span><span class="n">active_nodes2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">active_values2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">next_node2</span>
            <span class="n">Lmin2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">node2</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># in the tails of distributions it can happen that two points are out of order</span>
            <span class="c1"># but that may not be very important</span>
            <span class="c1"># in the interest of practicality, we allow this and only stop the</span>
            <span class="c1"># warmstart copying when some bulk of points differ.</span>
            <span class="c1"># in any case, warmstart should not be considered safe, but help iterating</span>
            <span class="c1"># and a final clean run is needed to finalise the results.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_values2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;stopping, number of live points differ (</span><span class="si">%d</span><span class="s2"> vs </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">active_values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_values2</span><span class="p">)))</span>
                    <span class="n">good_state</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
            
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">):</span>
                <span class="n">indices1</span><span class="p">,</span> <span class="n">indices2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">active_values</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">active_values2</span><span class="p">)))</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">normalised_kendall_tau_distance</span><span class="p">(</span><span class="n">active_values</span><span class="p">,</span> <span class="n">active_values2</span><span class="p">,</span> <span class="n">indices1</span><span class="p">,</span> <span class="n">indices2</span><span class="p">)</span>
            <span class="n">order_consistent</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="n">max_tau</span>
            <span class="k">if</span> <span class="n">order_consistent</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">good_state</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">order_consistent</span><span class="p">:</span>
                <span class="n">good_state</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># maintain state</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">niter</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">good_state</span><span class="p">:</span>
                <span class="c1">#print(&quot;        (%.1e)   L=%.1f&quot; % (last_good_like, Lmin2))</span>
                <span class="c1">#assert last_good_like &lt; Lmin2, (last_good_like, Lmin2)</span>
                <span class="n">last_good_like</span> <span class="o">=</span> <span class="n">Lmin2</span>
                <span class="n">last_good_state</span> <span class="o">=</span> <span class="n">niter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># interpolate a increasing likelihood</span>
                <span class="c1"># in the hope that the step size is smaller than</span>
                <span class="c1"># the likelihood increase</span>
                <span class="n">Lmin2</span> <span class="o">=</span> <span class="n">last_good_like</span>
                <span class="n">node2</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Lmin2</span>
                <span class="n">last_good_like</span> <span class="o">=</span> <span class="n">last_good_like</span> <span class="o">*</span> <span class="n">epsilon</span>
                <span class="k">break</span>

            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">logl_old</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">logl_new</span> <span class="o">=</span> <span class="n">logls_new</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1">#print(j, Lmin2, &#39;-&gt;&#39;, logl_new, &#39;instead of&#39;, Lmin, &#39;-&gt;&#39;, [c.value for c in node2.children])</span>
                <span class="n">child2</span> <span class="o">=</span> <span class="n">pointpile2</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl_new</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">node2</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">logl_new</span> <span class="o">&gt;</span> <span class="n">Lmin2</span><span class="p">:</span>
                    <span class="n">pointstore2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_listify</span><span class="p">([</span><span class="n">Lmin2</span><span class="p">,</span> <span class="n">logl_new</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cannot use new point because it would decrease likelihood (</span><span class="si">%.1f</span><span class="s2">-&gt;</span><span class="si">%.1f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Lmin2</span><span class="p">,</span> <span class="n">logl_new</span><span class="p">))</span>
                    <span class="c1">#good_state = False</span>
                    <span class="c1">#break</span>

            <span class="n">main_iterator2</span><span class="o">.</span><span class="n">passing_node</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">active_nodes2</span><span class="p">)</span>

            <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">...</span><span class="se">\r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">niter</span><span class="p">)</span>

            <span class="n">explorer2</span><span class="o">.</span><span class="n">expand_children_of</span><span class="p">(</span><span class="n">rootid2</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">good_state</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">main_iterator2</span><span class="o">.</span><span class="n">logZremain</span> <span class="o">&lt;</span> <span class="n">main_iterator2</span><span class="o">.</span><span class="n">logZ</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">good_state</span><span class="p">:</span>
            <span class="c1"># stop as the results diverged already</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> iterations salvaged (</span><span class="si">%.2f%%</span><span class="s2">).</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">last_good_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="p">(</span><span class="n">last_good_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>
    <span class="c1"># delete the ones at the end from last_good_state onwards</span>
    <span class="c1"># assert len(pointstore2.fileobj[&#39;points&#39;]) == niter, (len(pointstore2.fileobj[&#39;points&#39;]), niter)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">pointstore2</span><span class="o">.</span><span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">last_good_like</span>
    <span class="n">points2</span> <span class="o">=</span> <span class="n">pointstore2</span><span class="o">.</span><span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">][:][</span><span class="n">mask</span><span class="p">,:]</span>
    <span class="k">del</span> <span class="n">pointstore2</span><span class="o">.</span><span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
    <span class="n">pointstore2</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
        <span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pointstore2</span><span class="o">.</span><span class="n">ncols</span><span class="p">),</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">pointstore2</span><span class="o">.</span><span class="n">ncols</span><span class="p">))</span>
    <span class="n">pointstore2</span><span class="o">.</span><span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pointstore2</span><span class="o">.</span><span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">points2</span>
    <span class="n">pointstore2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">pointstore2</span>

    <span class="n">os</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">filepath2</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_update_region_bootstrap</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">nbootstraps</span><span class="p">,</span> <span class="n">minvol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mpi_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    update *region* with *nbootstraps* rounds of excluding points randomly.</span>
<span class="sd">    Stiffen ellipsoid size using the minimum volume *minvol*.</span>

<span class="sd">    If the mpi communicator *comm* is not None, use MPI to distribute</span>
<span class="sd">    the bootstraps over the *mpi_size* processes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">nbootstraps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nbootstraps</span>
    <span class="c1"># catch potential errors so MPI syncing still works</span>
    <span class="n">e</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">compute_enlargement</span><span class="p">(</span>
            <span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">,</span>
            <span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbootstraps</span> <span class="o">//</span> <span class="n">mpi_size</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">e1</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e1</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">recv_maxradii</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># if there are very many processors, we may have more</span>
        <span class="c1"># rounds than requested, leading to slowdown</span>
        <span class="c1"># thus we throw away the extra ones</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_maxradii</span><span class="p">[:</span><span class="n">nbootstraps</span><span class="p">])</span>
        <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">[:</span><span class="n">nbootstraps</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="c1"># reraise error if needed</span>
        <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;compute_enlargement failed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>

    <span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">region</span><span class="o">.</span><span class="n">enlarge</span> <span class="o">=</span> <span class="n">f</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">f</span>


<div class="viewcode-block" id="NestedSampler"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler">[docs]</a><span class="k">class</span> <span class="nc">NestedSampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple Nested sampler for reference.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">param_names</span><span class="p">,</span>
                 <span class="n">loglike</span><span class="p">,</span>
                 <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">derived_param_names</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">resume</span><span class="o">=</span><span class="s1">&#39;subfolder&#39;</span><span class="p">,</span>
                 <span class="n">run_num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">log_dir</span><span class="o">=</span><span class="s1">&#39;logs/test&#39;</span><span class="p">,</span>
                 <span class="n">num_live_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                 <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">wrapped_params</span><span class="o">=</span><span class="p">[],</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up nested sampler.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        param_names: list of str, names of the parameters.</span>
<span class="sd">            Length gives dimensionality of the sampling problem.</span>
<span class="sd">        loglike: function</span>
<span class="sd">            log-likelihood function.</span>
<span class="sd">            Receives multiple parameter vectors, returns vector of likelihood.</span>
<span class="sd">        transform: function</span>
<span class="sd">            parameter transform from unit cube to physical parameters.</span>
<span class="sd">            Receives multiple cube vectors, returns multiple parameter vectors.</span>
<span class="sd">        derived_param_names: list of str</span>
<span class="sd">            Additional derived parameters created by transform. (empty by default)</span>
<span class="sd">        log_dir: str</span>
<span class="sd">            where to store output files</span>
<span class="sd">        resume: &#39;resume&#39;, &#39;overwrite&#39; or &#39;subfolder&#39;</span>
<span class="sd">            if &#39;overwrite&#39;, overwrite previous data.</span>
<span class="sd">            if &#39;subfolder&#39;, create a fresh subdirectory in log_dir.</span>
<span class="sd">            if &#39;resume&#39; or True, continue previous run if available.</span>
<span class="sd">        wrapped_params: list of bools</span>
<span class="sd">            indicating whether this parameter wraps around (circular parameter).</span>
<span class="sd">        num_live_points: int</span>
<span class="sd">            Number of live points</span>
<span class="sd">        vectorized: bool</span>
<span class="sd">            If true, loglike and transform function can receive arrays</span>
<span class="sd">            of points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span> <span class="o">=</span> <span class="n">num_live_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="s1">&#39;nested&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">=</span> <span class="n">x_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span> <span class="o">=</span> <span class="n">derived_param_names</span>
        <span class="n">num_derived</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span> <span class="o">=</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_derived</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volfactor</span> <span class="o">=</span> <span class="n">vol_prefactor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrapped_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wrapped_params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">resume</span> <span class="ow">or</span> <span class="n">resume</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;overwrite&#39;</span><span class="p">,</span> <span class="s1">&#39;subfolder&#39;</span><span class="p">,</span> <span class="s1">&#39;resume&#39;</span><span class="p">),</span> <span class="s2">&quot;resume should be one of &#39;overwrite&#39; &#39;subfolder&#39; or &#39;resume&#39;&quot;</span>
        <span class="n">append_run_num</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;subfolder&#39;</span>
        <span class="n">resume</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;resume&#39;</span> <span class="ow">or</span> <span class="n">resume</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">loglike</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Error in transform function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)))</span>
        <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;Error in transform function: u was modified!&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;Error in loglikelihood function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;Error in loglikelihood function: returned non-finite number: </span><span class="si">%s</span><span class="s2"> for input u=</span><span class="si">%s</span><span class="s2"> p=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">safe_loglike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; wrapped likelihood function &quot;&quot;&quot;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span>
                <span class="s1">&#39;User-provided loglikelihood returned non-finite value:&#39;</span><span class="p">,</span>
                <span class="n">logl</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;for input value:&quot;</span><span class="p">,</span>
                <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">),:][</span><span class="mi">0</span><span class="p">,:])</span>
            <span class="k">return</span> <span class="n">logl</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span> <span class="o">=</span> <span class="n">safe_loglike</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="n">make_run_dir</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">run_num</span><span class="p">,</span> <span class="n">append_run_num</span><span class="o">=</span><span class="n">append_run_num</span><span class="p">)</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;run_dir&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Num live points [</span><span class="si">%d</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="c1"># self.pointstore = TextPointStore(os.path.join(self.logs[&#39;results&#39;], &#39;points.tsv&#39;), 2 + self.x_dim + self.num_params)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">HDF5PointStore</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;points.hdf5&#39;</span><span class="p">),</span>
                <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="k">if</span> <span class="n">resume</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">NullPointStore</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>

<div class="viewcode-block" id="NestedSampler.run"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_interval_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Explore parameter space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update_interval_iter:</span>
<span class="sd">            Update region after this many iterations.</span>
<span class="sd">        update_interval_ncall:</span>
<span class="sd">            Update region after update_interval_ncall likelihood calls.</span>
<span class="sd">        log_interval:</span>
<span class="sd">            Update stdout status line every log_interval iterations</span>
<span class="sd">        dlogz:</span>
<span class="sd">            Target evidence uncertainty.</span>
<span class="sd">        max_iters:</span>
<span class="sd">            maximum number of integration iterations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">update_interval_ncall</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">update_interval_ncall</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">update_interval_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">update_interval_ncall</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">update_interval_iter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">update_interval_iter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">log_interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">log_interval</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;log_interval must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="n">viz_callback</span> <span class="o">=</span> <span class="n">get_default_viz_callback</span><span class="p">()</span>

        <span class="n">prev_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_logl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="c1"># try to resume:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Resuming...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">):</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">prev_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">prev_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">])</span>
                    <span class="n">prev_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">prev_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_v</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>

            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">use_point_stack</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">assert</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="c1"># self.logger.info(&#39;Using MPI with rank [%d]&#39;, self.mpi_rank)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active_v</span><span class="p">):</span>
                        <span class="n">chunks</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chunks</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">recv_active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">active_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_active_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_active_logl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">active_v</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                        <span class="n">_listify</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">active_u</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">active_v</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span>
                        <span class="n">num_live_points_missing</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">))</span>
                <span class="n">active_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">active_v</span><span class="p">))</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_u</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">active_v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active_u</span> <span class="o">=</span> <span class="n">prev_u</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="n">prev_v</span>
            <span class="n">active_logl</span> <span class="o">=</span> <span class="n">prev_logl</span>

        <span class="n">saved_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">saved_v</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Stored points for posterior results</span>
        <span class="n">saved_logl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">saved_logwt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Information, initially 0.</span>
        <span class="n">logz</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e300</span>  <span class="c1"># ln(Evidence Z), initially Z=0</span>
        <span class="n">logvol</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">))</span>
        <span class="n">logz_remain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">active_logl</span><span class="p">)</span>
        <span class="n">fraction_remain</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">ncall</span> <span class="o">=</span> <span class="n">num_live_points_missing</span>  <span class="c1"># number of calls we already made</span>
        <span class="n">first_time</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">transformLayer</span> <span class="o">=</span> <span class="n">AffineLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformLayer</span> <span class="o">=</span> <span class="n">ScalingLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
        <span class="n">transformLayer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">MLFriends</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">transformLayer</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting sampling ...&#39;</span><span class="p">)</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ndraw</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">next_update_interval_ncall</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">next_update_interval_iter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">max_iters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">:</span>

            <span class="c1"># Worst object in collection and its weight (= volume * likelihood)</span>
            <span class="n">worst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">active_logl</span><span class="p">)</span>
            <span class="n">logwt</span> <span class="o">=</span> <span class="n">logvol</span> <span class="o">+</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span>

            <span class="c1"># Update evidence Z and information h.</span>
            <span class="n">logz_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="n">logz</span><span class="p">,</span> <span class="n">logwt</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logwt</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">logz</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">logz</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span>
            <span class="n">logz</span> <span class="o">=</span> <span class="n">logz_new</span>

            <span class="c1"># Add worst object to samples.</span>
            <span class="n">saved_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_u</span><span class="p">[</span><span class="n">worst</span><span class="p">]))</span>
            <span class="n">saved_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_v</span><span class="p">[</span><span class="n">worst</span><span class="p">]))</span>
            <span class="n">saved_logwt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logwt</span><span class="p">)</span>
            <span class="n">saved_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">])</span>

            <span class="c1"># expected_vol = np.exp(-it / self.num_live_points)</span>

            <span class="c1"># The new likelihood constraint is that of the worst object.</span>
            <span class="n">loglstar</span> <span class="o">=</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ncall</span> <span class="o">&gt;</span> <span class="n">next_update_interval_ncall</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="n">next_update_interval_iter</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
                    <span class="n">nextregion</span> <span class="o">=</span> <span class="n">region</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># rebuild space</span>
                    <span class="c1"># print()</span>
                    <span class="c1"># print(&quot;rebuilding space...&quot;, active_u.shape, active_u)</span>
                    <span class="n">nextTransformLayer</span> <span class="o">=</span> <span class="n">transformLayer</span><span class="o">.</span><span class="n">create_new</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">)</span>
                    <span class="n">nextregion</span> <span class="o">=</span> <span class="n">MLFriends</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">nextTransformLayer</span><span class="p">)</span>

                <span class="c1"># print(&quot;computing maxradius...&quot;)</span>
                <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">_update_region_bootstrap</span><span class="p">(</span><span class="n">nextregion</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)</span>

                <span class="n">nextregion</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">nextregion</span><span class="o">.</span><span class="n">enlarge</span> <span class="o">=</span> <span class="n">f</span>
                <span class="c1"># force shrinkage of volume</span>
                <span class="c1"># this is to avoid re-connection of dying out nodes</span>
                <span class="k">if</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">():</span>
                    <span class="n">region</span> <span class="o">=</span> <span class="n">nextregion</span>
                    <span class="n">transformLayer</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span>
                <span class="n">region</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">it</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">volfactor</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="n">viz_callback</span><span class="p">(</span>
                        <span class="n">points</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">active_v</span><span class="p">,</span> <span class="n">logl</span><span class="o">=</span><span class="n">active_logl</span><span class="p">),</span>
                        <span class="n">info</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                            <span class="n">it</span><span class="o">=</span><span class="n">it</span><span class="p">,</span> <span class="n">ncall</span><span class="o">=</span><span class="n">ncall</span><span class="p">,</span> <span class="n">logz</span><span class="o">=</span><span class="n">logz</span><span class="p">,</span> <span class="n">logz_remain</span><span class="o">=</span><span class="n">logz_remain</span><span class="p">,</span>
                            <span class="n">paramnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">,</span>
                            <span class="n">logvol</span><span class="o">=</span><span class="n">logvol</span><span class="p">),</span>
                        <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">transformLayer</span><span class="o">=</span><span class="n">transformLayer</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                <span class="n">next_update_interval_ncall</span> <span class="o">=</span> <span class="n">ncall</span> <span class="o">+</span> <span class="n">update_interval_ncall</span>
                <span class="n">next_update_interval_iter</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">update_interval_iter</span>
                <span class="n">first_time</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_point_stack</span><span class="p">:</span>
                    <span class="c1"># root checks the point store</span>
                    <span class="n">next_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">stored_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">loglstar</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">stored_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">stored_point</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                        <span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>  <span class="c1"># and informs everyone</span>
                        <span class="n">use_point_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">use_point_stack</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">next_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">next_point</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># assert not use_point_stack</span>

                    <span class="c1"># unpack</span>
                    <span class="n">likes</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">]</span>
                    <span class="n">samplesv</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
                    <span class="c1"># skip if we already know it is not useful</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">likes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="mi">1</span>

                <span class="k">while</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                    <span class="c1"># get new samples</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">ndraw</span><span class="p">)</span>
                    <span class="n">nu</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
                        <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">nc</span> <span class="o">+=</span> <span class="n">nu</span>
                        <span class="n">accepted</span> <span class="o">=</span> <span class="n">logl</span> <span class="o">&gt;</span> <span class="n">loglstar</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:]</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:]</span>
                        <span class="n">logl</span> <span class="o">=</span> <span class="n">logl</span><span class="p">[</span><span class="n">accepted</span><span class="p">]</span>
                        <span class="c1"># father = father[accepted]</span>

                    <span class="c1"># collect results from all MPI members</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                        <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">ncall</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span>
                        <span class="n">ncall</span> <span class="o">+=</span> <span class="n">nc</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">logli</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">samplesv</span><span class="p">,</span> <span class="n">likes</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                                <span class="n">_listify</span><span class="p">([</span><span class="n">loglstar</span><span class="p">,</span> <span class="n">logli</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">),</span>
                                <span class="n">ncall</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">loglstar</span><span class="p">:</span>
                    <span class="n">active_u</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">active_v</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">samplesv</span><span class="p">[</span><span class="n">ib</span><span class="p">,:]</span>
                    <span class="n">active_logl</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>

                    <span class="c1"># if we keep the region informed about the new live points</span>
                    <span class="c1"># then the region follows the live points even if maxradius is not updated</span>
                    <span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">worst</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">active_u</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span>
                    <span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">[</span><span class="n">worst</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">worst</span><span class="p">,:])</span>

                    <span class="c1"># if we track the cluster assignment, then in the next round</span>
                    <span class="c1"># the ids with the same members are likely to have the same id</span>
                    <span class="c1"># this is imperfect</span>
                    <span class="c1"># transformLayer.clusterids[worst] = transformLayer.clusterids[father[ib]]</span>
                    <span class="c1"># so we just mark the replaced ones as &quot;unassigned&quot;</span>
                    <span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Shrink interval</span>
            <span class="n">logvol</span> <span class="o">-=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span>
            <span class="n">logz_remain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">active_logl</span><span class="p">)</span> <span class="o">-</span> <span class="n">it</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span>
            <span class="n">fraction_remain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="n">logz</span><span class="p">,</span> <span class="n">logz_remain</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz</span>

            <span class="k">if</span> <span class="n">it</span> <span class="o">%</span> <span class="n">log_interval</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="c1"># nicelogger(self.paramnames, active_u, active_v, active_logl, it, ncall, logz, logz_remain, region=region)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Z=</span><span class="si">%.1g</span><span class="s1">+</span><span class="si">%.1g</span><span class="s1"> | Like=</span><span class="si">%.1g</span><span class="s1">..</span><span class="si">%.1g</span><span class="s1"> | it/evals=</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1"> eff=</span><span class="si">%.4f%%</span><span class="s1">  </span><span class="se">\r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">logz</span><span class="p">,</span> <span class="n">logz_remain</span><span class="p">,</span> <span class="n">loglstar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">active_logl</span><span class="p">),</span> <span class="n">it</span><span class="p">,</span>
                    <span class="n">ncall</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">ncall</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">it</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ncall</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                <span class="c1"># if efficiency becomes low, bulk-process larger arrays</span>
                <span class="n">ndraw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">16384</span><span class="p">,</span> <span class="nb">round</span><span class="p">((</span><span class="n">ncall</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)))</span>

            <span class="c1"># Stopping criterion</span>
            <span class="k">if</span> <span class="n">fraction_remain</span> <span class="o">&lt;</span> <span class="n">dlogz</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">logvol</span> <span class="o">=</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_v</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">):</span>
            <span class="n">logwt</span> <span class="o">=</span> <span class="n">logvol</span> <span class="o">+</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">logz_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="n">logz</span><span class="p">,</span> <span class="n">logwt</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logwt</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">logz</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">logz</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz_new</span><span class="p">)</span>
            <span class="n">logz</span> <span class="o">=</span> <span class="n">logz_new</span>
            <span class="n">saved_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_u</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">saved_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_v</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">saved_logwt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logwt</span><span class="p">)</span>
            <span class="n">saved_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">saved_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_u</span><span class="p">)</span>
        <span class="n">saved_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_v</span><span class="p">)</span>
        <span class="n">saved_wt</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_logwt</span><span class="p">)</span> <span class="o">-</span> <span class="n">logz</span><span class="p">)</span>
        <span class="n">saved_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">)</span>
        <span class="n">logzerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_live_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;final.csv&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;niter&#39;</span><span class="p">,</span> <span class="s1">&#39;ncall&#39;</span><span class="p">,</span> <span class="s1">&#39;logz&#39;</span><span class="p">,</span> <span class="s1">&#39;logzerr&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncall</span><span class="p">,</span> <span class="n">logz</span><span class="p">,</span> <span class="n">logzerr</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;niter: </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2"> ncall: </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2"> nsamples: </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2"> logz: </span><span class="si">{:6.3f}</span><span class="s2"> +/- </span><span class="si">{:6.3f}</span><span class="se">\n</span><span class="s2"> h: </span><span class="si">{:6.3f}</span><span class="s2">&quot;</span>
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncall</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">saved_v</span><span class="p">),</span> <span class="n">logz</span><span class="p">,</span> <span class="n">logzerr</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">resample_equal</span><span class="p">(</span><span class="n">saved_v</span><span class="p">,</span> <span class="n">saved_wt</span> <span class="o">/</span> <span class="n">saved_wt</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
            <span class="n">ncall</span><span class="o">=</span><span class="n">ncall</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">it</span><span class="p">,</span> <span class="n">logz</span><span class="o">=</span><span class="n">logz</span><span class="p">,</span> <span class="n">logzerr</span><span class="o">=</span><span class="n">logzerr</span><span class="p">,</span>
            <span class="n">weighted_samples</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">upoints</span><span class="o">=</span><span class="n">saved_u</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">saved_v</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">saved_wt</span><span class="p">,</span>
                <span class="n">logweights</span><span class="o">=</span><span class="n">saved_logwt</span><span class="p">,</span> <span class="n">logl</span><span class="o">=</span><span class="n">saved_logl</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span></div>

<div class="viewcode-block" id="NestedSampler.print_results"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler.print_results">[docs]</a>    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logZ</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">posterior</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give summary of marginal likelihood and parameters.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;logZ = </span><span class="si">%(logz).3f</span><span class="s1"> +- </span><span class="si">%(logzerr).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="n">med</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sigma</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">.</span><span class="si">%d</span><span class="s1">f&#39;</span> <span class="o">%</span> <span class="n">i</span>
            <span class="n">fmts</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;    </span><span class="si">%-20s</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">fmt</span> <span class="o">+</span> <span class="s2">&quot; +- &quot;</span> <span class="o">+</span> <span class="n">fmt</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fmts</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">med</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span></div>

<div class="viewcode-block" id="NestedSampler.plot"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.NestedSampler.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make corner plot.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="kn">import</span> <span class="nn">corner</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;weighted_samples&#39;</span><span class="p">][</span><span class="s1">&#39;points&#39;</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;weighted_samples&#39;</span><span class="p">][</span><span class="s1">&#39;weights&#39;</span><span class="p">])</span>
            <span class="n">cumsumweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">cumsumweights</span> <span class="o">&gt;</span> <span class="mf">1e-4</span>

            <span class="n">corner</span><span class="o">.</span><span class="n">corner</span><span class="p">(</span>
                <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">,:],</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">,</span>
                <span class="n">show_titles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;corner.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ReactiveNestedSampler"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler">[docs]</a><span class="k">class</span> <span class="nc">ReactiveNestedSampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nested sampler with reactive exploration strategy.</span>

<span class="sd">    Storage &amp; resume capable, optionally MPI parallelised.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">param_names</span><span class="p">,</span>
                 <span class="n">loglike</span><span class="p">,</span>
                 <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">derived_param_names</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">wrapped_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">resume</span><span class="o">=</span><span class="s1">&#39;subfolder&#39;</span><span class="p">,</span>
                 <span class="n">run_num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">log_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_test_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">draw_multiple</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">num_bootstraps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                 <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">ndraw_min</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
                 <span class="n">ndraw_max</span><span class="o">=</span><span class="mi">65536</span><span class="p">,</span>
                 <span class="n">storage_backend</span><span class="o">=</span><span class="s1">&#39;hdf5&#39;</span><span class="p">,</span>
                 <span class="n">warmstart_max_tau</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise nested sampler.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        param_names: list of str, names of the parameters.</span>
<span class="sd">            Length gives dimensionality of the sampling problem.</span>

<span class="sd">        loglike: function</span>
<span class="sd">            log-likelihood function.</span>
<span class="sd">            Receives multiple parameter vectors, returns vector of likelihood.</span>
<span class="sd">        transform: function</span>
<span class="sd">            parameter transform from unit cube to physical parameters.</span>
<span class="sd">            Receives multiple cube vectors, returns multiple parameter vectors.</span>

<span class="sd">        derived_param_names: list of str</span>
<span class="sd">            Additional derived parameters created by transform. (empty by default)</span>

<span class="sd">        log_dir: str</span>
<span class="sd">            where to store output files</span>
<span class="sd">        resume: &#39;resume&#39;, &#39;resume-similar&#39;, &#39;overwrite&#39; or &#39;subfolder&#39;</span>

<span class="sd">            if &#39;overwrite&#39;, overwrite previous data.</span>

<span class="sd">            if &#39;subfolder&#39;, create a fresh subdirectory in log_dir.</span>

<span class="sd">            if &#39;resume&#39; or True, continue previous run if available.</span>
<span class="sd">            Only works when dimensionality, transform or likelihood are consistent.</span>

<span class="sd">            if &#39;resume-similar&#39;, continue previous run if available.</span>
<span class="sd">            Only works when dimensionality and transform are consistent.</span>
<span class="sd">            If a likelihood difference is detected, the existing likelihoods</span>
<span class="sd">            are updated until the live point order differs.</span>
<span class="sd">            Otherwise, behaves like resume.</span>

<span class="sd">        wrapped_params: list of bools</span>
<span class="sd">            indicating whether this parameter wraps around (circular parameter).</span>

<span class="sd">        num_test_samples: int</span>
<span class="sd">            test transform and likelihood with this number of</span>
<span class="sd">            random points for errors first. Useful to catch bugs.</span>

<span class="sd">        vectorized: bool</span>
<span class="sd">            If true, loglike and transform function can receive arrays</span>
<span class="sd">            of points.</span>

<span class="sd">        draw_multiple: bool</span>
<span class="sd">            If efficiency goes down, dynamically draw more points</span>
<span class="sd">            from the region between `ndraw_min` and `ndraw_max`.</span>
<span class="sd">            If set to False, few points are sampled at once.</span>

<span class="sd">        ndraw_min: int</span>
<span class="sd">            Minimum number of points to simultaneously propose.</span>
<span class="sd">            Increase this if your likelihood makes vectorization very cheap.</span>

<span class="sd">        ndraw_max: int</span>
<span class="sd">            Maximum number of points to simultaneously propose.</span>
<span class="sd">            Increase this if your likelihood makes vectorization very cheap.</span>
<span class="sd">            Memory allocation may be slow for extremely high values.</span>

<span class="sd">        num_bootstraps: int</span>
<span class="sd">            number of logZ estimators and MLFriends region</span>
<span class="sd">            bootstrap rounds.</span>

<span class="sd">        storage_backend: str or class</span>
<span class="sd">            Class to use for storing the evaluated points (see ultranest.store)</span>
<span class="sd">            &#39;hdf5&#39; is strongly recommended. &#39;tsv&#39; and &#39;csv&#39; are also possible.</span>

<span class="sd">        warmstart_max_tau: float</span>
<span class="sd">            Maximum disorder to accept when resume=&#39;resume-similar&#39;;</span>
<span class="sd">            Live points are reused as long as the live point order </span>
<span class="sd">            is below this normalised Kendall tau distance.</span>
<span class="sd">            Values from 0 (highly conservative) to 1 (extremely negligent).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="s1">&#39;reactive-nested&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">=</span> <span class="n">x_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span> <span class="o">=</span> <span class="n">derived_param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_bootstraps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_bootstraps</span><span class="p">)</span>
        <span class="n">num_derived</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span> <span class="o">=</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_derived</span>
        <span class="k">if</span> <span class="n">wrapped_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrapped_params</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;wrapped_params has the number of entries:&quot;</span><span class="p">,</span> <span class="n">wrapped_params</span><span class="p">,</span> <span class="s2">&quot;, expected&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wrapped_params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setup_distributed_seeds</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_to_pointstore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span>

        <span class="k">assert</span> <span class="n">resume</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">,</span> <span class="s1">&#39;subfolder&#39;</span><span class="p">,</span> <span class="s1">&#39;resume&#39;</span><span class="p">,</span> <span class="s1">&#39;resume-similar&#39;</span><span class="p">),</span> \
            <span class="s2">&quot;resume should be one of &#39;overwrite&#39; &#39;subfolder&#39;, &#39;resume&#39; or &#39;resume-similar&#39;&quot;</span>
        <span class="n">append_run_num</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;subfolder&#39;</span>
        <span class="n">resume_similar</span> <span class="o">=</span> <span class="n">resume</span> <span class="o">==</span> <span class="s1">&#39;resume-similar&#39;</span>
        <span class="n">resume</span> <span class="o">=</span> <span class="n">resume</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;resume-similar&#39;</span><span class="p">,</span> <span class="s1">&#39;resume&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="n">make_run_dir</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">run_num</span><span class="p">,</span> <span class="n">append_run_num</span><span class="o">=</span><span class="n">append_run_num</span><span class="p">)</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;run_dir&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="s1">&#39;ultranest&#39;</span><span class="p">,</span> <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;ReactiveNestedSampler: dims=</span><span class="si">%d</span><span class="s1">+</span><span class="si">%d</span><span class="s1">, resume=</span><span class="si">%s</span><span class="s1">, log_dir=</span><span class="si">%s</span><span class="s1">, backend=</span><span class="si">%s</span><span class="s1">, vectorized=</span><span class="si">%s</span><span class="s1">, nbootstraps=</span><span class="si">%s</span><span class="s1">, ndraw=</span><span class="si">%s</span><span class="s1">..</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">x_dim</span><span class="p">,</span> <span class="n">num_derived</span><span class="p">,</span> <span class="n">resume</span><span class="p">,</span> <span class="n">log_dir</span><span class="p">,</span> <span class="n">storage_backend</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">,</span>
                <span class="n">num_bootstraps</span><span class="p">,</span> <span class="n">ndraw_min</span><span class="p">,</span> <span class="n">ndraw_max</span><span class="p">,</span>
            <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span> <span class="o">=</span> <span class="n">PointPile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_pointstore</span><span class="p">:</span>
            <span class="n">storage_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;points.&#39;</span> <span class="o">+</span> <span class="n">storage_backend</span><span class="p">)</span>
            <span class="n">storage_num_cols</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span>
            <span class="k">if</span> <span class="n">storage_backend</span> <span class="o">==</span> <span class="s1">&#39;tsv&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">TextPointStore</span><span class="p">(</span><span class="n">storage_filename</span><span class="p">,</span> <span class="n">storage_num_cols</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">delimiter</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">elif</span> <span class="n">storage_backend</span> <span class="o">==</span> <span class="s1">&#39;csv&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">TextPointStore</span><span class="p">(</span><span class="n">storage_filename</span><span class="p">,</span> <span class="n">storage_num_cols</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">delimiter</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span>
            <span class="k">elif</span> <span class="n">storage_backend</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">HDF5PointStore</span><span class="p">(</span><span class="n">storage_filename</span><span class="p">,</span> <span class="n">storage_num_cols</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="k">if</span> <span class="n">resume</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use custom backend</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">storage_backend</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">NullPointStore</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">ncalls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">loglike</span><span class="p">)</span>
            <span class="n">draw_multiple</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span> <span class="o">=</span> <span class="n">draw_multiple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndraw_min</span> <span class="o">=</span> <span class="n">ndraw_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndraw_max</span> <span class="o">=</span> <span class="n">ndraw_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_tregion</span> <span class="o">=</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_likelihood_function</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="p">,</span> <span class="n">num_test_samples</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span>
            <span class="k">if</span> <span class="n">resume_similar</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">storage_backend</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;resume-similar is only supported for HDF5 files&#39;</span>
                <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">warmstart_max_tau</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;warmstart_max_tau parameter needs to be set to a value between 0 and 1&#39;</span>
                <span class="c1"># close</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span>
                <span class="c1"># rewrite points file</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;trying to salvage points from previous, different run ...&#39;</span><span class="p">)</span>
                <span class="n">resume_from_similar_file</span><span class="p">(</span>
                    <span class="n">log_dir</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">loglike</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="n">ndraw</span><span class="o">=</span><span class="n">ndraw_min</span> <span class="k">if</span> <span class="n">vectorized</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">max_tau</span><span class="o">=</span><span class="n">warmstart_max_tau</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span> <span class="o">=</span> <span class="n">HDF5PointStore</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;points.hdf5&#39;</span><span class="p">),</span>
                    <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="k">if</span> <span class="n">resume</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">resume</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot resume because loglikelihood function changed, &quot;</span>
                                <span class="s2">&quot;unless resume=resume-similar. To start from scratch, delete &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">log_dir</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_likelihood_function</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="p">,</span> <span class="n">num_test_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_setup_distributed_seeds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>

        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># from http://arxiv.org/abs/1005.4117</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(((</span><span class="n">seed</span> <span class="o">*</span> <span class="mi">181</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">-</span> <span class="mi">83</span><span class="p">)</span> <span class="o">*</span> <span class="mi">359</span><span class="p">))</span> <span class="o">%</span> <span class="mi">104729</span><span class="p">))</span>
            <span class="c1"># print(&#39;setting seed:&#39;, self.mpi_rank, seed)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_likelihood_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="p">,</span> <span class="n">num_test_samples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests the `transform` and `loglike`lihood functions.</span>
<span class="sd">        `num_test_samples` samples are used to check whether they work and give the correct output.</span>

<span class="sd">        returns whether the most recently stored point (if any)</span>
<span class="sd">        still returns the same likelihood value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do some checks on the likelihood function</span>
        <span class="c1"># this makes debugging easier by failing early with meaningful errors</span>

        <span class="c1"># if we are resuming, check that last sample still gives same result</span>
        <span class="n">num_resume_test_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">num_test_samples</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span><span class="p">:</span>
            <span class="n">num_resume_test_samples</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">num_test_samples</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">num_test_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># test with num_test_samples random points</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_test_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;Error in transform function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span>
                <span class="s2">&quot;Error in transform function: u was modified!&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,),</span> <span class="p">(</span>
                <span class="s2">&quot;Error in loglikelihood function: returned shape is </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">logl</span><span class="p">),</span> <span class="p">(</span><span class="n">num_test_samples</span><span class="p">,)))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span>
                <span class="s2">&quot;Error in loglikelihood function: returned non-finite number: </span><span class="si">%s</span><span class="s2"> for input u=</span><span class="si">%s</span><span class="s2"> p=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span> <span class="ow">and</span> <span class="n">num_resume_test_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># test that last sample gives the same likelihood value</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">lastrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lastrow</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot resume: problem has different dimensionality&quot;</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">lastrow</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
            <span class="n">lastL</span> <span class="o">=</span> <span class="n">lastrow</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lastu</span> <span class="o">=</span> <span class="n">lastrow</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">lastu</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">lastp</span> <span class="o">=</span> <span class="n">lastrow</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Testing resume consistency: </span><span class="si">%s</span><span class="s2">: u=</span><span class="si">%s</span><span class="s2"> -&gt; p=</span><span class="si">%s</span><span class="s2"> -&gt; L=</span><span class="si">%s</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">lastrow</span><span class="p">,</span> <span class="n">lastu</span><span class="p">,</span> <span class="n">lastp</span><span class="p">,</span> <span class="n">lastL</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lastp</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Trying to resume from previous run, but transform function gives different result: </span><span class="si">%s</span><span class="s2"> gave </span><span class="si">%s</span><span class="s2">, now </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">lastu</span><span class="p">,</span> <span class="n">lastp</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lastp</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot resume because transform function changed. &quot;</span>
                <span class="s2">&quot;To start from scratch, delete &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;run_dir&#39;</span><span class="p">]))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">lastL</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Trying to resume from previous run, but likelihood function gives different result: </span><span class="si">%s</span><span class="s2"> gave </span><span class="si">%s</span><span class="s2">, now </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">lastu</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lastL</span><span class="p">,</span> <span class="n">logl</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">lastL</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_set_likelihood_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="p">,</span> <span class="n">num_test_samples</span><span class="p">,</span> <span class="n">make_safe</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the transform and log-likelihood functions.</span>

<span class="sd">        if make_safe is set, make functions safer by accepting misformed</span>
<span class="sd">        return shapes and non-finite likelihood values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">safe_loglike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; safe wrapper of likelihood function &quot;&quot;&quot;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">loglike</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">logl</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">logl</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logl</span><span class="p">))]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e100</span>
            <span class="k">return</span> <span class="n">logl</span>

        <span class="k">if</span> <span class="n">make_safe</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span> <span class="o">=</span> <span class="n">safe_loglike</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span> <span class="o">=</span> <span class="n">loglike</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">make_safe</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">safe_transform</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot; safe wrapper of transform function &quot;&quot;&quot;</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">safe_transform</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

        <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
        <span class="n">lims</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="n">lims</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lims</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">volfactor</span> <span class="o">=</span> <span class="n">vol_prefactor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_widen_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weighted_parents</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure that at parents have `nnodes_needed` live points (parallel arcs).</span>

<span class="sd">        If not, fill up by sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndone</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weighted_parents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndone</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No parents, so widening roots&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_widen_roots</span><span class="p">(</span><span class="n">nnodes_needed</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># select parents with weight 1/parent_weights</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="n">weighted_parents</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># preferentially select nodes with few parents, as those</span>
            <span class="c1"># have most weight</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weighted_parents</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span> <span class="o">/</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">weighted_parents</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">weighted_parents</span><span class="p">,</span> <span class="n">weights</span>

        <span class="c1"># sort from low to high</span>
        <span class="n">parents</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">))</span>
        <span class="n">Lmin</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Lmin</span><span class="p">):</span>
            <span class="c1"># some of the parents were born by sampling from the entire</span>
            <span class="c1"># prior volume. So we can efficiently apply a solution:</span>
            <span class="c1"># expand the roots</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;parent value is -inf, so widening roots&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_widen_roots</span><span class="p">(</span><span class="n">nnodes_needed</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># double until we reach the necessary points</span>
        <span class="c1"># this is probably 1, from (2K - K) / K</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">nnodes_needed</span> <span class="o">-</span> <span class="n">ndone</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Will add </span><span class="si">%d</span><span class="s1"> live points (x</span><span class="si">%d</span><span class="s1">) at L=</span><span class="si">%.1g</span><span class="s1"> ...&#39;</span><span class="p">,</span> <span class="n">nnodes_needed</span> <span class="o">-</span> <span class="n">ndone</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">)</span>

        <span class="c1"># add points where necessary (parents can have multiple entries)</span>
        <span class="n">target_min_num_children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
            <span class="n">orign</span> <span class="o">=</span> <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
            <span class="n">target_min_num_children</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">orign</span> <span class="o">+</span> <span class="n">nsamples</span>

        <span class="k">return</span> <span class="n">target_min_num_children</span>

    <span class="k">def</span> <span class="nf">_widen_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nroots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure root has `nroots` children.</span>

<span class="sd">        Sample from prior to fill up (if needed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Widening roots to </span><span class="si">%d</span><span class="s1"> live points (have </span><span class="si">%d</span><span class="s1"> already) ...&#39;</span><span class="p">,</span> <span class="n">nroots</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
        <span class="n">nnewroots</span> <span class="o">=</span> <span class="n">nroots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nnewroots</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># nothing to do</span>
            <span class="k">return</span>

        <span class="n">prev_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_logl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_rowid</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">:</span>
            <span class="c1"># try to resume:</span>
            <span class="c1"># self.logger.info(&#39;Resuming...&#39;)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nnewroots</span><span class="p">):</span>
                <span class="n">rowid</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">prev_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">prev_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">])</span>
                <span class="n">prev_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">])</span>
                <span class="n">prev_rowid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowid</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="n">prev_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_v</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>

            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="n">nnewroots</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
            <span class="n">num_live_points_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling </span><span class="si">%d</span><span class="s1"> live points from prior ...&#39;</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_live_points_missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_live_points_todo</span> <span class="o">=</span> <span class="n">num_live_points_missing</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># rank 0 picks up what the others did not do</span>
                <span class="n">num_live_points_todo</span> <span class="o">=</span> <span class="n">num_live_points_missing</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_live_points_missing</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_live_points_todo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span>
            <span class="n">active_logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">active_v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="n">num_live_points_missing</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">active_v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">active_logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">active_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">,),</span> <span class="p">(</span><span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_pointstore</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_live_points_missing</span><span class="p">):</span>
                    <span class="n">rowid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_listify</span><span class="p">(</span>
                        <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="n">active_u</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                        <span class="n">active_v</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">active_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">))</span>
                <span class="n">active_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_v</span><span class="p">,</span> <span class="n">active_v</span><span class="p">))</span>
                <span class="n">active_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prev_logl</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_u</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">),</span> <span class="p">(</span><span class="n">active_u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">),</span> <span class="p">(</span><span class="n">active_v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nnewroots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span> <span class="n">num_live_points_missing</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_u</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nnewroots</span><span class="p">,),</span> <span class="p">(</span><span class="n">active_logl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nnewroots</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active_u</span> <span class="o">=</span> <span class="n">prev_u</span>
            <span class="n">active_v</span> <span class="o">=</span> <span class="n">prev_v</span>
            <span class="n">active_logl</span> <span class="o">=</span> <span class="n">prev_logl</span>

        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">logl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_v</span><span class="p">,</span> <span class="n">active_logl</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_tregion</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_affine_transform</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span> <span class="o">+=</span> <span class="n">roots</span>

    <span class="k">def</span> <span class="nf">_adaptive_strategy_advice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">parallel_values</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">minimal_widths</span><span class="p">,</span> <span class="n">frac_remain</span><span class="p">,</span> <span class="n">Lepsilon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if integration is done.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Llo, Lhi: floats</span>
<span class="sd">            range where more sampling is needed</span>
<span class="sd">            if done, both are nan</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        Lmin: float</span>
<span class="sd">            current loglikelihood threshold</span>
<span class="sd">        parallel_values: array of floats</span>
<span class="sd">            loglikelihoods of live points</span>
<span class="sd">        main_iterator: BreadthFirstIterator</span>
<span class="sd">            current tree exploration iterator</span>
<span class="sd">        minimal_widths: list</span>
<span class="sd">            current width required</span>
<span class="sd">        frac_remain: float</span>
<span class="sd">            maximum fraction of integral in remainder for termination</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">parallel_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Ls</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># Ls = [node.value] + [n.value for rootid2, n in parallel_nodes]</span>
        <span class="n">Lmax</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Lmin</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># all points the same, stop</span>
        <span class="k">if</span> <span class="n">Lmax</span> <span class="o">-</span> <span class="n">Lmin</span> <span class="o">&lt;</span> <span class="n">Lepsilon</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># max remainder contribution is Lmax + weight, to be added to main_iterator.logZ</span>
        <span class="c1"># the likelihood that would add an equal amount as main_iterator.logZ is:</span>
        <span class="n">logZmax</span> <span class="o">=</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZremain</span>
        <span class="n">Lnext</span> <span class="o">=</span> <span class="n">logZmax</span> <span class="o">-</span> <span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">frac_remain</span><span class="p">))</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">))</span>
        <span class="n">L1</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Lmax1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span>
        <span class="n">Lnext</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Lnext</span><span class="p">,</span> <span class="n">Lmax1</span><span class="p">),</span> <span class="n">L1</span><span class="p">)</span>

        <span class="c1"># if the remainder dominates, return that range</span>
        <span class="k">if</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZremain</span> <span class="o">&gt;</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">Lnext</span>

        <span class="k">if</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">remainder_fraction</span> <span class="o">&gt;</span> <span class="n">frac_remain</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">Lnext</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">_find_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">dlogz</span><span class="p">,</span> <span class="n">dKL</span><span class="p">,</span> <span class="n">min_ess</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ask each strategy which log-likelihood interval needs more exploration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (Llo_Z, Lhi_Z): floats</span>
<span class="sd">            interval where dlogz strategy requires more samples.</span>
<span class="sd">        (Llo_KL, Lhi_KL): floats</span>
<span class="sd">            interval where posterior uncertainty strategy requires more samples.</span>
<span class="sd">        (Llo_ess, Lhi_ess): floats</span>
<span class="sd">            interval where effective sample strategy requires more samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        saved_logl: array of float</span>
<span class="sd">            loglikelihood values in integration</span>
<span class="sd">        main_iterator: BreadthFirstIterator</span>
<span class="sd">            current tree exploration iterator</span>
<span class="sd">        dlogz: float</span>
<span class="sd">            required logZ accuracy (smaller is stricter)</span>
<span class="sd">        dKL: float</span>
<span class="sd">            required Kulback-Leibler information gain between bootstrapped</span>
<span class="sd">            nested sampling incarnations (smaller is stricter).</span>
<span class="sd">        min_ess: float</span>
<span class="sd">            required number of effective samples (higher is stricter).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">saved_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">)</span>
        <span class="n">logw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logweights</span><span class="p">)</span> <span class="o">+</span> <span class="n">saved_logl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span>
        <span class="n">ref_logw</span> <span class="o">=</span> <span class="n">logw</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">other_logw</span> <span class="o">=</span> <span class="n">logw</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">Llo_ess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lhi_ess</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">ref_logw</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">w</span> <span class="o">/=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ess</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ess</span> <span class="o">&lt;</span> <span class="n">min_ess</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">min_ess</span><span class="p">)</span>
            <span class="n">Llo_ess</span> <span class="o">=</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">Lhi_ess</span> <span class="o">=</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">Lhi_ess</span> <span class="o">&gt;</span> <span class="n">Llo_ess</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Effective samples strategy wants to improve: </span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2"> (ESS = </span><span class="si">%.1f</span><span class="s2">, need &gt;</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                             <span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Lhi_ess</span><span class="p">,</span> <span class="n">ess</span><span class="p">,</span> <span class="n">min_ess</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">min_ess</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Effective samples strategy satisfied (ESS = </span><span class="si">%.1f</span><span class="s2">, need &gt;</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                             <span class="n">ess</span><span class="p">,</span> <span class="n">min_ess</span><span class="p">)</span>

        <span class="c1"># compute KL divergence</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">KL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">other_logw</span><span class="p">),</span> <span class="n">exp</span><span class="p">(</span><span class="n">other_logw</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">other_logw</span> <span class="o">-</span> <span class="n">ref_logw</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">KLtot</span> <span class="o">=</span> <span class="n">KL</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dKLtot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">KLtot</span> <span class="o">-</span> <span class="n">KLtot</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">KL</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">/=</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">Llo_KL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lhi_KL</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">dKLi</span><span class="p">,</span> <span class="n">logwi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dKLtot</span><span class="p">,</span> <span class="n">other_logw</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">dKLi</span> <span class="o">&gt;</span> <span class="n">dKL</span><span class="p">:</span>
                <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span> <span class="o">=</span> <span class="n">_get_cumsum_range</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mi">400</span><span class="p">)</span>
                <span class="c1"># ilo and ihi are most likely missing in this iterator</span>
                <span class="c1"># --&gt; select the one before/after in this iterator</span>
                <span class="n">ilos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logwi</span><span class="p">[:</span><span class="n">ilo</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ihis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">logwi</span><span class="p">[</span><span class="n">ihi</span><span class="p">:]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ilo2</span> <span class="o">=</span> <span class="n">ilos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ilos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">ihi2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ihi</span> <span class="o">+</span> <span class="n">ihis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ihis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                <span class="c1"># self.logger.info(&#39;   - KL[%d] = %.2f: need to improve near %.2f..%.2f --&gt; %.2f..%.2f&#39; % (</span>
                <span class="c1">#  i, dKLi, saved_logl[ilo], saved_logl[ihi], saved_logl[ilo2], saved_logl[ihi2]))</span>
                <span class="n">Llo_KL</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Llo_KL</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">ilo2</span><span class="p">])</span>
                <span class="n">Lhi_KL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lhi_KL</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">ihi2</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">Lhi_KL</span> <span class="o">&gt;</span> <span class="n">Llo_KL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Posterior uncertainty strategy wants to improve: </span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2"> (KL: </span><span class="si">%.2f</span><span class="s2">+-</span><span class="si">%.2f</span><span class="s2"> nat, need &lt;</span><span class="si">%.2f</span><span class="s2"> nat)&quot;</span><span class="p">,</span>
                             <span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">,</span> <span class="n">KLtot</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">dKLtot</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dKL</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Posterior uncertainty strategy is satisfied (KL: </span><span class="si">%.2f</span><span class="s2">+-</span><span class="si">%.2f</span><span class="s2"> nat, need &lt;</span><span class="si">%.2f</span><span class="s2"> nat)&quot;</span><span class="p">,</span>
                             <span class="n">KLtot</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">dKLtot</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dKL</span><span class="p">)</span>

        <span class="n">Llo_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lhi_Z</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># compute difference between lnZ cumsum</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">logw</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">/=</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">deltalogZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">all_logZ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">)</span>

        <span class="n">tail_fraction</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">istail</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">logzerr_tail</span> <span class="o">=</span> <span class="n">logaddexp</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">tail_fraction</span><span class="p">)</span> <span class="o">+</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">)</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">deltalogZ</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">logzerr_tail</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">deltalogZi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">deltalogZ</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">deltalogZi</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">:</span>
                    <span class="c1"># break up samples with too much weight</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_logw</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
                    <span class="c1"># if self.log:</span>
                    <span class="c1">#     self.logger.info(&#39;   - deltalogZi[%d] = %.2f: need to improve near %.2f..%.2f&#39; % (</span>
                    <span class="c1">#         i, deltalogZi, saved_logl[samples].min(), saved_logl[samples].max()))</span>
                    <span class="n">Llo_Z</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Llo_Z</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                    <span class="n">Lhi_Z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lhi_Z</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">Lhi_Z</span> <span class="o">&gt;</span> <span class="n">Llo_Z</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Evidency uncertainty strategy wants to improve: </span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2"> (dlogz from </span><span class="si">%.2f</span><span class="s2"> to </span><span class="si">%.2f</span><span class="s2">, need &lt;</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="n">Llo_Z</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">,</span> <span class="n">deltalogZ</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">deltalogZ</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dlogz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Evidency uncertainty strategy is satisfied (dlogz=</span><span class="si">%.2f</span><span class="s2">, need &lt;</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="n">deltalogZ</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">dlogz</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;  logZ error budget: single: </span><span class="si">%.2f</span><span class="s1"> bs:</span><span class="si">%.2f</span><span class="s1"> tail:</span><span class="si">%.2f</span><span class="s1"> total:</span><span class="si">%.2f</span><span class="s1"> required:&lt;</span><span class="si">%.2f</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="p">,</span> <span class="n">logzerr_tail</span><span class="p">,</span>
                <span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">logzerr_tail</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dlogz</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">Llo_Z</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Lhi_ess</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_refill_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get new samples from region.&quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">ndraw</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span><span class="p">:</span>
                <span class="c1"># peel off first if multiple evaluation is not supported</span>
                <span class="n">nu</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:]</span>

            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># check wrapping ellipsoid in transformed space</span>
                <span class="n">accepted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">nt</span> <span class="o">=</span> <span class="n">accepted</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if undefined, all pass; rarer branch</span>
                <span class="n">accepted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">nt</span> <span class="o">=</span> <span class="n">nu</span>

            <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logl</span><span class="p">[</span><span class="n">accepted</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">accepted</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">nc</span> <span class="o">+=</span> <span class="n">nt</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="n">logl</span> <span class="o">&gt;</span> <span class="n">Lmin</span>

            <span class="c1"># print(&quot;it: %4d ndraw: %d -&gt; %d -&gt; %d -&gt; %d &quot; % (nit, ndraw, nu, nt, accepted.sum()))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_slow_warned</span> <span class="ow">and</span> <span class="n">nit</span> <span class="o">*</span> <span class="n">ndraw</span> <span class="o">&gt;=</span> <span class="mi">100000</span> <span class="ow">and</span> <span class="n">nit</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="n">warning_message1</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Sampling from region seems inefficient (</span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> accepted in iteration </span><span class="si">%d</span><span class="s2">). &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">accepted</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">))</span>
            <span class="n">warning_message2</span> <span class="o">=</span> <span class="s2">&quot;To improve efficiency, modify the transformation so that the current live points</span><span class="si">%s</span><span class="s2"> are ellipsoidal, &quot;</span> <span class="o">+</span> \
                <span class="s2">&quot;or use a stepsampler, or set frac_remain to a lower number (e.g., 0.5) to terminate earlier.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
                <span class="n">debug_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;extra&#39;</span><span class="p">],</span> <span class="s1">&#39;sampling-stuck-it</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span>
                    <span class="n">debug_filename</span> <span class="o">+</span> <span class="s1">&#39;.npz&#39;</span><span class="p">,</span>
                    <span class="n">u</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">unormed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span>
                    <span class="n">maxradiussq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span>
                    <span class="n">sample_u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">sample_v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">sample_logl</span><span class="o">=</span><span class="n">logl</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">debug_filename</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="n">warning_message</span> <span class="o">=</span> <span class="n">warning_message1</span> <span class="o">+</span> <span class="p">(</span><span class="n">warning_message2</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39; (stored for you in </span><span class="si">%s</span><span class="s1">.csv)&#39;</span> <span class="o">%</span> <span class="n">debug_filename</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warning_message</span> <span class="o">=</span> <span class="n">warning_message1</span> <span class="o">+</span> <span class="n">warning_message2</span> <span class="o">%</span> <span class="s1">&#39;&#39;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warning_message</span><span class="p">)</span>
            <span class="n">logl_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">logl_region</span> <span class="o">==</span> <span class="n">Lmin</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Region cannot sample a higher point. &quot;</span>
                    <span class="s2">&quot;All remaining live points have the same value.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">logl_region</span> <span class="o">&gt;</span> <span class="n">Lmin</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Region cannot sample a higher point. &quot;</span>
                    <span class="s2">&quot;Perhaps you are resuming from a different problem?&quot;</span>
                    <span class="s2">&quot;Delete the output files and start again.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_slow_warned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span> <span class="o">+=</span> <span class="n">ndraw</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:],</span> <span class="n">v</span><span class="p">[</span><span class="n">accepted</span><span class="p">,:],</span> <span class="n">logl</span><span class="p">[</span><span class="n">accepted</span><span class="p">],</span> <span class="n">nc</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_create_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">active_u</span><span class="p">,</span> <span class="n">active_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw a new point above likelihood threshold `Lmin`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        Lmin: float</span>
<span class="sd">            loglikelihood threshold to draw above</span>
<span class="sd">        ndraw: float</span>
<span class="sd">            number of points to try to sample at once</span>
<span class="sd">        active_u: array of floats</span>
<span class="sd">            current live points</span>
<span class="sd">        active_values</span>
<span class="sd">            loglikelihoods of current live points</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ib</span>
            <span class="k">if</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">:</span>
                <span class="c1"># root checks the point store</span>
                <span class="n">next_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_pointstore</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">stored_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">Lmin</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stored_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">stored_point</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">next_point</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>  <span class="c1"># and informs everyone</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">next_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">next_point</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># unpack</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">next_point</span><span class="p">[:,</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
                <span class="c1"># skip if we already know it is not useful</span>
                <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> \
                <span class="p">(</span><span class="s2">&quot;None of the live points satisfies the current region!&quot;</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span> <span class="n">active_u</span><span class="p">)</span>

            <span class="n">use_stepsampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">ib</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">):</span>
                <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">use_stepsampler</span><span class="p">:</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">logl</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span><span class="o">.</span><span class="fm">__next__</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                        <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">loglike</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span>
                        <span class="n">Lmin</span><span class="o">=</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">us</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">Ls</span><span class="o">=</span><span class="n">active_values</span><span class="p">,</span>
                        <span class="n">ndraw</span><span class="o">=</span><span class="n">ndraw</span><span class="p">,</span> <span class="n">tregion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tregion</span><span class="p">)</span>
                    <span class="n">quality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span><span class="o">.</span><span class="n">nsteps</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">logl</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">quality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refill_samples</span><span class="p">(</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">nit</span><span class="p">)</span>
                <span class="n">nit</span> <span class="o">+=</span> <span class="mi">1</span>
            
                <span class="k">if</span> <span class="n">logl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
                    <span class="n">logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
                <span class="k">elif</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">))</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">))</span>
                    <span class="n">logl</span> <span class="o">=</span> <span class="n">logl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                    <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_samplesv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_likes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">recv_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_samplesv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">recv_likes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">recv_nc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">u</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">likes</span> <span class="o">=</span> <span class="n">logl</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">+=</span> <span class="n">nc</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">logli</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                            <span class="n">_listify</span><span class="p">([</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">logli</span><span class="p">,</span> <span class="n">quality</span><span class="p">],</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Lmin</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesv</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">logl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">logl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ib</span> <span class="o">=</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_update_region</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">active_u</span><span class="p">,</span> <span class="n">active_node_ids</span><span class="p">,</span>
        <span class="n">bootstrap_rootids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active_rootids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nbootstraps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">minvol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">active_p</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a new MLFriends region from `active_u`,</span>
<span class="sd">        and wrapping ellipsoid.</span>
<span class="sd">        Both are safely built using bootstrapping, so that the</span>
<span class="sd">        region can be used for sampling and rejecting points.</span>
<span class="sd">        If MPI is enabled, this computation is parallelised.</span>

<span class="sd">        If active_p is not None, a wrapping ellipsoid is built also</span>
<span class="sd">        in the user-transformed parameter space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        active_u: array of floats</span>
<span class="sd">            current live points</span>
<span class="sd">        active_node_ids: 2d array of ints</span>
<span class="sd">            which bootstrap initialisation the points belong to.</span>
<span class="sd">        active_rootids: 2d array of ints</span>
<span class="sd">            roots active in each bootstrap initialisation</span>
<span class="sd">        bootstrap_rootids: array of ints</span>
<span class="sd">            bootstrap samples. if None, they are drawn fresh.</span>
<span class="sd">        nbootstraps: int</span>
<span class="sd">            number of bootstrap rounds</span>
<span class="sd">        active_p: array of floats</span>
<span class="sd">            current live points, in user-transformed space</span>
<span class="sd">        minvol: float</span>
<span class="sd">            expected current minimum volume of region.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        updated: bool</span>
<span class="sd">            True if update was made, False if previous region remained.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">nbootstraps</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if self.log:</span>
            <span class="c1">#    self.logger.debug(&quot;building first region ...&quot;)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="n">AffineLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="n">ScalingLayer</span><span class="p">(</span><span class="n">wrapped_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped_axes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_u</span><span class="p">,</span> <span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region_class</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span> <span class="o">=</span> <span class="n">active_node_ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="ow">is</span> <span class="kc">None</span>

            <span class="n">_update_region_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">nbootstraps</span><span class="p">,</span> <span class="n">minvol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
            <span class="c1"># if self.log:</span>
            <span class="c1">#     self.logger.debug(&quot;building first region ... r=%e, f=%e&quot; % (r, f))</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># verify correctness:</span>
            <span class="c1"># self.region.create_ellipsoid(minvol=minvol)</span>
            <span class="c1"># assert self.region.inside(active_u).all(), self.region.inside(active_u).mean()</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">need_accept</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we have been told that radius is currently invalid</span>
            <span class="c1"># we need to bootstrap back to a valid state</span>

            <span class="c1"># compute radius given current transformLayer</span>
            <span class="n">oldu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">active_u</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span> <span class="o">=</span> <span class="n">active_node_ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">set_transformLayer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="p">)</span>

            <span class="n">_update_region_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">nbootstraps</span><span class="p">,</span> <span class="n">minvol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)</span>

            <span class="c1"># print(&quot;made first region, r=%e&quot; % (r))</span>

            <span class="c1"># now that we have r, can do clustering</span>
            <span class="c1"># but such reclustering would forget the cluster ids</span>

            <span class="c1"># instead, track the clusters from before by matching manually</span>
            <span class="n">oldt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">oldu</span><span class="p">)</span>
            <span class="n">clusterids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">active_u</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">nnearby</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ci</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># find points from that cluster</span>
                <span class="n">oldti</span> <span class="o">=</span> <span class="n">oldt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="n">ci</span><span class="p">]</span>
                <span class="c1"># identify which new points are near this cluster</span>
                <span class="n">find_nearby</span><span class="p">(</span><span class="n">oldti</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span> <span class="n">nnearby</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">nnearby</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="c1"># assign the nearby ones to this cluster</span>
                <span class="c1"># if they have not been set yet</span>
                <span class="c1"># if they have, set them to -1</span>
                <span class="n">clusterids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">clusterids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># clusters we are unsure about (double assignments) go unassigned</span>
            <span class="n">clusterids</span><span class="p">[</span><span class="n">clusterids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># tell scaling layer the correct cluster information</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">=</span> <span class="n">clusterids</span>

            <span class="c1"># we want the clustering to repeat to remove remaining zeros</span>
            <span class="n">need_accept</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

            <span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">)</span>

            <span class="c1"># verify correctness:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
            <span class="c1"># assert self.region.inside(active_u).all(), self.region.inside(active_u).mean()</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">)</span>
        <span class="c1"># rebuild space</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nextTransformLayer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">create_new</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span><span class="p">,</span> <span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">smallest_cluster</span> <span class="o">=</span> <span class="n">cluster_sizes</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">smallest_cluster</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;clustering found some stray points [need_accept=</span><span class="si">%s</span><span class="s2">] </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">need_accept</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">nextregion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region_class</span><span class="p">(</span><span class="n">active_u</span><span class="p">,</span> <span class="n">nextTransformLayer</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">unormed</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">nclusters</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="s2">&quot;Found a lot of clusters: </span><span class="si">%d</span><span class="s2"> (</span><span class="si">%d</span><span class="s2"> with &gt;1 members)&quot;</span><span class="p">,</span>
                            <span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">nclusters</span><span class="p">,</span> <span class="p">(</span><span class="n">cluster_sizes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

                <span class="c1"># if self.log:</span>
                <span class="c1">#     self.logger.info(&quot;computing maxradius...&quot;)</span>
                <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">_update_region_bootstrap</span><span class="p">(</span><span class="n">nextregion</span><span class="p">,</span> <span class="n">nbootstraps</span><span class="p">,</span> <span class="n">minvol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)</span>
                <span class="c1"># verify correctness:</span>
                <span class="n">nextregion</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">(</span><span class="n">minvol</span><span class="o">=</span><span class="n">minvol</span><span class="p">)</span>

                <span class="c1"># check if live points are numerically colliding or become linearly dependent</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">live_points_healthy</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span> <span class="ow">and</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">active_u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">active_u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dim</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">ellipsoid_cov</span><span class="p">)</span>

                <span class="k">assert</span> <span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">active_u</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">unormed</span><span class="p">,</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">active_u</span><span class="p">))</span>
                <span class="c1"># assert nextregion.inside(active_u).all(),</span>
                <span class="c1">#  (&quot;live points should live in new region, but only %.3f%% do.&quot; % (100 * nextregion.inside(active_u).mean()), active_u)</span>
                <span class="n">good_region</span> <span class="o">=</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="c1"># assert good_region</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good_region</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Proposed region is inconsistent (maxr=</span><span class="si">%f</span><span class="s2">,enlarge=</span><span class="si">%f</span><span class="s2">) and will be skipped.&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

                <span class="c1"># avoid cases where every point is its own cluster,</span>
                <span class="c1"># and even the largest cluster has fewer than x_dim points</span>
                <span class="n">sensible_clustering</span> <span class="o">=</span> <span class="n">nextTransformLayer</span><span class="o">.</span><span class="n">nclusters</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nextregion</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> \
                    <span class="ow">and</span> <span class="n">cluster_sizes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># force shrinkage of volume. avoids reconnecting dying modes</span>
                <span class="k">if</span> <span class="n">good_region</span> <span class="ow">and</span> \
                        <span class="p">(</span><span class="n">need_accept</span> <span class="ow">or</span> <span class="n">nextregion</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">estimate_volume</span><span class="p">())</span> \
                        <span class="ow">and</span> <span class="n">sensible_clustering</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">nextregion</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span> <span class="o">=</span> <span class="n">active_node_ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">need_accept</span><span class="p">,</span> <span class="n">updated</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Warning</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;not updating region&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">FloatingPointError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;not updating region&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;not updating region&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">active_p</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_tregion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
                    <span class="n">tregion</span> <span class="o">=</span> <span class="n">WrappingEllipsoid</span><span class="p">(</span><span class="n">active_p</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">tregion</span><span class="o">.</span><span class="n">compute_enlargement</span><span class="p">(</span>
                        <span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbootstraps</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                        <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">recv_enlarge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recv_enlarge</span><span class="p">)</span>
                    <span class="n">tregion</span><span class="o">.</span><span class="n">enlarge</span> <span class="o">=</span> <span class="n">f</span>
                    <span class="n">tregion</span><span class="o">.</span><span class="n">create_ellipsoid</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span> <span class="o">=</span> <span class="n">tregion</span>
            <span class="k">except</span> <span class="ne">FloatingPointError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;not updating t-ellipsoid&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;not updating t-ellipsoid&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">updated</span>

    <span class="k">def</span> <span class="nf">_expand_nodes_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expand nodes before `Lmin` to have `nnodes_needed`.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Llo: float</span>
<span class="sd">            lowest parent sampled (-np.inf if sampling from root)</span>
<span class="sd">        Lhi: float</span>
<span class="sd">            Lmin</span>
<span class="sd">        target_min_num_children: int</span>
<span class="sd">            number of children that need to be maintained between Llo, Lhi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">parents</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">find_nodes_before</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">)</span>
        <span class="n">target_min_num_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widen_nodes</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Llo</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">)</span>
        <span class="n">Lhi</span> <span class="o">=</span> <span class="n">Lmin</span>
        <span class="k">return</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">target_min_num_children</span>

    <span class="k">def</span> <span class="nf">_should_node_be_expanded</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">minimal_widths_sequence</span><span class="p">,</span> <span class="n">target_min_num_children</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">parallel_values</span><span class="p">,</span> <span class="n">max_ncalls</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">,</span> <span class="n">live_points_healthy</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if node needs new children.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expand_node: bool</span>
<span class="sd">            True if should sample a new point</span>
<span class="sd">            based on this node (above its likelihood value Lmin).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        it: int</span>
<span class="sd">            current iteration</span>
<span class="sd">        node: node</span>
<span class="sd">            The node to consider</span>
<span class="sd">        parallel_values: array of floats</span>
<span class="sd">            loglikelihoods of live points</span>
<span class="sd">        max_ncalls: int</span>
<span class="sd">            maximum number of likelihood function calls allowed</span>
<span class="sd">        max_iters: int</span>
<span class="sd">            maximum number of nested sampling iteration allowed</span>
<span class="sd">        Llo, Lhi, minimal_widths_sequence, target_min_num_children:</span>
<span class="sd">            Current strategy parameters</span>
<span class="sd">        live_points_healthy: bool</span>
<span class="sd">            indicates whether the live points have become</span>
<span class="sd">            linearly dependent (covariance not full rank)</span>
<span class="sd">            or have attained the same exact value in some parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Lmin</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
        <span class="n">nlive</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parallel_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">Lmin</span> <span class="o">&lt;=</span> <span class="n">Lhi</span> <span class="ow">and</span> <span class="n">Llo</span> <span class="o">&lt;=</span> <span class="n">Lhi</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">live_points_healthy</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># some reasons to stop:</span>
        <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_ncalls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">&gt;=</span> <span class="n">max_ncalls</span><span class="p">:</span>
                <span class="c1"># print(&quot;not expanding, because above max_ncall&quot;)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">max_iters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&gt;=</span> <span class="n">max_iters</span><span class="p">:</span>
                <span class="c1"># print(&quot;not expanding, because above max_iters&quot;)</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># in a plateau, only shrink (Fowlie+2020)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Lmin</span> <span class="o">==</span> <span class="n">parallel_values</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">expand_node</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># we should continue to progress towards Lhi</span>
        <span class="k">while</span> <span class="n">Lmin</span> <span class="o">&gt;</span> <span class="n">minimal_widths_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">minimal_widths_sequence</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># get currently desired width</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minimal_width_clusters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># compute number of clusters with more than 1 element</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">nclusters</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_sizes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">minimal_width_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span>

        <span class="n">minimal_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimal_widths_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">minimal_width_clusters</span><span class="p">)</span>

        <span class="c1"># if already has children, no need to expand</span>
        <span class="c1"># if we are wider than the width required</span>
        <span class="c1"># we do not need to expand this one</span>
        <span class="c1"># expand_node = len(node.children) == 0</span>
        <span class="c1"># prefer 1 child, or the number required, if specified</span>
        <span class="n">nmin</span> <span class="o">=</span> <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">target_min_num_children</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">expand_node</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nmin</span>
        <span class="c1"># print(&quot;not expanding, because we are quite wide&quot;, nlive, minimal_width, minimal_widths_sequence)</span>
        <span class="c1"># but we have to expand the first iteration,</span>
        <span class="c1"># otherwise the integrator never sets H</span>
        <span class="n">too_wide</span> <span class="o">=</span> <span class="n">nlive</span> <span class="o">&gt;</span> <span class="n">minimal_width</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">expand_node</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">too_wide</span>

<div class="viewcode-block" id="ReactiveNestedSampler.run"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_interval_volume_fraction</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">show_status</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">viz_callback</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">dKL</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">frac_remain</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="n">Lepsilon</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
            <span class="n">min_ess</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_ncalls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_num_improvement_loops</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">min_num_live_points</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">cluster_num_live_points</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
            <span class="n">insertion_test_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">insertion_test_zscore_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">region_class</span><span class="o">=</span><span class="n">MLFriends</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run until target convergence criteria are fulfilled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update_interval_volume_fraction: float</span>
<span class="sd">            Update region when the volume shrunk by this amount.</span>

<span class="sd">        update_interval_ncall: int</span>
<span class="sd">            Update region after update_interval_ncall likelihood calls (not used).</span>

<span class="sd">        log_interval: int</span>
<span class="sd">            Update stdout status line every log_interval iterations</span>

<span class="sd">        show_status: bool</span>
<span class="sd">            show integration progress as a status line.</span>
<span class="sd">            If no output desired, set to False.</span>

<span class="sd">        viz_callback: function</span>
<span class="sd">            callback function when region was rebuilt. Allows to</span>
<span class="sd">            show current state of the live points.</span>
<span class="sd">            See :func:`nicelogger` or :class:`LivePointsWidget`.</span>
<span class="sd">            If no output desired, set to False.</span>

<span class="sd">        dlogz: float</span>
<span class="sd">            Target evidence uncertainty. This is the std</span>
<span class="sd">            between bootstrapped logz integrators.</span>

<span class="sd">        dKL: float</span>
<span class="sd">            Target posterior uncertainty. This is the</span>
<span class="sd">            Kullback-Leibler divergence in nat between bootstrapped integrators.</span>

<span class="sd">        frac_remain: float</span>
<span class="sd">            Integrate until this fraction of the integral is left in the remainder.</span>
<span class="sd">            Set to a low number (1e-2 ... 1e-5) to make sure peaks are discovered.</span>
<span class="sd">            Set to a higher number (0.5) if you know the posterior is simple.</span>

<span class="sd">        Lepsilon: float</span>
<span class="sd">            Terminate when live point likelihoods are all the same,</span>
<span class="sd">            within Lepsilon tolerance. Increase this when your likelihood</span>
<span class="sd">            function is inaccurate, to avoid unnecessary search.</span>

<span class="sd">        min_ess: int</span>
<span class="sd">            Target number of effective posterior samples.</span>

<span class="sd">        max_iters: int</span>
<span class="sd">            maximum number of integration iterations.</span>

<span class="sd">        max_ncalls: int</span>
<span class="sd">            stop after this many likelihood evaluations.</span>

<span class="sd">        max_num_improvement_loops: int</span>
<span class="sd">            run() tries to assess iteratively where more samples are needed.</span>
<span class="sd">            This number limits the number of improvement loops.</span>

<span class="sd">        min_num_live_points: int</span>
<span class="sd">            minimum number of live points throughout the run</span>

<span class="sd">        cluster_num_live_points: int</span>
<span class="sd">            require at least this many live points per detected cluster</span>

<span class="sd">        insertion_test_zscore_threshold: float</span>
<span class="sd">            z-score used as a threshold for the insertion order test.</span>
<span class="sd">            Set to infinity to disable.</span>

<span class="sd">        insertion_test_window: float</span>
<span class="sd">            Number of iterations after which the insertion order test is reset.</span>

<span class="sd">        region_class: MLFriends or RobustEllipsoidRegion</span>
<span class="sd">            Whether to use MLFriends+ellipsoidal+tellipsoidal region (better for multi-modal problems)</span>
<span class="sd">            or just ellipsoidal sampling (faster for high-dimensional, gaussian-like problems).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_iter</span><span class="p">(</span>
            <span class="n">update_interval_volume_fraction</span><span class="o">=</span><span class="n">update_interval_volume_fraction</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="n">update_interval_ncall</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="n">log_interval</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="n">dlogz</span><span class="p">,</span> <span class="n">dKL</span><span class="o">=</span><span class="n">dKL</span><span class="p">,</span>
            <span class="n">Lepsilon</span><span class="o">=</span><span class="n">Lepsilon</span><span class="p">,</span> <span class="n">frac_remain</span><span class="o">=</span><span class="n">frac_remain</span><span class="p">,</span>
            <span class="n">min_ess</span><span class="o">=</span><span class="n">min_ess</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="n">max_iters</span><span class="p">,</span>
            <span class="n">max_ncalls</span><span class="o">=</span><span class="n">max_ncalls</span><span class="p">,</span> <span class="n">max_num_improvement_loops</span><span class="o">=</span><span class="n">max_num_improvement_loops</span><span class="p">,</span>
            <span class="n">min_num_live_points</span><span class="o">=</span><span class="n">min_num_live_points</span><span class="p">,</span>
            <span class="n">cluster_num_live_points</span><span class="o">=</span><span class="n">cluster_num_live_points</span><span class="p">,</span>
            <span class="n">show_status</span><span class="o">=</span><span class="n">show_status</span><span class="p">,</span>
            <span class="n">viz_callback</span><span class="o">=</span><span class="n">viz_callback</span><span class="p">,</span>
            <span class="n">insertion_test_window</span><span class="o">=</span><span class="n">insertion_test_window</span><span class="p">,</span>
            <span class="n">insertion_test_zscore_threshold</span><span class="o">=</span><span class="n">insertion_test_zscore_threshold</span><span class="p">,</span>
            <span class="n">region_class</span><span class="o">=</span><span class="n">region_class</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;did a run_iter pass!&quot;</span><span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;done iterating.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.run_iter"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.run_iter">[docs]</a>    <span class="k">def</span> <span class="nf">run_iter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_interval_volume_fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
            <span class="n">update_interval_ncall</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">log_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dlogz</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">dKL</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">frac_remain</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="n">Lepsilon</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
            <span class="n">min_ess</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_ncalls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_num_improvement_loops</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">min_num_live_points</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">cluster_num_live_points</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
            <span class="n">show_status</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">viz_callback</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
            <span class="n">insertion_test_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">insertion_test_zscore_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">region_class</span><span class="o">=</span><span class="n">MLFriends</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate towards convergence.</span>

<span class="sd">        Use as an iterator like so::</span>

<span class="sd">            for result in sampler.run_iter(...):</span>
<span class="sd">                print(&#39;lnZ = %(logz).2f +- %(logzerr).2f&#39; % result)</span>

<span class="sd">        Parameters as described in run() method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># frac_remain=1  means 1:1 -&gt; dlogz=log(0.5)</span>
        <span class="c1"># frac_remain=0.1 means 1:10 -&gt; dlogz=log(0.1)</span>
        <span class="c1"># dlogz_min = log(1./(1 + frac_remain))</span>
        <span class="c1"># dlogz_min = -log1p(frac_remain)</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">frac_remain</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dlogz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;To achieve the desired logz accuracy, set frac_remain to a value much smaller than </span><span class="si">%s</span><span class="s2"> (currently: </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dlogz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frac_remain</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_pointstore</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Resuming from </span><span class="si">%d</span><span class="s2"> stored points&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">assert</span> <span class="n">min_num_live_points</span> <span class="o">&gt;=</span> <span class="n">cluster_num_live_points</span><span class="p">,</span> \
            <span class="p">(</span><span class="s1">&#39;min_num_live_points(</span><span class="si">%d</span><span class="s1">) cannot be less than cluster_num_live_points(</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">min_num_live_points</span><span class="p">,</span> <span class="n">cluster_num_live_points</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_num_live_points</span> <span class="o">=</span> <span class="n">min_num_live_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_num_live_points</span> <span class="o">=</span> <span class="n">cluster_num_live_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_slow_warned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_tregion</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_class</span> <span class="o">=</span> <span class="n">region_class</span>
        <span class="n">update_interval_volume_log_fraction</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">update_interval_volume_fraction</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">viz_callback</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">viz_callback</span> <span class="o">=</span> <span class="n">get_default_viz_callback</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_widen_roots</span><span class="p">(</span><span class="n">min_num_live_points</span><span class="p">)</span>

        <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Lmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">strategy_stale</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">minimal_widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target_min_num_children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">improvement_it</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">assert</span> <span class="n">max_iters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_iters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Invalid value for max_iters: </span><span class="si">%s</span><span class="s2">. Set to None or positive number&quot;</span> <span class="o">%</span> <span class="n">max_iters</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">max_ncalls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_ncalls</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Invalid value for max_ncalls: </span><span class="si">%s</span><span class="s2">. Set to None or positive number&quot;</span> <span class="o">%</span> <span class="n">max_ncalls</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;run_iter dlogz=</span><span class="si">%.1f</span><span class="s1">, dKL=</span><span class="si">%.1f</span><span class="s1">, frac_remain=</span><span class="si">%.2f</span><span class="s1">, Lepsilon=</span><span class="si">%.4f</span><span class="s1">, min_ess=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">dlogz</span><span class="p">,</span> <span class="n">dKL</span><span class="p">,</span> <span class="n">frac_remain</span><span class="p">,</span> <span class="n">Lepsilon</span><span class="p">,</span> <span class="n">min_ess</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;max_iters=</span><span class="si">%d</span><span class="s1">, max_ncalls=</span><span class="si">%d</span><span class="s1">, max_num_improvement_loops=</span><span class="si">%d</span><span class="s1">, min_num_live_points=</span><span class="si">%d</span><span class="s1">, cluster_num_live_points=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">max_iters</span> <span class="k">if</span> <span class="n">max_iters</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_ncalls</span> <span class="k">if</span> <span class="n">max_ncalls</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">max_num_improvement_loops</span><span class="p">,</span> <span class="n">min_num_live_points</span><span class="p">,</span> <span class="n">cluster_num_live_points</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span>

            <span class="n">nroots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">update_interval_ncall</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">update_interval_ncall</span> <span class="o">=</span> <span class="n">nroots</span>

            <span class="k">if</span> <span class="n">log_interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">nroots</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log_interval</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">log_interval</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">log_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;log_interval must be &gt;= 1&quot;</span><span class="p">)</span>

            <span class="n">explorer</span> <span class="o">=</span> <span class="n">BreadthFirstIterator</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
            <span class="c1"># Integrating thing</span>
            <span class="n">main_iterator</span> <span class="o">=</span> <span class="n">MultiCounter</span><span class="p">(</span>
                <span class="n">nroots</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">),</span>
                <span class="n">nbootstraps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bootstraps</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">),</span>
                <span class="n">random</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_insertion_order</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lmax</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">))</span>
            <span class="n">insertion_test</span> <span class="o">=</span> <span class="n">UniformOrderAccumulator</span><span class="p">(</span><span class="n">nroots</span><span class="p">)</span>
            <span class="n">insertion_test_runs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">insertion_test_quality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">insertion_test_direction</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">live_points_healthy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">it_at_first_region</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span><span class="p">:</span>
                <span class="n">ndraw</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ndraw</span> <span class="o">=</span> <span class="mi">40</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_pointstore</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">stack_empty</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_point_stack</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Llo</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhi</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Exploring (in particular: L=</span><span class="si">%.2f</span><span class="s2">..</span><span class="si">%.2f</span><span class="s2">) ...&quot;</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">)</span>
            <span class="n">region_sequence</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">minimal_widths_sequence</span> <span class="o">=</span> <span class="n">_sequentialize_width_sequence</span><span class="p">(</span><span class="n">minimal_widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_num_live_points</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;minimal_widths_sequence: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">minimal_widths_sequence</span><span class="p">)</span>

            <span class="n">saved_nodeids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">saved_logl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ncall_at_run_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span>
            <span class="n">ncall_region_at_run_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span>
            <span class="n">next_update_interval_volume</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">last_status</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1"># we go through each live point (regardless of root) by likelihood value</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">next_node</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">next_node</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">active_rootids</span><span class="p">,</span> <span class="n">active_values</span><span class="p">,</span> <span class="n">active_node_ids</span><span class="p">)</span> <span class="o">=</span> <span class="n">next_node</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rootid</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="c1"># this is the likelihood level we have to improve upon</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Lmin</span> <span class="o">=</span> <span class="n">Lmin</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

                <span class="c1"># if within suggested range, expand</span>
                <span class="k">if</span> <span class="n">strategy_stale</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">Lmin</span> <span class="o">&lt;=</span> <span class="n">Lhi</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhi</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">active_values</span> <span class="o">==</span> <span class="n">Lmin</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="c1"># check with advisor if we want to expand this node</span>
                    <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_strategy_advice</span><span class="p">(</span>
                        <span class="n">Lmin</span><span class="p">,</span> <span class="n">active_values</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span>
                        <span class="n">minimal_widths</span><span class="p">,</span> <span class="n">frac_remain</span><span class="p">,</span> <span class="n">Lepsilon</span><span class="o">=</span><span class="n">Lepsilon</span><span class="p">)</span>
                    <span class="c1"># when we are going to the peak, numerical accuracy</span>
                    <span class="c1"># can become an issue. We should try not to get stuck there</span>
                    <span class="n">strategy_stale</span> <span class="o">=</span> <span class="n">Lhi</span> <span class="o">-</span> <span class="n">Llo</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lepsilon</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>

                <span class="n">expand_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_node_be_expanded</span><span class="p">(</span>
                    <span class="n">it</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">minimal_widths_sequence</span><span class="p">,</span>
                    <span class="n">target_min_num_children</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">active_values</span><span class="p">,</span>
                    <span class="n">max_ncalls</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">live_points_healthy</span><span class="p">)</span>

                <span class="n">region_fresh</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">expand_node</span><span class="p">:</span>
                    <span class="c1"># sample a new point above Lmin</span>
                    <span class="n">active_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">getu</span><span class="p">(</span><span class="n">active_node_ids</span><span class="p">)</span>
                    <span class="n">active_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">getp</span><span class="p">(</span><span class="n">active_node_ids</span><span class="p">)</span>
                    <span class="n">nlive</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_u</span><span class="p">)</span>
                    <span class="c1"># first we check that the region is up-to-date</span>
                    <span class="k">if</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span> <span class="o">&lt;</span> <span class="n">next_update_interval_volume</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">it_at_first_region</span> <span class="o">=</span> <span class="n">it</span>
                        <span class="n">region_fresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_region</span><span class="p">(</span>
                            <span class="n">active_u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_p</span><span class="o">=</span><span class="n">active_p</span><span class="p">,</span> <span class="n">active_node_ids</span><span class="o">=</span><span class="n">active_node_ids</span><span class="p">,</span>
                            <span class="n">active_rootids</span><span class="o">=</span><span class="n">active_rootids</span><span class="p">,</span>
                            <span class="n">bootstrap_rootids</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">rootids</span><span class="p">[</span><span class="mi">1</span><span class="p">:,],</span>
                            <span class="n">nbootstraps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_bootstraps</span><span class="p">,</span>
                            <span class="n">minvol</span><span class="o">=</span><span class="n">exp</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span><span class="p">))</span>

                        <span class="k">if</span> <span class="n">region_fresh</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">stepsampler</span><span class="o">.</span><span class="n">region_changed</span><span class="p">(</span><span class="n">active_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

                        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">nclusters</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_sizes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="n">region_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">nlive</span><span class="p">,</span> <span class="n">nclusters</span><span class="p">))</span>

                        <span class="c1"># next_update_interval_ncall = self.ncall + (update_interval_ncall or nlive)</span>
                        <span class="n">next_update_interval_volume</span> <span class="o">=</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span> <span class="o">+</span> <span class="n">update_interval_volume_log_fraction</span>

                        <span class="c1"># provide nice output to follow what is going on</span>
                        <span class="c1"># but skip if we are resuming</span>
                        <span class="c1">#  and (self.ncall != ncall_at_run_start and it_at_first_region == it)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">viz_callback</span><span class="p">:</span>
                            <span class="n">viz_callback</span><span class="p">(</span>
                                <span class="n">points</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">active_p</span><span class="p">,</span> <span class="n">logl</span><span class="o">=</span><span class="n">active_values</span><span class="p">),</span>
                                <span class="n">info</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                                    <span class="n">it</span><span class="o">=</span><span class="n">it</span><span class="p">,</span> <span class="n">ncall</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span>
                                    <span class="n">logz</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span>
                                    <span class="n">logz_remain</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logZremain</span><span class="p">,</span>
                                    <span class="n">logvol</span><span class="o">=</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">logVolremaining</span><span class="p">,</span>
                                    <span class="n">paramnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">,</span>
                                    <span class="n">paramlims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_limits</span><span class="p">,</span>
                                    <span class="n">order_test_correlation</span><span class="o">=</span><span class="n">insertion_test_quality</span><span class="p">,</span>
                                    <span class="n">order_test_direction</span><span class="o">=</span><span class="n">insertion_test_direction</span><span class="p">,</span>
                                <span class="p">),</span>
                                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">transformLayer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="p">,</span>
                                <span class="n">region_fresh</span><span class="o">=</span><span class="n">region_fresh</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">nlive</span> <span class="o">&lt;</span> <span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span> <span class="ow">and</span> <span class="n">improvement_it</span> <span class="o">&lt;</span> <span class="n">max_num_improvement_loops</span><span class="p">:</span>
                        <span class="c1"># make wider here</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                                <span class="s2">&quot;Found </span><span class="si">%d</span><span class="s2"> clusters, but only have </span><span class="si">%d</span><span class="s2"> live points, want </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">nclusters</span><span class="p">,</span> <span class="n">nlive</span><span class="p">,</span>
                                <span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span><span class="p">)</span>
                        <span class="k">break</span>

                    <span class="c1"># sample point</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_point</span><span class="p">(</span><span class="n">Lmin</span><span class="o">=</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">ndraw</span><span class="o">=</span><span class="n">ndraw</span><span class="p">,</span> <span class="n">active_u</span><span class="o">=</span><span class="n">active_u</span><span class="p">,</span> <span class="n">active_values</span><span class="o">=</span><span class="n">active_values</span><span class="p">)</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">insertion_test_zscore_threshold</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nlive</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">insertion_test</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">active_values</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">nlive</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">insertion_test</span><span class="o">.</span><span class="n">zscore</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">insertion_test_zscore_threshold</span><span class="p">:</span>
                            <span class="n">insertion_test_runs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">insertion_test</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
                            <span class="n">insertion_test_quality</span> <span class="o">=</span> <span class="n">insertion_test</span><span class="o">.</span><span class="n">N</span>
                            <span class="n">insertion_test_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">insertion_test</span><span class="o">.</span><span class="n">zscore</span><span class="p">)</span>
                            <span class="n">insertion_test</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                        <span class="k">elif</span> <span class="n">insertion_test</span><span class="o">.</span><span class="n">N</span> <span class="o">&gt;</span> <span class="n">nlive</span> <span class="o">*</span> <span class="n">insertion_test_window</span><span class="p">:</span>
                            <span class="n">insertion_test_quality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                            <span class="n">insertion_test_direction</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">insertion_test</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

                    <span class="c1"># identify which point is being replaced (from when we built the region)</span>
                    <span class="n">worst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region_nodes</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">id</span>
                    <span class="c1"># if we keep the region informed about the new live points</span>
                    <span class="c1"># then the region follows the live points even if maxradius is not updated</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">unormed</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                    <span class="c1"># move also the ellipsoid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">ellipsoid_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tregion</span><span class="o">.</span><span class="n">ellipsoid_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">active_p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># if we track the cluster assignment, then in the next round</span>
                    <span class="c1"># the ids with the same members are likely to have the same id</span>
                    <span class="c1"># this is imperfect</span>
                    <span class="c1"># transformLayer.clusterids[worst] = transformLayer.clusterids[father[ib]]</span>
                    <span class="c1"># so we just mark the replaced ones as &quot;unassigned&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transformLayer</span><span class="o">.</span><span class="n">clusterids</span><span class="p">[</span><span class="n">worst</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="p">(</span><span class="n">region_fresh</span> <span class="ow">or</span> <span class="n">it</span> <span class="o">%</span> <span class="n">log_interval</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">last_status</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">):</span>
                        <span class="n">last_status</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="c1"># the number of proposals asked from region</span>
                        <span class="n">ncall_region_here</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span> <span class="o">-</span> <span class="n">ncall_region_at_run_start</span><span class="p">)</span>
                        <span class="c1"># the number of proposals returned by the region</span>
                        <span class="n">ncall_here</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">-</span> <span class="n">ncall_at_run_start</span>
                        <span class="c1"># the number of likelihood evaluations above threshold</span>
                        <span class="n">it_here</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">it_at_first_region</span>

                        <span class="k">if</span> <span class="n">show_status</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">Lmin</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e8</span><span class="p">:</span>
                                <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;Z=</span><span class="si">%.1g</span><span class="s1">(</span><span class="si">%.2f%%</span><span class="s1">) | Like=</span><span class="si">%.2g</span><span class="s1">..</span><span class="si">%.2g</span><span class="s1"> [</span><span class="si">%.4g</span><span class="s1">..</span><span class="si">%.4g</span><span class="s1">]</span><span class="si">%s</span><span class="s1">| it/evals=</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1"> eff=</span><span class="si">%.4f%%</span><span class="s1"> N=</span><span class="si">%d</span><span class="s1"> </span><span class="se">\r</span><span class="s1">&#39;</span>
                            <span class="k">elif</span> <span class="n">Llo</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e8</span><span class="p">:</span>
                                <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;Z=</span><span class="si">%.1f</span><span class="s1">(</span><span class="si">%.2f%%</span><span class="s1">) | Like=</span><span class="si">%.2f</span><span class="s1">..</span><span class="si">%.2f</span><span class="s1"> [</span><span class="si">%.4g</span><span class="s1">..</span><span class="si">%.4g</span><span class="s1">]</span><span class="si">%s</span><span class="s1">| it/evals=</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1"> eff=</span><span class="si">%.4f%%</span><span class="s1"> N=</span><span class="si">%d</span><span class="s1"> </span><span class="se">\r</span><span class="s1">&#39;</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;Z=</span><span class="si">%.1f</span><span class="s1">(</span><span class="si">%.2f%%</span><span class="s1">) | Like=</span><span class="si">%.2f</span><span class="s1">..</span><span class="si">%.2f</span><span class="s1"> [</span><span class="si">%.4f</span><span class="s1">..</span><span class="si">%.4f</span><span class="s1">]</span><span class="si">%s</span><span class="s1">| it/evals=</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1"> eff=</span><span class="si">%.4f%%</span><span class="s1"> N=</span><span class="si">%d</span><span class="s1"> </span><span class="se">\r</span><span class="s1">&#39;</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">txt</span> <span class="o">%</span> <span class="p">(</span>
                                <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">remainder_fraction</span><span class="p">),</span>
                                <span class="n">Lmin</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span> <span class="k">if</span> <span class="n">strategy_stale</span> <span class="k">else</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">ncall_here</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">it_here</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ncall_here</span><span class="p">,</span>
                                <span class="n">nlive</span><span class="p">))</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;iteration=</span><span class="si">%d</span><span class="s1">, ncalls=</span><span class="si">%d</span><span class="s1">, logz=</span><span class="si">%.2f</span><span class="s1">, remainder_fraction=</span><span class="si">%.4f%%</span><span class="s1">, Lmin=</span><span class="si">%.2f</span><span class="s1">, Lmax=</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">it</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ</span><span class="p">,</span>
                            <span class="mi">100</span> <span class="o">*</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">remainder_fraction</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span><span class="p">))</span>

                        <span class="c1"># if efficiency becomes low, bulk-process larger arrays</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_multiple</span><span class="p">:</span>
                            <span class="c1"># inefficiency is the number of (region) proposals per successful number of iterations</span>
                            <span class="c1"># but improves by parallelism (because we need only the per-process inefficiency)</span>
                            <span class="c1"># sampling_inefficiency = (self.ncall - ncall_at_run_start + 1) / (it + 1) / self.mpi_size</span>
                            <span class="n">sampling_inefficiency</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncall_region_here</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">it_here</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span>

                            <span class="c1"># smooth update:</span>
                            <span class="n">ndraw_next</span> <span class="o">=</span> <span class="mf">0.04</span> <span class="o">*</span> <span class="n">sampling_inefficiency</span> <span class="o">+</span> <span class="n">ndraw</span> <span class="o">*</span> <span class="mf">0.96</span>
                            <span class="n">ndraw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndraw_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndraw_max</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">ndraw_next</span><span class="p">),</span> <span class="n">ndraw</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>

                            <span class="k">if</span> <span class="n">sampling_inefficiency</span> <span class="o">&gt;</span> <span class="mi">100000</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&gt;=</span> <span class="n">it_at_first_region</span> <span class="o">+</span> <span class="mi">10</span><span class="p">:</span>
                                <span class="c1"># if the efficiency is poor, there are enough samples in each iteration</span>
                                <span class="c1"># to estimate the inefficiency</span>
                                <span class="n">ncall_at_run_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span>
                                <span class="n">it_at_first_region</span> <span class="o">=</span> <span class="n">it</span>
                                <span class="n">ncall_region_at_run_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall_region</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we do not want to count iterations without work</span>
                    <span class="c1"># otherwise efficiency becomes &gt; 1</span>
                    <span class="n">it_at_first_region</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">saved_nodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">saved_logl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lmin</span><span class="p">)</span>

                <span class="c1"># inform iterators (if it is their business) about the arc</span>
                <span class="n">main_iterator</span><span class="o">.</span><span class="n">passing_node</span><span class="p">(</span><span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">active_rootids</span><span class="p">,</span> <span class="n">active_values</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># the region radius needs to increase if nlive decreases</span>
                    <span class="c1"># radius is not reliable, so set to inf</span>
                    <span class="c1"># (heuristics do not work in practice)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">maxradiussq</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># ask for the region to be rebuilt</span>
                    <span class="n">next_update_interval_volume</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">explorer</span><span class="o">.</span><span class="n">expand_children_of</span><span class="p">(</span><span class="n">rootid</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Explored until L=</span><span class="si">%.1g</span><span class="s2">  &quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># print_tree(roots[::10])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_results</span><span class="p">(</span><span class="n">main_iterator</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">,</span> <span class="n">saved_nodeids</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span>

            <span class="k">if</span> <span class="n">max_ncalls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="o">&gt;=</span> <span class="n">max_ncalls</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s1">&#39;Reached maximum number of likelihood calls (</span><span class="si">%d</span><span class="s1"> &gt; </span><span class="si">%d</span><span class="s1">)...&#39;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">,</span> <span class="n">max_ncalls</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">improvement_it</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">max_num_improvement_loops</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">improvement_it</span> <span class="o">&gt;</span> <span class="n">max_num_improvement_loops</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reached maximum number of improvement loops.&#39;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">ncall_at_run_start</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span> <span class="ow">and</span> <span class="n">improvement_it</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s1">&#39;No changes made. &#39;</span>
                        <span class="s1">&#39;Probably the strategy was to explore in the remainder, &#39;</span>
                        <span class="s1">&#39;but it is irrelevant already; try decreasing frac_remain.&#39;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">Lmax</span> <span class="o">=</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">region_sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Lmin</span><span class="p">,</span> <span class="n">nlive</span><span class="p">,</span> <span class="n">nclusters</span> <span class="o">=</span> <span class="n">region_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nnodes_needed</span> <span class="o">=</span> <span class="n">cluster_num_live_points</span> <span class="o">*</span> <span class="n">nclusters</span>
                <span class="k">if</span> <span class="n">nlive</span> <span class="o">&lt;</span> <span class="n">nnodes_needed</span><span class="p">:</span>
                    <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">target_min_num_children_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_nodes_before</span><span class="p">(</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span> <span class="ow">or</span> <span class="n">nlive</span><span class="p">)</span>
                    <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target_min_num_children_new</span><span class="p">)</span>
                    <span class="c1"># if self.log:</span>
                    <span class="c1">#     print_tree(self.root.children[::10])</span>
                    <span class="n">minimal_widths</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Llo</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">))</span>
                    <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="c1"># self.logger.info(&#39;  logZ = %.4f +- %.4f (main)&#39; % (main_iterator.logZ, main_iterator.logZerr))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  logZ = </span><span class="si">%.4g</span><span class="s1"> +- </span><span class="si">%.4g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZ_bs</span><span class="p">,</span> <span class="n">main_iterator</span><span class="o">.</span><span class="n">logZerr_bs</span><span class="p">)</span>

            <span class="n">saved_logl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">)</span>
            <span class="p">(</span><span class="n">Llo_Z</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">),</span> <span class="p">(</span><span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Lhi_ess</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_strategy</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">dlogz</span><span class="o">=</span><span class="n">dlogz</span><span class="p">,</span> <span class="n">dKL</span><span class="o">=</span><span class="n">dKL</span><span class="p">,</span> <span class="n">min_ess</span><span class="o">=</span><span class="n">min_ess</span><span class="p">)</span>
            <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Llo_ess</span><span class="p">,</span> <span class="n">Llo_KL</span><span class="p">,</span> <span class="n">Llo_Z</span><span class="p">)</span>
            <span class="n">Lhi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lhi_ess</span><span class="p">,</span> <span class="n">Lhi_KL</span><span class="p">,</span> <span class="n">Lhi_Z</span><span class="p">)</span>
            <span class="c1"># to avoid numerical issues when all likelihood values are the same</span>
            <span class="n">Lhi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Lhi</span><span class="p">,</span> <span class="n">saved_logl</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.001</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span><span class="p">:</span>
                <span class="n">recv_Llo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">Llo</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_Llo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_Llo</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_Lhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">Lhi</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">recv_Lhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">recv_Lhi</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">recv_Llo</span><span class="p">)</span>
                <span class="n">Lhi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">recv_Lhi</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Llo</span> <span class="o">&lt;=</span> <span class="n">Lhi</span><span class="p">:</span>
                <span class="c1"># if self.log:</span>
                <span class="c1">#     print_tree(roots, title=&quot;Tree before forking:&quot;)</span>
                <span class="n">parents</span><span class="p">,</span> <span class="n">parent_weights</span> <span class="o">=</span> <span class="n">find_nodes_before</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">Llo</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">count_tree_between</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">)</span>
                <span class="n">nnodes_needed</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s1">&#39;Widening from </span><span class="si">%d</span><span class="s1"> to </span><span class="si">%d</span><span class="s1"> live points before L=</span><span class="si">%.1g</span><span class="s1">...&#39;</span><span class="p">,</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">),</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">Llo</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">Llo</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Llo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointstore</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="n">target_min_num_children</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_widen_nodes</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">parent_weights</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">,</span> <span class="n">update_interval_ncall</span><span class="p">))</span>
                <span class="n">minimal_widths</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Llo</span><span class="p">,</span> <span class="n">Lhi</span><span class="p">,</span> <span class="n">nnodes_needed</span><span class="p">))</span>
                <span class="c1"># if self.log:</span>
                <span class="c1">#     print_tree(roots, title=&quot;Tree after forking:&quot;)</span>
                <span class="c1"># print(&#39;tree size:&#39;, count_tree(roots))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span></div>

    <span class="k">def</span> <span class="nf">_update_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">,</span> <span class="n">saved_logl</span><span class="p">,</span> <span class="n">saved_nodeids</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Likelihood function evaluations: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">combine_results</span><span class="p">(</span>
            <span class="n">saved_logl</span><span class="p">,</span> <span class="n">saved_nodeids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="p">,</span>
            <span class="n">main_iterator</span><span class="p">,</span> <span class="n">mpi_comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpi</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ncall&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncall</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;paramnames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;logzerr_single&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">all_H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_num_live_points</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="n">sequence</span><span class="p">,</span> <span class="n">results2</span> <span class="o">=</span> <span class="n">logz_sequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_insertion_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;insertion_order_MWW_test&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">results2</span><span class="p">[</span><span class="s1">&#39;insertion_order_MWW_test&#39;</span><span class="p">]</span>

        <span class="n">results_simple</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">weighted_samples</span> <span class="o">=</span> <span class="n">results_simple</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weighted_samples&#39;</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">results_simple</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;samples&#39;</span><span class="p">)</span>
        <span class="n">saved_wt0</span> <span class="o">=</span> <span class="n">weighted_samples</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
        <span class="n">saved_u</span> <span class="o">=</span> <span class="n">weighted_samples</span><span class="p">[</span><span class="s1">&#39;upoints&#39;</span><span class="p">]</span>
        <span class="n">saved_v</span> <span class="o">=</span> <span class="n">weighted_samples</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing samples and results to disk ...&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;equal_weighted_post.txt&#39;</span><span class="p">),</span>
                       <span class="n">samples</span><span class="p">,</span>
                       <span class="n">header</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">),</span>
                       <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;weighted_post.txt&#39;</span><span class="p">),</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">saved_wt0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">saved_v</span><span class="p">)),</span>
                       <span class="n">header</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="s1">&#39;logl&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">),</span>
                       <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;weighted_post_untransformed.txt&#39;</span><span class="p">),</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">saved_wt0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">saved_logl</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">saved_u</span><span class="p">)),</span>
                       <span class="n">header</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="s1">&#39;logl&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">),</span>
                       <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">],</span> <span class="s1">&#39;results.json&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">results_simple</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">],</span> <span class="s1">&#39;post_summary.csv&#39;</span><span class="p">),</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;posterior&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;stdev&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;errlo&#39;</span><span class="p">,</span> <span class="s1">&#39;errup&#39;</span><span class="p">)])],</span>
                <span class="n">header</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;&quot;</span><span class="si">{0}</span><span class="s1">_mean&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_stdev&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_median&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_errlo&quot;, &quot;</span><span class="si">{0}</span><span class="s1">_errup&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">]),</span>
                <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="s1">&#39;logz&#39;</span><span class="p">,</span> <span class="s1">&#39;logzerr&#39;</span><span class="p">,</span> <span class="s1">&#39;logvol&#39;</span><span class="p">,</span> <span class="s1">&#39;nlive&#39;</span><span class="p">,</span> <span class="s1">&#39;logl&#39;</span><span class="p">,</span> <span class="s1">&#39;logwt&#39;</span><span class="p">,</span> <span class="s1">&#39;insert_order&#39;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;chains&#39;</span><span class="p">],</span> <span class="s1">&#39;run.txt&#39;</span><span class="p">),</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">])),</span>
                       <span class="n">header</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span>
                       <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing samples and results to disk ... done&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_sequence</span> <span class="o">=</span> <span class="n">sequence</span>

<div class="viewcode-block" id="ReactiveNestedSampler.store_tree"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.store_tree">[docs]</a>    <span class="k">def</span> <span class="nf">store_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store tree to disk (results/tree.hdf5).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">dump_tree</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">],</span> <span class="s1">&#39;tree.hdf5&#39;</span><span class="p">),</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpile</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.print_results"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.print_results">[docs]</a>    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logZ</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">posterior</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give summary of marginal likelihood and parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;logZ = </span><span class="si">%(logz).3f</span><span class="s1"> +- </span><span class="si">%(logzerr).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  single instance: logZ = </span><span class="si">%(logz_single).3f</span><span class="s1"> +- </span><span class="si">%(logzerr_single).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  bootstrapped   : logZ = </span><span class="si">%(logz_bs).3f</span><span class="s1"> +- </span><span class="si">%(logzerr_bs).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  tail           : logZ = +- </span><span class="si">%(logzerr_tail).3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;insert order U test : converged: </span><span class="si">%(converged)s</span><span class="s1"> correlation: </span><span class="si">%(independent_iterations)s</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;insertion_order_MWW_test&#39;</span><span class="p">]))</span>

            <span class="nb">print</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                <span class="n">med</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sigma</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">.</span><span class="si">%d</span><span class="s1">f&#39;</span> <span class="o">%</span> <span class="n">i</span>
                <span class="n">fmts</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;    </span><span class="si">%-20s</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">fmt</span> <span class="o">+</span> <span class="s2">&quot; +- &quot;</span> <span class="o">+</span> <span class="n">fmt</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">fmts</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">med</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make corner, run and trace plots.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_corner</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_run</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_trace</span><span class="p">()</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot_corner"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot_corner">[docs]</a>    <span class="k">def</span> <span class="nf">plot_corner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make corner plot.</span>

<span class="sd">        Writes corner plot to plots/ directory if log directory was</span>
<span class="sd">        specified, otherwise show interactively.</span>

<span class="sd">        This does essentially::</span>

<span class="sd">            from ultranest.plot import cornerplot</span>
<span class="sd">            cornerplot(results)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">cornerplot</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making corner plot ...&#39;</span><span class="p">)</span>
        <span class="n">cornerplot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;corner.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making corner plot ... done&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot_trace"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot_trace">[docs]</a>    <span class="k">def</span> <span class="nf">plot_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make trace plot.</span>

<span class="sd">        Write parameter trace diagnostic plots to plots/ directory</span>
<span class="sd">        if log directory specified, otherwise show interactively.</span>

<span class="sd">        This does essentially::</span>

<span class="sd">            from ultranest.plot import traceplot</span>
<span class="sd">            traceplot(results=results, labels=paramnames + derivedparamnames)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">traceplot</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making trace plot ... &#39;</span><span class="p">)</span>
        <span class="n">paramnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivedparamnames</span>
        <span class="c1"># get dynesty-compatible sequences</span>
        <span class="n">traceplot</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_sequence</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">paramnames</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;trace.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making trace plot ... done&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReactiveNestedSampler.plot_run"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.ReactiveNestedSampler.plot_run">[docs]</a>    <span class="k">def</span> <span class="nf">plot_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make run plot.</span>

<span class="sd">        Write run diagnostic plots to plots/ directory</span>
<span class="sd">        if log directory specified, otherwise show interactively.</span>

<span class="sd">        This does essentially::</span>

<span class="sd">            from ultranest.plot import runplot</span>
<span class="sd">            runplot(results=results)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">runplot</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making run plot ... &#39;</span><span class="p">)</span>
        <span class="c1"># get dynesty-compatible sequences</span>
        <span class="n">runplot</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_sequence</span><span class="p">,</span> <span class="n">logplot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_to_disk</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">],</span> <span class="s1">&#39;run.pdf&#39;</span><span class="p">),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Making run plot ... done&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="read_file"><a class="viewcode-back" href="../../ultranest.html#ultranest.integrator.read_file">[docs]</a><span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">num_bootstraps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_insertion_order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read the output HDF5 file of UltraNest.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_dir: str</span>
<span class="sd">        Folder containing results</span>
<span class="sd">    x_dim: int</span>
<span class="sd">        number of dimensions</span>
<span class="sd">    num_bootstraps: int</span>
<span class="sd">        number of bootstraps to use for estimating logZ.</span>
<span class="sd">    random: bool</span>
<span class="sd">        use randomization for volume estimation.</span>
<span class="sd">    verbose: bool</span>
<span class="sd">        show progress</span>
<span class="sd">    check_insertion_order: bool</span>
<span class="sd">        whether to perform MWW insertion order test for assessing convergence</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    sequence: dict</span>
<span class="sd">        contains arrays storing for each iteration estimates of:</span>

<span class="sd">            * logz: log evidence estimate</span>
<span class="sd">            * logzerr: log evidence uncertainty estimate</span>
<span class="sd">            * logvol: log volume estimate</span>
<span class="sd">            * samples_n: number of live points</span>
<span class="sd">            * logwt: log weight</span>
<span class="sd">            * logl: log likelihood</span>

<span class="sd">    final: dict</span>
<span class="sd">        same as ReactiveNestedSampler.results and</span>
<span class="sd">        ReactiveNestedSampler.run return values</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">h5py</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="s1">&#39;points.hdf5&#39;</span><span class="p">)</span>
    <span class="n">fileobj</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">num_params</span> <span class="o">=</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">x_dim</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">fileobj</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">][:]</span>
    <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">fileobj</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>

    <span class="n">pointpile</span> <span class="o">=</span> <span class="n">PointPile</span><span class="p">(</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">num_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">Lmin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; find matching sample from points file &quot;&quot;&quot;</span>
        <span class="c1"># look forward to see if there is an exact match</span>
        <span class="c1"># if we do not use the exact matches</span>
        <span class="c1">#   this causes a shift in the loglikelihoods</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">next_row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
            <span class="n">row_Lmin</span> <span class="o">=</span> <span class="n">next_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">next_row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">row_Lmin</span> <span class="o">&lt;=</span> <span class="n">Lmin</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="n">Lmin</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">logl</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_params</span><span class="p">]</span>
        <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">roots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">onNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">main_iterator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; insert (single) child of node if available &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                 <span class="k">break</span>
            <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logl</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span><span class="p">:</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x_dim</span> <span class="o">+</span> <span class="n">num_params</span><span class="p">]</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">pointpile</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">logl</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">main_iterator</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="n">logl</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">logz_sequence</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pointpile</span><span class="p">,</span> <span class="n">nbootstraps</span><span class="o">=</span><span class="n">num_bootstraps</span><span class="p">,</span>
                         <span class="n">random</span><span class="o">=</span><span class="n">random</span><span class="p">,</span> <span class="n">onNode</span><span class="o">=</span><span class="n">onNode</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                         <span class="n">check_insertion_order</span><span class="o">=</span><span class="n">check_insertion_order</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2014-2020, Johannes Buchner

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>