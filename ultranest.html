

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ultranest package &mdash; UltraNest 3.2.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/icon.ico"/>
  
  
  
    <link rel="canonical" href="https://johannesbuchner.github.io/UltraNest/ultranest.html"/>
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Frequently Asked Questions" href="issues.html" />
    <link rel="prev" title="API" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> UltraNest
          

          
            
            <img src="_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">UltraNest</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="method.html">Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-ultranest.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="priors.html">Specifying priors</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Tour of the features</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">ultranest package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.dychmc">ultranest.dychmc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.dyhmc">ultranest.dyhmc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.flatnuts">ultranest.flatnuts module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#flatnuts">FLATNUTS</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.integrator">ultranest.integrator module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.mlfriends">ultranest.mlfriends module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">ultranest.mlfriends module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.netiter">ultranest.netiter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.ordertest">ultranest.ordertest module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.pathsampler">ultranest.pathsampler module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.plot">ultranest.plot module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.samplingpath">ultranest.samplingpath module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.solvecompat">ultranest.solvecompat module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.stepsampler">ultranest.stepsampler module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.store">ultranest.store module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.utils">ultranest.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest.viz">ultranest.viz module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ultranest">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Release Notes</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example-sine-line.html">Time series fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-sine-modelcomparison.html">Model comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-sine-highd.html">Higher-dimensional fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-intrinsic-distribution.html">Tutorial: intrinsic distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-line.html">Tutorial: fitting a line</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-outliers.html">Tutorial: distribution with outliers</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-sine-bayesian-workflow.html">Bayesian workflow</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">UltraNest</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">API</a> &raquo;</li>
        
      <li>ultranest package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="ultranest-package">
<h1>ultranest package<a class="headerlink" href="#ultranest-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-ultranest.dychmc">
<span id="ultranest-dychmc-module"></span><h2>ultranest.dychmc module<a class="headerlink" href="#module-ultranest.dychmc" title="Permalink to this headline">¶</a></h2>
<p>Constrained Hamiltanean Monte Carlo step sampling.</p>
<p>Uses gradient to reflect at nested sampling boundaries.</p>
<dl class="py function">
<dt id="ultranest.dychmc.stop_criterion">
<code class="sig-prename descclassname">ultranest.dychmc.</code><code class="sig-name descname">stop_criterion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">thetaminus</span></em>, <em class="sig-param"><span class="n">thetaplus</span></em>, <em class="sig-param"><span class="n">rminus</span></em>, <em class="sig-param"><span class="n">rplus</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#stop_criterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.stop_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the stop condition in the main loop
dot(dtheta, rminus) &gt;= 0 &amp; dot(dtheta, rplus &gt;= 0)</p>
<dl class="simple">
<dt>thetaminus, thetaplus: ndarray[float, ndim=1]</dt><dd><p>under and above position</p>
</dd>
<dt>rminus, rplus: ndarray[float, ndim=1]</dt><dd><p>under and above momentum</p>
</dd>
</dl>
<dl class="simple">
<dt>criterion: bool</dt><dd><p>return if the condition is valid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dychmc.step_or_reflect">
<code class="sig-prename descclassname">ultranest.dychmc.</code><code class="sig-name descname">step_or_reflect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">gradient</span></em>, <em class="sig-param"><span class="n">Lmin</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#step_or_reflect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.step_or_reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a step from theta towards v with stepsize epsilon.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dychmc.build_tree">
<code class="sig-prename descclassname">ultranest.dychmc.</code><code class="sig-name descname">build_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">gradient</span></em>, <em class="sig-param"><span class="n">Lmin</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#build_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.build_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>The main recursion.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dychmc.tree_sample">
<code class="sig-prename descclassname">ultranest.dychmc.</code><code class="sig-name descname">tree_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">logL</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">gradient</span></em>, <em class="sig-param"><span class="n">Lmin</span></em>, <em class="sig-param"><span class="n">maxheight</span><span class="o">=</span><span class="default_value">inf</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#tree_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.tree_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Build NUTS-like tree of sampling path from theta towards p with stepsize epsilon.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dychmc.generate_uniform_direction">
<code class="sig-prename descclassname">ultranest.dychmc.</code><code class="sig-name descname">generate_uniform_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">massmatrix</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#generate_uniform_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.generate_uniform_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>draw unit direction vector according to mass matrix</p>
</dd></dl>

<dl class="py class">
<dt id="ultranest.dychmc.DynamicCHMCSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.dychmc.</code><code class="sig-name descname">DynamicCHMCSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ndim</span></em>, <em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">gradient</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">0.9</span></em>, <em class="sig-param"><span class="n">nudge</span><span class="o">=</span><span class="default_value">1.04</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#DynamicCHMCSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.DynamicCHMCSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Dynamic Constrained Hamiltonian/Hybrid Monte Carlo technique</p>
<p>Run a billiard ball inside the likelihood constrained.
The ball reflects off the constraint.</p>
<p>The trajectory is explored in steps of stepsize epsilon.
A No-U-turn criterion and randomized doubling of forward or backward
steps is used to avoid repeating circular trajectories.
Because of this, the number of steps is dynamic.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – if not false, allow earlier termination than nsteps.
The ‘proposal-distance’ strategy stops when the sum of
all proposed vectors exceeds the mean distance
between pairs of live points.
As distance, the Mahalanobis distance is used.
The ‘move-distance’ strategy stops when the distance between
start point and current position exceeds the mean distance
between pairs of live points.</p></li>
<li><p><strong>transform</strong> (<em>function</em>) – called with unit cube position vector u, returns
transformed parameter vector p.</p></li>
<li><p><strong>loglike</strong> (<em>function</em>) – called with transformed parameters p, returns loglikelihood</p></li>
<li><p><strong>gradient</strong> (<em>function</em>) – called with unit cube position vector u, returns
gradient (dlogL/du, not just dlogL/dp)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.dychmc.DynamicCHMCSampler.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#DynamicCHMCSampler.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.DynamicCHMCSampler.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sampler statistics.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dychmc.DynamicCHMCSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">pi</span></em>, <em class="sig-param"><span class="n">Li</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">Lmin</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#DynamicCHMCSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.DynamicCHMCSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move from position ui, Li, gradi with a HMC trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>unew</strong> (<em>vector</em>) – new position in cube space</p></li>
<li><p><strong>pnew</strong> (<em>vector</em>) – new position in physical parameter space</p></li>
<li><p><strong>Lnew</strong> (<em>float</em>) – new likelihood</p></li>
<li><p><strong>nc</strong> (<em>int</em>) – number of likelihood evaluations</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – acceptance rate of trajectory</p></li>
<li><p><strong>treeheight</strong> (<em>int</em>) – height of NUTS tree</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dychmc.DynamicCHMCSampler.create_problem">
<code class="sig-name descname">create_problem</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ls</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#DynamicCHMCSampler.create_problem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.DynamicCHMCSampler.create_problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up auxiliary distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Ls</strong> (<em>array of floats</em>) – live point likelihoods</p></li>
<li><p><strong>region</strong> (<em>MLFriends region object</em>) – region.transformLayer is used to obtain mass matrices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dychmc.DynamicCHMCSampler.adjust_stepsize">
<code class="sig-name descname">adjust_stepsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#DynamicCHMCSampler.adjust_stepsize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.DynamicCHMCSampler.adjust_stepsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Store chain statistics and adapt proposal.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dychmc.DynamicCHMCSampler.region_changed">
<code class="sig-name descname">region_changed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ls</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#DynamicCHMCSampler.region_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.DynamicCHMCSampler.region_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>React to change of region.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dychmc.DynamicCHMCSampler.adjust_nsteps">
<code class="sig-name descname">adjust_nsteps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">history</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dychmc.html#DynamicCHMCSampler.adjust_nsteps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dychmc.DynamicCHMCSampler.adjust_nsteps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.dyhmc">
<span id="ultranest-dyhmc-module"></span><h2>ultranest.dyhmc module<a class="headerlink" href="#module-ultranest.dyhmc" title="Permalink to this headline">¶</a></h2>
<p>Experimental constrained Hamiltanean Monte Carlo step sampling</p>
<p>Contrary to CHMC, this uses the likelihood gradients throughout the path.
A helper surface is created using the live points.</p>
<dl class="py function">
<dt id="ultranest.dyhmc.stop_criterion">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">stop_criterion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">thetaminus</span></em>, <em class="sig-param"><span class="n">thetaplus</span></em>, <em class="sig-param"><span class="n">rminus</span></em>, <em class="sig-param"><span class="n">rplus</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#stop_criterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.stop_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the stop condition in the main loop
dot(dtheta, rminus) &gt;= 0 &amp; dot(dtheta, rplus &gt;= 0)</p>
<dl class="simple">
<dt>thetaminus, thetaplus: ndarray[float, ndim=1]</dt><dd><p>under and above position</p>
</dd>
<dt>rminus, rplus: ndarray[float, ndim=1]</dt><dd><p>under and above momentum</p>
</dd>
</dl>
<dl class="simple">
<dt>criterion: bool</dt><dd><p>return if the condition is valid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.leapfrog">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">leapfrog</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">grad</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">invmassmatrix</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#leapfrog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.leapfrog" title="Permalink to this definition">¶</a></dt>
<dd><p>Leap frog step from theta with momentum r and stepsize epsilon.
The local gradient grad is updated with function f</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.build_tree">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">build_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">grad</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">invmassmatrix</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">joint0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#build_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.build_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>The main recursion.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.tree_sample">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">tree_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">logp</span></em>, <em class="sig-param"><span class="n">r0</span></em>, <em class="sig-param"><span class="n">grad</span></em>, <em class="sig-param"><span class="n">extra</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">invmassmatrix</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">joint</span></em>, <em class="sig-param"><span class="n">maxheight</span><span class="o">=</span><span class="default_value">inf</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#tree_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.tree_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Build NUTS-like tree of sampling path from theta towards p with stepsize epsilon.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.find_beta_params_static">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">find_beta_params_static</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">u10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#find_beta_params_static"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.find_beta_params_static" title="Permalink to this definition">¶</a></dt>
<dd><p>Define auxiliary distribution following naive intuition.
Make 50% quantile to be at u=0.1, and very flat at high u.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.find_beta_params_dynamic">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">find_beta_params_dynamic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">u10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#find_beta_params_dynamic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.find_beta_params_dynamic" title="Permalink to this definition">¶</a></dt>
<dd><p>Define auxiliary distribution taking into account
kinetic energy of a d-dimensional HMC.
Make exp(-d/2) quantile to be at u=0.1, and 95% quantile at u=0.5.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.generate_momentum_normal">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">generate_momentum_normal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">massmatrix</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#generate_momentum_normal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.generate_momentum_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>draw direction vector according to mass matrix</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.generate_momentum">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">generate_momentum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">massmatrix</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">beta</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#generate_momentum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.generate_momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>draw momentum from a circle, with amplitude following the beta distribution</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.generate_momentum_circle">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">generate_momentum_circle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">massmatrix</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#generate_momentum_circle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.generate_momentum_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>draw from a circle, with a little noise in amplitude</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.dyhmc.generate_momentum_flattened">
<code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">generate_momentum_flattened</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">massmatrix</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#generate_momentum_flattened"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.generate_momentum_flattened" title="Permalink to this definition">¶</a></dt>
<dd><p>like normal distribution, but make momenta distributed like a single gaussian.
<strong>this is the one being used</strong></p>
</dd></dl>

<dl class="py class">
<dt id="ultranest.dyhmc.FlattenedProblem">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">FlattenedProblem</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">Ls</span></em>, <em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">layer</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#FlattenedProblem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.FlattenedProblem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Creates a suitable auxiliary distribution from samples of likelihood values</p>
<p>The distribution is the CDF of a beta distribution, with
0 -&gt; logLmin
1 -&gt; 90% quantile of logLs
0.5 -&gt; 10% quantile of logLs</p>
<p>.modify_Lgrad() returns the conversion from logL, grad to the
equivalents on the auxiliary distribution.</p>
<p>.__call__(x) returns logL, grad on the auxiliary distribution.</p>
<dl class="py method">
<dt id="ultranest.dyhmc.FlattenedProblem.modify_Lgrad">
<code class="sig-name descname">modify_Lgrad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span></em>, <em class="sig-param"><span class="n">grad</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#FlattenedProblem.modify_Lgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.FlattenedProblem.modify_Lgrad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.dyhmc.FlattenedProblem.generate_momentum">
<code class="sig-name descname">generate_momentum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#FlattenedProblem.generate_momentum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.FlattenedProblem.generate_momentum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.dyhmc.DynamicHMCSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.dyhmc.</code><code class="sig-name descname">DynamicHMCSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ndim</span></em>, <em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">transform_loglike_gradient</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">0.9</span></em>, <em class="sig-param"><span class="n">nudge</span><span class="o">=</span><span class="default_value">1.04</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#DynamicHMCSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.DynamicHMCSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Dynamic Hamiltonian/Hybrid Monte Carlo technique</p>
<p>Typically, HMC operates on the posterior. It has the benefit
of producing “orbit” trajectories, that can follow the guidance
of gradients.</p>
<p>In nested sampling, we need to sample the prior subject to the
likelihood constraint. This means a HMC would most of the time
go in straight lines, until it steps outside the boundary.
Techniques such as Constrained HMC and Galilean MC use the
gradient outside to select the reflection direction.</p>
<p>However, it would be beneficial to be repelled by the likelihood
boundary, and to take advantage of gradient guidance.
This implements a new technique that does this.</p>
<p>The trick is to define a auxiliary distribution from the likelihood,
generate HMC trajectories from it, and draw points from the
trajectory with inverse the probability of the auxiliary distribution
to sample from the prior. Thus, the auxiliary distribution should be
mostly flat, and go to zero at the boundaries to repell the HMC.</p>
<p>Given Lmin and Lmax from the live points,
use a beta approximation of log-likelihood</p>
<p>p=1 if L&gt;Lmin
u = (L - Lmin) / (Lmax - Lmin)
p = Beta_PDF(u; alpha, beta)</p>
<dl class="simple">
<dt>then define</dt><dd><p>d log(p) / dx = dlog(p_orig)/dlog(p) * dlog(p_orig) / dx
new gradient  = conversion           * original gradient</p>
</dd>
<dt>with conversion</dt><dd><p>dlogp/du = 0 if u&gt;1; otherwise:
dlogp/du =  u**(1-alpha) * (1-u)**(1-beta) / Ic(u; alpha, beta) / Beta_PDF(u, alpha, beta)
du/dL = 1 / (Lmax - Lmin)</p>
</dd>
</dl>
<p>The beta distribution achieves:
* a flattening of the loglikelihood to avoid seeing only “walls”
* using the gradient to identify how to orbit the likelihood contour
* at higher, unseen likelihoods, the exploration is in straight lines
* trajectory do not have the energy to go below Lmin.
* alpha and beta parameters allow flexible choice of “contour avoidance”</p>
<p>Run HMC trajectory on p
This will draw samples proportional to p
Modify multinomial acceptance by 1/p to get uniform samples.
and  reject porig &lt; p_1</p>
<p>The remaining choices for HMC are how long the trajectories should
run (number of steps) and the step size. The former is solved
by No-U-Turn Sampler or dynamic HMC, which randomly build
forward and backward paths until the trajectory turns around.
Then, a random point from the trajectory is chosen.</p>
<p>The step size is chosen by targeting an acceptance rate of
delta~0.95, and decreasing(increasing) every time the region is
rebuilt if the acceptance rate is below(above).</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>transform_loglike_gradient</strong> (<em>function</em>) – called with unit cube position vector u, returns
transformed parameter vector p,
loglikelihood and gradient (dlogL/du, not just dlogL/dp)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.dyhmc.DynamicHMCSampler.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#DynamicHMCSampler.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.DynamicHMCSampler.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sampler statistics.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dyhmc.DynamicHMCSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">pi</span></em>, <em class="sig-param"><span class="n">Li</span></em>, <em class="sig-param"><span class="n">gradi</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">Lflat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">gradflat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#DynamicHMCSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.DynamicHMCSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move from position ui, Li, gradi with a HMC trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>unew</strong> (<em>vector</em>) – new position in cube space</p></li>
<li><p><strong>pnew</strong> (<em>vector</em>) – new position in physical parameter space</p></li>
<li><p><strong>Lnew</strong> (<em>float</em>) – new likelihood</p></li>
<li><p><strong>gradnew</strong> (<em>vector</em>) – new gradient</p></li>
<li><p><strong>Lflat</strong> (<em>float</em>) – new likelihood on auxiliary distribution</p></li>
<li><p><strong>gradflat</strong> (<em>vector</em>) – new gradient on auxiliary distribution</p></li>
<li><p><strong>nc</strong> (<em>int</em>) – number of likelihood evaluations</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – acceptance rate of HMC trajectory</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – acceptance rate of inverse-beta-biased HMC trajectory</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dyhmc.DynamicHMCSampler.create_problem">
<code class="sig-name descname">create_problem</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ls</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#DynamicHMCSampler.create_problem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.DynamicHMCSampler.create_problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up auxiliary distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Ls</strong> (<em>array of floats</em>) – live point likelihoods</p></li>
<li><p><strong>region</strong> (<em>MLFriends region object</em>) – region.transformLayer is used to obtain mass matrices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.dyhmc.DynamicHMCSampler.adjust_stepsize">
<code class="sig-name descname">adjust_stepsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#DynamicHMCSampler.adjust_stepsize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.DynamicHMCSampler.adjust_stepsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.dyhmc.DynamicHMCSampler.region_changed">
<code class="sig-name descname">region_changed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ls</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/dyhmc.html#DynamicHMCSampler.region_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.dyhmc.DynamicHMCSampler.region_changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.flatnuts">
<span id="ultranest-flatnuts-module"></span><h2>ultranest.flatnuts module<a class="headerlink" href="#module-ultranest.flatnuts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="flatnuts">
<h3>FLATNUTS<a class="headerlink" href="#flatnuts" title="Permalink to this headline">¶</a></h3>
<p>Experimental.</p>
<p>Directional sampling within regions.</p>
<p>Work in unit cube space. assume a step size.</p>
<ol class="arabic simple">
<li><p>starting from a live point</p></li>
<li><p>choose a random direction based on whitened space metric</p></li>
<li><p>for forward and backward direction:</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>find distance where leaving spheres (surely outside)</p></li>
<li><p>bisect the step that leads out of the likelihood threshold</p></li>
<li><p>can we scatter forward?</p>
<ul class="simple">
<li><p>if we stepped outside the unit cube, use normal to the parameter(s) we stepped out from</p></li>
<li><p>if gradient available, use it at first outside point</p></li>
<li><p>for each sphere that contains the last inside point:</p>
<ul>
<li><p>resize so that first outside point is on the surface, get tangential vector there
(this vector is just the difference between sphere center and last inside point)</p></li>
<li><p>compute reflection of direction vector with tangential plane</p></li>
</ul>
</li>
<li><p>choose a forward reflection at random (if any)</p></li>
</ul>
</li>
</ol>
<p>3.4) test if next point is inside again. If yes, continue NUTS</p>
</div></blockquote>
<dl class="simple">
<dt>NUTS:</dt><dd><ul class="simple">
<li><p>alternatingly double the number of steps to the forward or backward side</p></li>
<li><p>build a tree; terminate when start and end directions are not forward any more</p></li>
<li><p>choose a end point at random out of the sequence</p></li>
</ul>
</dd>
</dl>
<p>If the number of steps on any straight line is &lt;10 steps, make step size smaller
If the number of steps on any straight line is &gt;100 steps, make step size slightly bigger</p>
<dl class="field-list simple">
<dt class="field-odd">param - Number of NUTS tracks</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">type - Number of NUTS tracks</dt>
<dd class="field-even"><p>has to be user-tuned to ensure sufficiently independent samples; starting from 1, look when Z does not change anymore</p>
</dd>
<dt class="field-odd">param - Step size</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">type - Step size</dt>
<dd class="field-even"><p>self-adjusting</p>
</dd>
</dl>
<dl class="simple">
<dt>Benefit of this algorithm:</dt><dd><ul class="simple">
<li><p>insensitive to step size</p></li>
<li><p>insensitive to dimensionality (sqrt scaling), better than slice sampling</p></li>
<li><p>takes advantage of region information, can accelerate low-d problems as well</p></li>
</ul>
</dd>
<dt>Drawbacks:</dt><dd><ul class="simple">
<li><p>inaccurate reflections degrade dimensionality scaling</p></li>
<li><p>more complex to implement than slice sampling</p></li>
</ul>
</dd>
</dl>
<dl class="py class">
<dt id="ultranest.flatnuts.SingleJumper">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.flatnuts.</code><code class="sig-name descname">SingleJumper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stepsampler</span></em>, <em class="sig-param"><span class="n">nsteps</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#SingleJumper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.SingleJumper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Jump on step at a time. If unsuccessful, reverse direction.</p>
<dl class="py method">
<dt id="ultranest.flatnuts.SingleJumper.prepare_jump">
<code class="sig-name descname">prepare_jump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#SingleJumper.prepare_jump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.SingleJumper.prepare_jump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.SingleJumper.check_gaps">
<code class="sig-name descname">check_gaps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gaps</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#SingleJumper.check_gaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.SingleJumper.check_gaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.SingleJumper.make_jump">
<code class="sig-name descname">make_jump</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gaps</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#SingleJumper.make_jump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.SingleJumper.make_jump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.flatnuts.DirectJumper">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.flatnuts.</code><code class="sig-name descname">DirectJumper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stepsampler</span></em>, <em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#DirectJumper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.DirectJumper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Jump to n steps immediately. If unsuccessful, takes rest in other direction.</p>
<dl class="py method">
<dt id="ultranest.flatnuts.DirectJumper.prepare_jump">
<code class="sig-name descname">prepare_jump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#DirectJumper.prepare_jump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.DirectJumper.prepare_jump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.DirectJumper.check_gaps">
<code class="sig-name descname">check_gaps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gaps</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#DirectJumper.check_gaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.DirectJumper.check_gaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.DirectJumper.make_jump">
<code class="sig-name descname">make_jump</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gaps</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#DirectJumper.make_jump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.DirectJumper.make_jump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.flatnuts.IntervalJumper">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.flatnuts.</code><code class="sig-name descname">IntervalJumper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stepsampler</span></em>, <em class="sig-param"><span class="n">nsteps</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#IntervalJumper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.IntervalJumper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Use interval to choose final point randomly</p>
<dl class="py method">
<dt id="ultranest.flatnuts.IntervalJumper.prepare_jump">
<code class="sig-name descname">prepare_jump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#IntervalJumper.prepare_jump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.IntervalJumper.prepare_jump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.IntervalJumper.make_jump">
<code class="sig-name descname">make_jump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#IntervalJumper.make_jump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.IntervalJumper.make_jump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.flatnuts.</code><code class="sig-name descname">ClockedSimpleStepSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">contourpath</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Find a new point with a series of small steps</p>
<p>Starts a sampling track from x in direction v.
is_inside is a function that returns true when a given point is inside the volume</p>
<p>epsilon gives the step size in direction v.
samples, if given, helps choose the gradient – To be removed
plot: if set to true, make some debug plots</p>
<dl class="py method">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler.reverse">
<code class="sig-name descname">reverse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reflpoint</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler.reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect off the surface at reflpoint going in direction v</p>
<p>returns the new direction.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler.set_nsteps">
<code class="sig-name descname">set_nsteps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler.set_nsteps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler.set_nsteps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler.is_done">
<code class="sig-name descname">is_done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler.is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler.is_done" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler.expand_onestep">
<code class="sig-name descname">expand_onestep</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fwd</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">Lmin</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler.expand_onestep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler.expand_onestep" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper interface, make one step (forward fwd=True or backward fwd=False)</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler.expand_to_step">
<code class="sig-name descname">expand_to_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">Lmin</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler.expand_to_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler.expand_to_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper interface, go to step nstep</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedSimpleStepSampler.get_independent_sample">
<code class="sig-name descname">get_independent_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">Lmin</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedSimpleStepSampler.get_independent_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedSimpleStepSampler.get_independent_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper interface, call next() until a independent sample is returned</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.flatnuts.ClockedStepSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.flatnuts.</code><code class="sig-name descname">ClockedStepSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">contourpath</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedStepSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedStepSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.flatnuts.ClockedSimpleStepSampler" title="ultranest.flatnuts.ClockedSimpleStepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.flatnuts.ClockedSimpleStepSampler</span></code></a></p>
<p>Find a new point with a series of small steps</p>
<p>Starts a sampling track from x in direction v.
is_inside is a function that returns true when a given point is inside the volume</p>
<p>epsilon gives the step size in direction v.
samples, if given, helps choose the gradient – To be removed
plot: if set to true, make some debug plots</p>
<dl class="py method">
<dt id="ultranest.flatnuts.ClockedStepSampler.continue_sampling">
<code class="sig-name descname">continue_sampling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedStepSampler.continue_sampling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedStepSampler.continue_sampling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedStepSampler.expand_to">
<code class="sig-name descname">expand_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedStepSampler.expand_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedStepSampler.expand_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedStepSampler.eval_at">
<code class="sig-name descname">eval_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">xj</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">sign</span></em>, <em class="sig-param"><span class="n">Llast</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedStepSampler.eval_at"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedStepSampler.eval_at" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedStepSampler.reflect_at">
<code class="sig-name descname">reflect_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">xk</span></em>, <em class="sig-param"><span class="n">vk</span></em>, <em class="sig-param"><span class="n">sign</span></em>, <em class="sig-param"><span class="n">Llast</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedStepSampler.reflect_at"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedStepSampler.reflect_at" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedStepSampler.next">
<code class="sig-name descname">next</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Llast</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedStepSampler.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedStepSampler.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Run steps forward or backward to step i (can be positive or
negative, 0 is the starting point)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.flatnuts.ClockedBisectSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.flatnuts.</code><code class="sig-name descname">ClockedBisectSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">contourpath</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedBisectSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedBisectSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.flatnuts.ClockedStepSampler" title="ultranest.flatnuts.ClockedStepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.flatnuts.ClockedStepSampler</span></code></a></p>
<p>Step sampler that does not require each step to be evaluated</p>
<p>Starts a sampling track from x in direction v.
is_inside is a function that returns true when a given point is inside the volume</p>
<p>epsilon gives the step size in direction v.
samples, if given, helps choose the gradient – To be removed
plot: if set to true, make some debug plots</p>
<dl class="py method">
<dt id="ultranest.flatnuts.ClockedBisectSampler.continue_sampling">
<code class="sig-name descname">continue_sampling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedBisectSampler.continue_sampling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedBisectSampler.continue_sampling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedBisectSampler.expand_to">
<code class="sig-name descname">expand_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">j</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedBisectSampler.expand_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedBisectSampler.expand_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedBisectSampler.bisect_at">
<code class="sig-name descname">bisect_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lefti</span></em>, <em class="sig-param"><span class="n">leftx</span></em>, <em class="sig-param"><span class="n">leftv</span></em>, <em class="sig-param"><span class="n">midi</span></em>, <em class="sig-param"><span class="n">midx</span></em>, <em class="sig-param"><span class="n">midv</span></em>, <em class="sig-param"><span class="n">righti</span></em>, <em class="sig-param"><span class="n">rightx</span></em>, <em class="sig-param"><span class="n">rightv</span></em>, <em class="sig-param"><span class="n">sign</span></em>, <em class="sig-param"><span class="n">Llast</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedBisectSampler.bisect_at"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedBisectSampler.bisect_at" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedBisectSampler.next">
<code class="sig-name descname">next</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Llast</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedBisectSampler.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedBisectSampler.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Run steps forward or backward to step i (can be positive or
negative, 0 is the starting point)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.flatnuts.ClockedNUTSSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.flatnuts.</code><code class="sig-name descname">ClockedNUTSSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">contourpath</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedNUTSSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedNUTSSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.flatnuts.ClockedBisectSampler" title="ultranest.flatnuts.ClockedBisectSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.flatnuts.ClockedBisectSampler</span></code></a></p>
<p>No-U-turn sampler (NUTS) on flat surfaces.</p>
<p>Starts a sampling track from x in direction v.
is_inside is a function that returns true when a given point is inside the volume</p>
<p>epsilon gives the step size in direction v.
samples, if given, helps choose the gradient – To be removed
plot: if set to true, make some debug plots</p>
<dl class="py method">
<dt id="ultranest.flatnuts.ClockedNUTSSampler.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedNUTSSampler.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedNUTSSampler.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedNUTSSampler.next">
<code class="sig-name descname">next</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Llast</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedNUTSSampler.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedNUTSSampler.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternatingly doubles the number of steps to forward and backward
direction (which may include reflections, see StepSampler and
BisectSampler).
When track returns (start and end of tree point toward each other),
terminates and returns a random point on that track.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedNUTSSampler.sample_chain_point">
<code class="sig-name descname">sample_chain_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedNUTSSampler.sample_chain_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedNUTSSampler.sample_chain_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a point on the track between a and b (inclusive)
returns tuple ((point coordinates, likelihood), is_independent)</p>
<blockquote>
<div><p>where is_independent is always True</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="ultranest.flatnuts.ClockedNUTSSampler.build_tree">
<code class="sig-name descname">build_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">startstate</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">rwd</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/flatnuts.html#ClockedNUTSSampler.build_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.flatnuts.ClockedNUTSSampler.build_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Build sub-trees of depth j in direction rwd</p>
<p>startstate: (i, x, v) state information of first node
j: int height of the tree
rwd: bool whether we go backward</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-ultranest.integrator">
<span id="ultranest-integrator-module"></span><h2>ultranest.integrator module<a class="headerlink" href="#module-ultranest.integrator" title="Permalink to this headline">¶</a></h2>
<p>Ultranest calculates the Bayesian evidence and posterior samples of arbitrary models.</p>
<dl class="py class">
<dt id="ultranest.integrator.ReactiveNestedSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.integrator.</code><code class="sig-name descname">ReactiveNestedSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param_names</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">derived_param_names</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">wrapped_params</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">resume</span><span class="o">=</span><span class="default_value">'subfolder'</span></em>, <em class="sig-param"><span class="n">run_num</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_test_samples</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">draw_multiple</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">num_bootstraps</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">vectorized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ndraw_min</span><span class="o">=</span><span class="default_value">128</span></em>, <em class="sig-param"><span class="n">ndraw_max</span><span class="o">=</span><span class="default_value">65536</span></em>, <em class="sig-param"><span class="n">storage_backend</span><span class="o">=</span><span class="default_value">'hdf5'</span></em>, <em class="sig-param"><span class="n">warmstart_max_tau</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Nested sampler with reactive exploration strategy.</p>
<p>Storage &amp; resume capable, optionally MPI parallelised.</p>
<p>Initialise nested sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_names</strong> (<em>list of str</em><em>, </em><em>names of the parameters.</em>) – Length gives dimensionality of the sampling problem.</p></li>
<li><p><strong>loglike</strong> (<em>function</em>) – log-likelihood function.
Receives multiple parameter vectors, returns vector of likelihood.</p></li>
<li><p><strong>transform</strong> (<em>function</em>) – parameter transform from unit cube to physical parameters.
Receives multiple cube vectors, returns multiple parameter vectors.</p></li>
<li><p><strong>derived_param_names</strong> (<em>list of str</em>) – Additional derived parameters created by transform. (empty by default)</p></li>
<li><p><strong>log_dir</strong> (<em>str</em>) – where to store output files</p></li>
<li><p><strong>resume</strong> (<em>'resume'</em><em>, </em><em>'resume-similar'</em><em>, </em><em>'overwrite'</em><em> or </em><em>'subfolder'</em>) – <p>if ‘overwrite’, overwrite previous data.</p>
<p>if ‘subfolder’, create a fresh subdirectory in log_dir.</p>
<p>if ‘resume’ or True, continue previous run if available.
Only works when dimensionality, transform or likelihood are consistent.</p>
<p>if ‘resume-similar’, continue previous run if available.
Only works when dimensionality and transform are consistent.
If a likelihood difference is detected, the existing likelihoods
are updated until the live point order differs.
Otherwise, behaves like resume.</p>
</p></li>
<li><p><strong>wrapped_params</strong> (<em>list of bools</em>) – indicating whether this parameter wraps around (circular parameter).</p></li>
<li><p><strong>num_test_samples</strong> (<em>int</em>) – test transform and likelihood with this number of
random points for errors first. Useful to catch bugs.</p></li>
<li><p><strong>vectorized</strong> (<em>bool</em>) – If true, loglike and transform function can receive arrays
of points.</p></li>
<li><p><strong>draw_multiple</strong> (<em>bool</em>) – If efficiency goes down, dynamically draw more points
from the region between <cite>ndraw_min</cite> and <cite>ndraw_max</cite>.
If set to False, few points are sampled at once.</p></li>
<li><p><strong>ndraw_min</strong> (<em>int</em>) – Minimum number of points to simultaneously propose.
Increase this if your likelihood makes vectorization very cheap.</p></li>
<li><p><strong>ndraw_max</strong> (<em>int</em>) – Maximum number of points to simultaneously propose.
Increase this if your likelihood makes vectorization very cheap.
Memory allocation may be slow for extremely high values.</p></li>
<li><p><strong>num_bootstraps</strong> (<em>int</em>) – number of logZ estimators and MLFriends region
bootstrap rounds.</p></li>
<li><p><strong>storage_backend</strong> (<em>str</em><em> or </em><em>class</em>) – Class to use for storing the evaluated points (see ultranest.store)
‘hdf5’ is strongly recommended. ‘tsv’ and ‘csv’ are also possible.</p></li>
<li><p><strong>warmstart_max_tau</strong> (<em>float</em>) – Maximum disorder to accept when resume=’resume-similar’;
Live points are reused as long as the live point order
is below this normalised Kendall tau distance.
Values from 0 (highly conservative) to 1 (extremely negligent).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">update_interval_volume_fraction</span><span class="o">=</span><span class="default_value">0.8</span></em>, <em class="sig-param"><span class="n">update_interval_ncall</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_interval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">show_status</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">viz_callback</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">dlogz</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">dKL</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">frac_remain</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">Lepsilon</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">min_ess</span><span class="o">=</span><span class="default_value">400</span></em>, <em class="sig-param"><span class="n">max_iters</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_ncalls</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_num_improvement_loops</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">min_num_live_points</span><span class="o">=</span><span class="default_value">400</span></em>, <em class="sig-param"><span class="n">cluster_num_live_points</span><span class="o">=</span><span class="default_value">40</span></em>, <em class="sig-param"><span class="n">insertion_test_window</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">insertion_test_zscore_threshold</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run until target convergence criteria are fulfilled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>update_interval_volume_fraction</strong> (<em>float</em>) – Update region when the volume shrunk by this amount.</p></li>
<li><p><strong>update_interval_ncall</strong> (<em>int</em>) – Update region after update_interval_ncall likelihood calls (not used).</p></li>
<li><p><strong>log_interval</strong> (<em>int</em>) – Update stdout status line every log_interval iterations</p></li>
<li><p><strong>show_status</strong> (<em>bool</em>) – show integration progress as a status line.
If no output desired, set to False.</p></li>
<li><p><strong>viz_callback</strong> (<em>function</em>) – callback function when region was rebuilt. Allows to
show current state of the live points.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">nicelogger()</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">LivePointsWidget</span></code>.
If no output desired, set to False.</p></li>
<li><p><strong>dlogz</strong> (<em>float</em>) – Target evidence uncertainty. This is the std
between bootstrapped logz integrators.</p></li>
<li><p><strong>dKL</strong> (<em>float</em>) – Target posterior uncertainty. This is the
Kullback-Leibler divergence in nat between bootstrapped integrators.</p></li>
<li><p><strong>frac_remain</strong> (<em>float</em>) – Integrate until this fraction of the integral is left in the remainder.
Set to a low number (1e-2 … 1e-5) to make sure peaks are discovered.
Set to a higher number (0.5) if you know the posterior is simple.</p></li>
<li><p><strong>Lepsilon</strong> (<em>float</em>) – Terminate when live point likelihoods are all the same,
within Lepsilon tolerance. Increase this when your likelihood
function is inaccurate, to avoid unnecessary search.</p></li>
<li><p><strong>min_ess</strong> (<em>int</em>) – Target number of effective posterior samples.</p></li>
<li><p><strong>max_iters</strong> (<em>int</em>) – maximum number of integration iterations.</p></li>
<li><p><strong>max_ncalls</strong> (<em>int</em>) – stop after this many likelihood evaluations.</p></li>
<li><p><strong>max_num_improvement_loops</strong> (<em>int</em>) – run() tries to assess iteratively where more samples are needed.
This number limits the number of improvement loops.</p></li>
<li><p><strong>min_num_live_points</strong> (<em>int</em>) – minimum number of live points throughout the run</p></li>
<li><p><strong>cluster_num_live_points</strong> (<em>int</em>) – require at least this many live points per detected cluster</p></li>
<li><p><strong>insertion_test_zscore_threshold</strong> (<em>float</em>) – z-score used as a threshold for the insertion order test.
Set to infinity to disable.</p></li>
<li><p><strong>insertion_test_window</strong> (<em>float</em>) – Number of iterations after which the insertion order test is reset.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.run_iter">
<code class="sig-name descname">run_iter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">update_interval_volume_fraction</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">update_interval_ncall</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_interval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dlogz</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">dKL</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">frac_remain</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">Lepsilon</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">min_ess</span><span class="o">=</span><span class="default_value">400</span></em>, <em class="sig-param"><span class="n">max_iters</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_ncalls</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_num_improvement_loops</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">min_num_live_points</span><span class="o">=</span><span class="default_value">400</span></em>, <em class="sig-param"><span class="n">cluster_num_live_points</span><span class="o">=</span><span class="default_value">40</span></em>, <em class="sig-param"><span class="n">show_status</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">viz_callback</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">insertion_test_window</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">insertion_test_zscore_threshold</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.run_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.run_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate towards convergence.</p>
<p>Use as an iterator like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_iter</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lnZ = </span><span class="si">%(logz).2f</span><span class="s1"> +- </span><span class="si">%(logzerr).2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters as described in run() method.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.store_tree">
<code class="sig-name descname">store_tree</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.store_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.store_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Store tree to disk (results/tree.hdf5).</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.print_results">
<code class="sig-name descname">print_results</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logZ</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">posterior</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.print_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Give summary of marginal likelihood and parameters.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make corner, run and trace plots.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.plot_corner">
<code class="sig-name descname">plot_corner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.plot_corner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.plot_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Make corner plot.</p>
<p>Writes corner plot to plots/ directory if log directory was
specified, otherwise show interactively.</p>
<p>This does essentially:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ultranest.plot</span> <span class="kn">import</span> <span class="n">cornerplot</span>
<span class="n">cornerplot</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.plot_trace">
<code class="sig-name descname">plot_trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.plot_trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.plot_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Make trace plot.</p>
<p>Write parameter trace diagnostic plots to plots/ directory
if log directory specified, otherwise show interactively.</p>
<p>This does essentially:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ultranest.plot</span> <span class="kn">import</span> <span class="n">traceplot</span>
<span class="n">traceplot</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">paramnames</span> <span class="o">+</span> <span class="n">derivedparamnames</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.ReactiveNestedSampler.plot_run">
<code class="sig-name descname">plot_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#ReactiveNestedSampler.plot_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.ReactiveNestedSampler.plot_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Make run plot.</p>
<p>Write run diagnostic plots to plots/ directory
if log directory specified, otherwise show interactively.</p>
<p>This does essentially:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ultranest.plot</span> <span class="kn">import</span> <span class="n">runplot</span>
<span class="n">runplot</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.integrator.NestedSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.integrator.</code><code class="sig-name descname">NestedSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param_names</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">derived_param_names</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">resume</span><span class="o">=</span><span class="default_value">'subfolder'</span></em>, <em class="sig-param"><span class="n">run_num</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_dir</span><span class="o">=</span><span class="default_value">'logs/test'</span></em>, <em class="sig-param"><span class="n">num_live_points</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">vectorized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">wrapped_params</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#NestedSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.NestedSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Simple Nested sampler for reference.</p>
<p>Set up nested sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_names</strong> (<em>list of str</em><em>, </em><em>names of the parameters.</em>) – Length gives dimensionality of the sampling problem.</p></li>
<li><p><strong>loglike</strong> (<em>function</em>) – log-likelihood function.
Receives multiple parameter vectors, returns vector of likelihood.</p></li>
<li><p><strong>transform</strong> (<em>function</em>) – parameter transform from unit cube to physical parameters.
Receives multiple cube vectors, returns multiple parameter vectors.</p></li>
<li><p><strong>derived_param_names</strong> (<em>list of str</em>) – Additional derived parameters created by transform. (empty by default)</p></li>
<li><p><strong>log_dir</strong> (<em>str</em>) – where to store output files</p></li>
<li><p><strong>resume</strong> (<em>'resume'</em><em>, </em><em>'overwrite'</em><em> or </em><em>'subfolder'</em>) – if ‘overwrite’, overwrite previous data.
if ‘subfolder’, create a fresh subdirectory in log_dir.
if ‘resume’ or True, continue previous run if available.</p></li>
<li><p><strong>wrapped_params</strong> (<em>list of bools</em>) – indicating whether this parameter wraps around (circular parameter).</p></li>
<li><p><strong>num_live_points</strong> (<em>int</em>) – Number of live points</p></li>
<li><p><strong>vectorized</strong> (<em>bool</em>) – If true, loglike and transform function can receive arrays
of points.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.integrator.NestedSampler.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">update_interval_iter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">update_interval_ncall</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_interval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dlogz</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">max_iters</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#NestedSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.NestedSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Explore parameter space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>update_interval_iter</strong> – Update region after this many iterations.</p></li>
<li><p><strong>update_interval_ncall</strong> – Update region after update_interval_ncall likelihood calls.</p></li>
<li><p><strong>log_interval</strong> – Update stdout status line every log_interval iterations</p></li>
<li><p><strong>dlogz</strong> – Target evidence uncertainty.</p></li>
<li><p><strong>max_iters</strong> – maximum number of integration iterations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.NestedSampler.print_results">
<code class="sig-name descname">print_results</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logZ</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">posterior</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#NestedSampler.print_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.NestedSampler.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Give summary of marginal likelihood and parameters.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.integrator.NestedSampler.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#NestedSampler.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.NestedSampler.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make corner plot.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="ultranest.integrator.read_file">
<code class="sig-prename descclassname">ultranest.integrator.</code><code class="sig-name descname">read_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">log_dir</span></em>, <em class="sig-param"><span class="n">x_dim</span></em>, <em class="sig-param"><span class="n">num_bootstraps</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">check_insertion_order</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/integrator.html#read_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.integrator.read_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the output HDF5 file of UltraNest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>log_dir</strong> (<em>str</em>) – Folder containing results</p></li>
<li><p><strong>x_dim</strong> (<em>int</em>) – number of dimensions</p></li>
<li><p><strong>num_bootstraps</strong> (<em>int</em>) – number of bootstraps to use for estimating logZ.</p></li>
<li><p><strong>random</strong> (<em>bool</em>) – use randomization for volume estimation.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – show progress</p></li>
<li><p><strong>check_insertion_order</strong> (<em>bool</em>) – whether to perform MWW insertion order test for assessing convergence</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>sequence</strong> (<em>dict</em>) –</p>
<p>contains arrays storing for each iteration estimates of:</p>
<blockquote>
<div><ul class="simple">
<li><p>logz: log evidence estimate</p></li>
<li><p>logzerr: log evidence uncertainty estimate</p></li>
<li><p>logvol: log volume estimate</p></li>
<li><p>samples_n: number of live points</p></li>
<li><p>logwt: log weight</p></li>
<li><p>logl: log likelihood</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>final</strong> (<em>dict</em>) – same as ReactiveNestedSampler.results and
ReactiveNestedSampler.run return values</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ultranest.mlfriends">
<span id="ultranest-mlfriends-module"></span><h2>ultranest.mlfriends module<a class="headerlink" href="#module-ultranest.mlfriends" title="Permalink to this headline">¶</a></h2>
<p>Construct and sample from region.</p>
<p>Implements MLFriends efficiently, with transformation layers and clustering.</p>
<dl class="py class">
<dt id="ultranest.mlfriends.AffineLayer">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">AffineLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ctr</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">T</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">invT</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nclusters</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">wrapped_dims</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.AffineLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#id20" title="ultranest.mlfriends.ScalingLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.mlfriends.ScalingLayer</span></code></a></p>
<p>Affine whitening transformation.</p>
<p>Learns the covariance of points.</p>
<p>Initialise layer.</p>
<p>The parameters are optional and can be learned from points with <a class="reference internal" href="#id3" title="ultranest.mlfriends.AffineLayer.optimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">optimize()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctr</strong> (<em>vector</em>) – Center of points</p></li>
<li><p><strong>T</strong> (<em>matrix</em>) – transformation matrix</p></li>
<li><p><strong>invT</strong> (<em>matrix</em>) – inverse transformation matrix</p></li>
<li><p><strong>nclusters</strong> (<em>int</em>) – number of clusters</p></li>
<li><p><strong>wrapped_dims</strong> (<em>array of bools</em>) – indicates which parameter axes are circular.</p></li>
<li><p><strong>clusterids</strong> (<em>array of int</em>) – cluster id for each point</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.mlfriends.AffineLayer.create_new">
<code class="sig-name descname">create_new</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">upoints</span></em>, <em class="sig-param"><span class="n">maxradiussq</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.AffineLayer.create_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Learn next layer from this optimized layer’s clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upoints</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>maxradiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – Minimum volume to regularize sample covariance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A new, optimized AffineLayer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.AffineLayer.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">centered_points</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.AffineLayer.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize layer.</p>
<p>Estimates covariance of <code class="docutils literal notranslate"><span class="pre">centered_points</span></code>. <code class="docutils literal notranslate"><span class="pre">minvol</span></code> sets the
smallest allowed size of the covariance to avoid numerical
collapse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>centered_points</strong> (<em>array</em>) – points with their cluster center subtracted</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em>) – for each point, which cluster they belong to</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – Minimum volume to regularize sample covariance</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.AffineLayer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.AffineLayer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from cube space to a whitened space.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.AffineLayer.untransform">
<code class="sig-name descname">untransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ww</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.AffineLayer.untransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from whitened space back to cube space.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.mlfriends.MLFriends">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">MLFriends</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">transformLayer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>MLFriends region.</p>
<p>Defines a region around nested sampling live points for</p>
<ol class="arabic simple">
<li><p>checking whether a proposed point likely also fulfills the
likelihood constraints</p></li>
<li><p>proposing new points.</p></li>
</ol>
<p>Learns geometry of region from existing live points.</p>
<p>Initialise region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>array of vectors</em>) – live points</p></li>
<li><p><strong>transformLayer</strong> (<a class="reference internal" href="#id20" title="ultranest.mlfriends.ScalingLayer"><em>ScalingLayer</em></a><em> or </em><a class="reference internal" href="#id0" title="ultranest.mlfriends.AffineLayer"><em>AffineLayer</em></a>) – whitening layer</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.compute_enlargement">
<code class="sig-name descname">compute_enlargement</code><span class="sig-paren">(</span><em class="sig-param">nbootstraps=50</em>, <em class="sig-param">minvol=0.0</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/user/.local/lib/python3.8/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.compute_enlargement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return MLFriends radius and ellipsoid enlargement using bootstrapping.</p>
<p>The wrapping ellipsoid covariance is determined in each bootstrap round.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbootstraps</strong> (<em>int</em>) – number of bootstrapping rounds</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – minimum volume to enforce to wrapping ellipsoid</p></li>
<li><p><strong>rng</strong> – random number generator</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>max_distance</strong> (<em>float</em>) – square radius of MLFriends algorithm</p></li>
<li><p><strong>max_radius</strong> (<em>float</em>) – square radius of enclosing ellipsoid.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.compute_maxradiussq">
<code class="sig-name descname">compute_maxradiussq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nbootstraps</span><span class="o">=</span><span class="default_value">50</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.compute_maxradiussq" title="Permalink to this definition">¶</a></dt>
<dd><p>Run MLFriends bootstrapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nbootstraps</strong> (<em>int</em>) – number of bootstrapping rounds</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>square radius that safely encloses all live points.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.compute_mean_pair_distance">
<code class="sig-name descname">compute_mean_pair_distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.compute_mean_pair_distance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.create_ellipsoid">
<code class="sig-name descname">create_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.create_ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create wrapping ellipsoid and store its center and covariance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>minvol</strong> (<em>float</em>) – If positive, make sure ellipsoid has at least this volume.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.estimate_volume">
<code class="sig-name descname">estimate_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.estimate_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the order of magnitude of the volume around a single point
given the current transformLayer and</p>
<p>Does not account for:
* the number of live points
* their overlap
* the intersection with the unit cube borders</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>volume (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.inside">
<code class="sig-name descname">inside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if inside region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pts</strong> (<em>array of vectors</em>) – Points to check</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_inside</strong> – True if inside MLFriends region and wrapping ellipsoid,
for each point in <code class="docutils literal notranslate"><span class="pre">pts</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of bools</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.inside_ellipsoid">
<code class="sig-name descname">inside_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.inside_ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if inside wrapping ellipsoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>array of vectors</em>) – Points to check</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_inside</strong> – True if inside wrapping ellipsoid, for each point in <cite>pts</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of bools</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Switches automatically between the <code class="docutils literal notranslate"><span class="pre">sampling_methods</span></code> (attribute).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nsamples</strong> (<em>int</em>) – number of samples to draw</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>samples</strong> (<em>array of shape (nsamples, dimension)</em>) – samples drawn</p></li>
<li><p><strong>idx</strong> (<em>array of integers (nsamples)</em>) – index of a point nearby (MLFriends.u)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.sample_from_boundingbox">
<code class="sig-name descname">sample_from_boundingbox</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.sample_from_boundingbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Draws uniformly from bounding box around region.</p>
<p>Parameters as described in <em>sample()</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.sample_from_points">
<code class="sig-name descname">sample_from_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.sample_from_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Chooses randomly from points and their ellipsoids.</p>
<p>Parameters as described in <em>sample()</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.sample_from_transformed_boundingbox">
<code class="sig-name descname">sample_from_transformed_boundingbox</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.sample_from_transformed_boundingbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Draws uniformly from bounding box around region (in whitened space).</p>
<p>Parameters as described in <em>sample()</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.sample_from_wrapping_ellipsoid">
<code class="sig-name descname">sample_from_wrapping_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.sample_from_wrapping_ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Draws uniformly from wrapping ellipsoid and filters with region.</p>
<p>Parameters as described in <code class="docutils literal notranslate"><span class="pre">sample()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.MLFriends.set_transformLayer">
<code class="sig-name descname">set_transformLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transformLayer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.MLFriends.set_transformLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Update transformation layer. Invalidates attribute <cite>maxradius</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transformLayer</strong> (<a class="reference internal" href="#id20" title="ultranest.mlfriends.ScalingLayer"><em>ScalingLayer</em></a><em> or </em><a class="reference internal" href="#id0" title="ultranest.mlfriends.AffineLayer"><em>AffineLayer</em></a>) – t-space transformation layer</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.mlfriends.ScalingLayer">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">ScalingLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mean</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">std</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nclusters</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">wrapped_dims</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Simple transformation layer that only shifts and scales each axis.</p>
<p>Initialise layer.</p>
<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.create_new">
<code class="sig-name descname">create_new</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">upoints</span></em>, <em class="sig-param"><span class="n">maxradiussq</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.create_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Learn next layer from this optimized layer’s clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upoints</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>maxradiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – Minimum volume to regularize sample covariance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A new, optimized ScalingLayer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">centered_points</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize layer.</p>
<p>Estimates mean and std of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>centered_points</strong> (<em>array</em>) – points with their cluster center subtracted</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em>) – for each point, which cluster they belong to</p></li>
<li><p><strong>minvol</strong> – ignored</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.optimize_wrap">
<code class="sig-name descname">optimize_wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.optimize_wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimization for wrapped/circular parameters.
Does nothing if there are no wrapped/circular parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array</em>) – points to use for optimization (in u-space)</p></li>
<li><p><strong>largest gap in live points and wrap parameter space there.</strong> (<em>Find</em>) – </p></li>
<li><p><strong>example</strong> (<em>For</em>) – <a href="#id39"><span class="problematic" id="id40">|*****           ****|</span></a></p></li>
<li><p><strong>a wrapped axis has::</strong> (<em>if</em>) – <a href="#id41"><span class="problematic" id="id42">|*****           ****|</span></a></p></li>
<li><p><strong>would identify the middle</strong> (<em>it</em>) – </p></li>
<li><p><strong>it</strong> (<em>subtract</em>) – </p></li>
<li><p><strong>that the new space</strong> (<em>so</em>) – </p></li>
<li><p><strong>is::</strong> – <div class="line-block">
<div class="line"><strong>****</strong>      |</div>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.set_clusterids">
<code class="sig-name descname">set_clusterids</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">npoints</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.set_clusterids" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the cluster id assigned to each point.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from cube space to a whitened space.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.untransform">
<code class="sig-name descname">untransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ww</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.untransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from whitened space back to cube space.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wpoints</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo wrapping for circular parameters.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.ScalingLayer.wrap">
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.ScalingLayer.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap points for circular parameters.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.mlfriends.WrappingEllipsoid">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">WrappingEllipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.WrappingEllipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Ellipsoid which safely wraps points.</p>
<p>Initialise region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>array of vectors</em>) – live points</p>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.mlfriends.WrappingEllipsoid.compute_enlargement">
<code class="sig-name descname">compute_enlargement</code><span class="sig-paren">(</span><em class="sig-param">nbootstraps=50</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/user/.local/lib/python3.8/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.WrappingEllipsoid.compute_enlargement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ellipsoid enlargement after <cite>nbootstraps</cite> bootstrapping rounds.</p>
<p>The wrapping ellipsoid covariance is determined in each bootstrap round.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.WrappingEllipsoid.create_ellipsoid">
<code class="sig-name descname">create_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.WrappingEllipsoid.create_ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create wrapping ellipsoid and store its center and covariance.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.mlfriends.WrappingEllipsoid.inside">
<code class="sig-name descname">inside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.WrappingEllipsoid.inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if inside wrapping ellipsoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>array of vectors</em>) – Points to check</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_inside</strong> – True if inside wrapping ellipsoid, for each point in <cite>pts</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of bools</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="ultranest.mlfriends.bounding_ellipsoid">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">bounding_ellipsoid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.bounding_ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bounding ellipsoid containing a set of points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>(</em><em>npoints</em><em>, </em><em>ndim</em><em>) </em><em>ndarray</em>) – Coordinates of uniformly sampled points.</p></li>
<li><p><strong>pointvol</strong> (<em>float</em><em>, </em><em>optional</em>) – Used to set a minimum bound on the ellipsoid volume when
minvol is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean and covariance of points</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.mlfriends.compute_mean_pair_distance">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">compute_mean_pair_distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.compute_mean_pair_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average distance between pairs of points.
Pairs from different clusters are excluded in the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pts</strong> (<em>array</em>) – points</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em><em> or </em><em>None</em>) – for each point, index of the associated cluster.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean distance between point pairs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.mlfriends.find_nearby">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">find_nearby</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.find_nearby" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the index of a point in <cite>a</cite> within square radius <cite>radiussq</cite>, for each point <cite>b</cite> in <cite>bpts</cite>.</p>
<p>The number is written to <cite>nnearby</cite> (of same length as <cite>bpts</cite>).
If none is found, -1 is written.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>apts</strong> (<em>array</em>) – points</p></li>
<li><p><strong>bpts</strong> (<em>array</em>) – points</p></li>
<li><p><strong>radiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>nnearby</strong> (<em>array of ints</em>) – The result will be written here.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.mlfriends.make_eigvals_positive">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">make_eigvals_positive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.make_eigvals_positive" title="Permalink to this definition">¶</a></dt>
<dd><p>For the symmetric square matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>, increase any zero eigenvalues
to fulfill a target product of eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array</em>) – covariance matrix</p></li>
<li><p><strong>targetprod</strong> (<em>array</em>) – target product of eigenvalues</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>covariance matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.mlfriends.update_clusters">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">update_clusters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.update_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters <cite>upoints</cite>, so that clusters are distinct if no
member pair is within a radius of sqrt(<cite>maxradiussq</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upoints</strong> (<em>array</em>) – points (in u-space)</p></li>
<li><p><strong>tpoints</strong> (<em>array</em>) – points (in t-space)</p></li>
<li><p><strong>maxradiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em><em> or </em><em>None</em>) – for each point, index of the associated cluster.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>nclusters</strong> (<em>int</em>) – the number of clusters found, which is also clusterids.max()</p></li>
<li><p><strong>new_clusterids</strong> (<em>array of int</em>) – the new clusterids for each point</p></li>
<li><p><em>overlapped_points</em> – upoints with their cluster centers subtracted.</p></li>
<li><p><em>The existing cluster ids are re-used when assigning new clusters,</em></p></li>
<li><p><em>if possible.</em></p></li>
<li><p>Clustering is performed on a transformed coordinate space (<cite>tpoints</cite>).</p></li>
<li><p><em>Returned values are based on upoints.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.mlfriends.vol_prefactor">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">vol_prefactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ultranest.mlfriends.vol_prefactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume constant for an <code class="docutils literal notranslate"><span class="pre">n</span></code>-dimensional sphere.</p>
<p>for <code class="docutils literal notranslate"><span class="pre">n</span></code> even:  $$    (2pi)^(n    /2) / (2 * 4 * … * n)$$
for <code class="docutils literal notranslate"><span class="pre">n</span></code> odd :  $$2 * (2pi)^((n-1)/2) / (1 * 3 * … * n)$$</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – dimensionality</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>volume (float)</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id1">
<h2>ultranest.mlfriends module<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-0"></span><p>Construct and sample from region.</p>
<p>Implements MLFriends efficiently, with transformation layers and clustering.</p>
<dl class="py class">
<dt id="id0">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">AffineLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ctr</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">T</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">invT</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nclusters</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">wrapped_dims</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#id20" title="ultranest.mlfriends.ScalingLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.mlfriends.ScalingLayer</span></code></a></p>
<p>Affine whitening transformation.</p>
<p>Learns the covariance of points.</p>
<p>Initialise layer.</p>
<p>The parameters are optional and can be learned from points with <a class="reference internal" href="#id3" title="ultranest.mlfriends.AffineLayer.optimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">optimize()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctr</strong> (<em>vector</em>) – Center of points</p></li>
<li><p><strong>T</strong> (<em>matrix</em>) – transformation matrix</p></li>
<li><p><strong>invT</strong> (<em>matrix</em>) – inverse transformation matrix</p></li>
<li><p><strong>nclusters</strong> (<em>int</em>) – number of clusters</p></li>
<li><p><strong>wrapped_dims</strong> (<em>array of bools</em>) – indicates which parameter axes are circular.</p></li>
<li><p><strong>clusterids</strong> (<em>array of int</em>) – cluster id for each point</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="id2">
<code class="sig-name descname">create_new</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">upoints</span></em>, <em class="sig-param"><span class="n">maxradiussq</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>Learn next layer from this optimized layer’s clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upoints</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>maxradiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – Minimum volume to regularize sample covariance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A new, optimized AffineLayer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id3">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">centered_points</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize layer.</p>
<p>Estimates covariance of <code class="docutils literal notranslate"><span class="pre">centered_points</span></code>. <code class="docutils literal notranslate"><span class="pre">minvol</span></code> sets the
smallest allowed size of the covariance to avoid numerical
collapse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>centered_points</strong> (<em>array</em>) – points with their cluster center subtracted</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em>) – for each point, which cluster they belong to</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – Minimum volume to regularize sample covariance</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id4">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id4" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from cube space to a whitened space.</p>
</dd></dl>

<dl class="py method">
<dt id="id5">
<code class="sig-name descname">untransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ww</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id5" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from whitened space back to cube space.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="id6">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">MLFriends</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">transformLayer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id6" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>MLFriends region.</p>
<p>Defines a region around nested sampling live points for</p>
<ol class="arabic simple">
<li><p>checking whether a proposed point likely also fulfills the
likelihood constraints</p></li>
<li><p>proposing new points.</p></li>
</ol>
<p>Learns geometry of region from existing live points.</p>
<p>Initialise region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>array of vectors</em>) – live points</p></li>
<li><p><strong>transformLayer</strong> (<a class="reference internal" href="#id20" title="ultranest.mlfriends.ScalingLayer"><em>ScalingLayer</em></a><em> or </em><a class="reference internal" href="#id0" title="ultranest.mlfriends.AffineLayer"><em>AffineLayer</em></a>) – whitening layer</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="id7">
<code class="sig-name descname">compute_enlargement</code><span class="sig-paren">(</span><em class="sig-param">nbootstraps=50</em>, <em class="sig-param">minvol=0.0</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/user/.local/lib/python3.8/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#id7" title="Permalink to this definition">¶</a></dt>
<dd><p>Return MLFriends radius and ellipsoid enlargement using bootstrapping.</p>
<p>The wrapping ellipsoid covariance is determined in each bootstrap round.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbootstraps</strong> (<em>int</em>) – number of bootstrapping rounds</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – minimum volume to enforce to wrapping ellipsoid</p></li>
<li><p><strong>rng</strong> – random number generator</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>max_distance</strong> (<em>float</em>) – square radius of MLFriends algorithm</p></li>
<li><p><strong>max_radius</strong> (<em>float</em>) – square radius of enclosing ellipsoid.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id8">
<code class="sig-name descname">compute_maxradiussq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nbootstraps</span><span class="o">=</span><span class="default_value">50</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id8" title="Permalink to this definition">¶</a></dt>
<dd><p>Run MLFriends bootstrapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nbootstraps</strong> (<em>int</em>) – number of bootstrapping rounds</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>square radius that safely encloses all live points.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id9">
<code class="sig-name descname">compute_mean_pair_distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="id10">
<code class="sig-name descname">create_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id10" title="Permalink to this definition">¶</a></dt>
<dd><p>Create wrapping ellipsoid and store its center and covariance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>minvol</strong> (<em>float</em>) – If positive, make sure ellipsoid has at least this volume.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id11">
<code class="sig-name descname">estimate_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id11" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the order of magnitude of the volume around a single point
given the current transformLayer and</p>
<p>Does not account for:
* the number of live points
* their overlap
* the intersection with the unit cube borders</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>volume (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id12">
<code class="sig-name descname">inside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id12" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if inside region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pts</strong> (<em>array of vectors</em>) – Points to check</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_inside</strong> – True if inside MLFriends region and wrapping ellipsoid,
for each point in <code class="docutils literal notranslate"><span class="pre">pts</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of bools</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id13">
<code class="sig-name descname">inside_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id13" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if inside wrapping ellipsoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>array of vectors</em>) – Points to check</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_inside</strong> – True if inside wrapping ellipsoid, for each point in <cite>pts</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of bools</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id14">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id14" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Switches automatically between the <code class="docutils literal notranslate"><span class="pre">sampling_methods</span></code> (attribute).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nsamples</strong> (<em>int</em>) – number of samples to draw</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>samples</strong> (<em>array of shape (nsamples, dimension)</em>) – samples drawn</p></li>
<li><p><strong>idx</strong> (<em>array of integers (nsamples)</em>) – index of a point nearby (MLFriends.u)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id15">
<code class="sig-name descname">sample_from_boundingbox</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id15" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Draws uniformly from bounding box around region.</p>
<p>Parameters as described in <em>sample()</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="id16">
<code class="sig-name descname">sample_from_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id16" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Chooses randomly from points and their ellipsoids.</p>
<p>Parameters as described in <em>sample()</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="id17">
<code class="sig-name descname">sample_from_transformed_boundingbox</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id17" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Draws uniformly from bounding box around region (in whitened space).</p>
<p>Parameters as described in <em>sample()</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="id18">
<code class="sig-name descname">sample_from_wrapping_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id18" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniformly sampled points from MLFriends region.</p>
<p>Draws uniformly from wrapping ellipsoid and filters with region.</p>
<p>Parameters as described in <code class="docutils literal notranslate"><span class="pre">sample()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="id19">
<code class="sig-name descname">set_transformLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transformLayer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id19" title="Permalink to this definition">¶</a></dt>
<dd><p>Update transformation layer. Invalidates attribute <cite>maxradius</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transformLayer</strong> (<a class="reference internal" href="#id20" title="ultranest.mlfriends.ScalingLayer"><em>ScalingLayer</em></a><em> or </em><a class="reference internal" href="#id0" title="ultranest.mlfriends.AffineLayer"><em>AffineLayer</em></a>) – t-space transformation layer</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="id20">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">ScalingLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mean</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">std</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nclusters</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">wrapped_dims</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id20" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Simple transformation layer that only shifts and scales each axis.</p>
<p>Initialise layer.</p>
<dl class="py method">
<dt id="id21">
<code class="sig-name descname">create_new</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">upoints</span></em>, <em class="sig-param"><span class="n">maxradiussq</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id21" title="Permalink to this definition">¶</a></dt>
<dd><p>Learn next layer from this optimized layer’s clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upoints</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>maxradiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>minvol</strong> (<em>float</em>) – Minimum volume to regularize sample covariance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A new, optimized ScalingLayer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id22">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">centered_points</span></em>, <em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id22" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize layer.</p>
<p>Estimates mean and std of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array</em>) – points to use for optimize (in u-space)</p></li>
<li><p><strong>centered_points</strong> (<em>array</em>) – points with their cluster center subtracted</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em>) – for each point, which cluster they belong to</p></li>
<li><p><strong>minvol</strong> – ignored</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id23">
<code class="sig-name descname">optimize_wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id23" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimization for wrapped/circular parameters.
Does nothing if there are no wrapped/circular parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array</em>) – points to use for optimization (in u-space)</p></li>
<li><p><strong>largest gap in live points and wrap parameter space there.</strong> (<em>Find</em>) – </p></li>
<li><p><strong>example</strong> (<em>For</em>) – <a href="#id43"><span class="problematic" id="id44">|*****           ****|</span></a></p></li>
<li><p><strong>a wrapped axis has::</strong> (<em>if</em>) – <a href="#id45"><span class="problematic" id="id46">|*****           ****|</span></a></p></li>
<li><p><strong>would identify the middle</strong> (<em>it</em>) – </p></li>
<li><p><strong>it</strong> (<em>subtract</em>) – </p></li>
<li><p><strong>that the new space</strong> (<em>so</em>) – </p></li>
<li><p><strong>is::</strong> – <div class="line-block">
<div class="line"><strong>****</strong>      |</div>
</div>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id24">
<code class="sig-name descname">set_clusterids</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clusterids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">npoints</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id24" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the cluster id assigned to each point.</p>
</dd></dl>

<dl class="py method">
<dt id="id25">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id25" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from cube space to a whitened space.</p>
</dd></dl>

<dl class="py method">
<dt id="id26">
<code class="sig-name descname">untransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ww</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id26" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform points from whitened space back to cube space.</p>
</dd></dl>

<dl class="py method">
<dt id="id27">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wpoints</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id27" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo wrapping for circular parameters.</p>
</dd></dl>

<dl class="py method">
<dt id="id28">
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id28" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap points for circular parameters.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="id29">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">WrappingEllipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id29" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Ellipsoid which safely wraps points.</p>
<p>Initialise region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>array of vectors</em>) – live points</p>
</dd>
</dl>
<dl class="py method">
<dt id="id30">
<code class="sig-name descname">compute_enlargement</code><span class="sig-paren">(</span><em class="sig-param">nbootstraps=50</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/user/.local/lib/python3.8/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#id30" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ellipsoid enlargement after <cite>nbootstraps</cite> bootstrapping rounds.</p>
<p>The wrapping ellipsoid covariance is determined in each bootstrap round.</p>
</dd></dl>

<dl class="py method">
<dt id="id31">
<code class="sig-name descname">create_ellipsoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">minvol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id31" title="Permalink to this definition">¶</a></dt>
<dd><p>Create wrapping ellipsoid and store its center and covariance.</p>
</dd></dl>

<dl class="py method">
<dt id="id32">
<code class="sig-name descname">inside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id32" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if inside wrapping ellipsoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>array of vectors</em>) – Points to check</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_inside</strong> – True if inside wrapping ellipsoid, for each point in <cite>pts</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of bools</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="id33">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">bounding_ellipsoid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id33" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bounding ellipsoid containing a set of points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>(</em><em>npoints</em><em>, </em><em>ndim</em><em>) </em><em>ndarray</em>) – Coordinates of uniformly sampled points.</p></li>
<li><p><strong>pointvol</strong> (<em>float</em><em>, </em><em>optional</em>) – Used to set a minimum bound on the ellipsoid volume when
minvol is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean and covariance of points</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id34">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">compute_mean_pair_distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id34" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average distance between pairs of points.
Pairs from different clusters are excluded in the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pts</strong> (<em>array</em>) – points</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em><em> or </em><em>None</em>) – for each point, index of the associated cluster.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean distance between point pairs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id35">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">find_nearby</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id35" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the index of a point in <cite>a</cite> within square radius <cite>radiussq</cite>, for each point <cite>b</cite> in <cite>bpts</cite>.</p>
<p>The number is written to <cite>nnearby</cite> (of same length as <cite>bpts</cite>).
If none is found, -1 is written.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>apts</strong> (<em>array</em>) – points</p></li>
<li><p><strong>bpts</strong> (<em>array</em>) – points</p></li>
<li><p><strong>radiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>nnearby</strong> (<em>array of ints</em>) – The result will be written here.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id36">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">make_eigvals_positive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id36" title="Permalink to this definition">¶</a></dt>
<dd><p>For the symmetric square matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>, increase any zero eigenvalues
to fulfill a target product of eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array</em>) – covariance matrix</p></li>
<li><p><strong>targetprod</strong> (<em>array</em>) – target product of eigenvalues</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>covariance matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id37">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">update_clusters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id37" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters <cite>upoints</cite>, so that clusters are distinct if no
member pair is within a radius of sqrt(<cite>maxradiussq</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upoints</strong> (<em>array</em>) – points (in u-space)</p></li>
<li><p><strong>tpoints</strong> (<em>array</em>) – points (in t-space)</p></li>
<li><p><strong>maxradiussq</strong> (<em>float</em>) – square of the MLFriends radius</p></li>
<li><p><strong>clusterids</strong> (<em>array of ints</em><em> or </em><em>None</em>) – for each point, index of the associated cluster.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>nclusters</strong> (<em>int</em>) – the number of clusters found, which is also clusterids.max()</p></li>
<li><p><strong>new_clusterids</strong> (<em>array of int</em>) – the new clusterids for each point</p></li>
<li><p><em>overlapped_points</em> – upoints with their cluster centers subtracted.</p></li>
<li><p><em>The existing cluster ids are re-used when assigning new clusters,</em></p></li>
<li><p><em>if possible.</em></p></li>
<li><p>Clustering is performed on a transformed coordinate space (<cite>tpoints</cite>).</p></li>
<li><p><em>Returned values are based on upoints.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id38">
<code class="sig-prename descclassname">ultranest.mlfriends.</code><code class="sig-name descname">vol_prefactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id38" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume constant for an <code class="docutils literal notranslate"><span class="pre">n</span></code>-dimensional sphere.</p>
<p>for <code class="docutils literal notranslate"><span class="pre">n</span></code> even:  $$    (2pi)^(n    /2) / (2 * 4 * … * n)$$
for <code class="docutils literal notranslate"><span class="pre">n</span></code> odd :  $$2 * (2pi)^((n-1)/2) / (1 * 3 * … * n)$$</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – dimensionality</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>volume (float)</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ultranest.netiter">
<span id="ultranest-netiter-module"></span><h2>ultranest.netiter module<a class="headerlink" href="#module-ultranest.netiter" title="Permalink to this headline">¶</a></h2>
<p>Functions and classes for treating nested sampling exploration as a tree.</p>
<p>The root represents the prior volume, branches and sub-branches split the volume.
The leaves of the tree are the integration tail.</p>
<p>Nested sampling proceeds as a breadth first graph search,
with active nodes sorted by likelihood value.
The number of live points are the number of parallel edges (active nodes to do).</p>
<p>Most functions receive the argument “roots”, which are the
children of the tree root (main branches).</p>
<p>The exploration is bootstrap-capable without requiring additional
computational effort: The roots are indexed, and the bootstrap explorer
can ignore the rootids it does not know about.</p>
<dl class="py class">
<dt id="ultranest.netiter.TreeNode">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">TreeNode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">children</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#TreeNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.TreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Simple tree node.</p>
<p>Define TreeNode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – used to order nodes</p></li>
<li><p><strong>id</strong> (<em>int</em>) – refers to the order of discovery and storage (PointPile)</p></li>
<li><p><strong>children</strong> (<em>list of nodes</em>) – children nodes. if None, a empty list is used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="ultranest.netiter.BreadthFirstIterator">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">BreadthFirstIterator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">roots</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#BreadthFirstIterator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.BreadthFirstIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generator exploring the tree.</p>
<p>Nodes are ordered by value and expanded in order.
The number of edges passing the node “in parallel” are “active”.</p>
<p>Start with initial set of nodes <em>roots</em>.</p>
<dl class="py method">
<dt id="ultranest.netiter.BreadthFirstIterator.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#BreadthFirstIterator.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.BreadthFirstIterator.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)start exploration from the top.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.BreadthFirstIterator.next_node">
<code class="sig-name descname">next_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#BreadthFirstIterator.next_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.BreadthFirstIterator.next_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get next node in order.</p>
<p>Does not remove the node from active set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>None if done.</em></p></li>
<li><p><em>rootid, node, (active_nodes, active_root_ids, active_node_values, active_node_ids)</em></p></li>
<li><p><em>otherwise</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.BreadthFirstIterator.drop_next_node">
<code class="sig-name descname">drop_next_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#BreadthFirstIterator.drop_next_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.BreadthFirstIterator.drop_next_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Forget the current node.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.BreadthFirstIterator.expand_children_of">
<code class="sig-name descname">expand_children_of</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rootid</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#BreadthFirstIterator.expand_children_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.BreadthFirstIterator.expand_children_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the current node with its children.</p>
<p>rootid and node have to come from the most recent call to next_node.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="ultranest.netiter.print_tree">
<code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">print_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">roots</span></em>, <em class="sig-param"><span class="n">title</span><span class="o">=</span><span class="default_value">'Tree:'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#print_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.print_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a pretty yet compact graphic of the tree.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.netiter.dump_tree">
<code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">dump_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">roots</span></em>, <em class="sig-param"><span class="n">pointpile</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#dump_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.dump_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a copy of the tree to a HDF5 file.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.netiter.count_tree">
<code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">count_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">roots</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#count_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.count_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum number of parallel edges and the total number of nodes.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.netiter.count_tree_between">
<code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">count_tree_between</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">roots</span></em>, <em class="sig-param"><span class="n">lo</span></em>, <em class="sig-param"><span class="n">hi</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#count_tree_between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.count_tree_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Build basic tree statistics.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>nnodes</strong> (<em>int</em>) – the total number of nodes in the value interval lo .. hi (inclusive).</p></li>
<li><p><strong>maxwidth</strong> (<em>int</em>) – the maximum number of parallel edges</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.netiter.find_nodes_before">
<code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">find_nodes_before</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#find_nodes_before"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.find_nodes_before" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify all nodes that have children above value.</p>
<p>If a root child is above the value, its parent (root) is the leaf returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>list_of_parents</strong> (<em>list of nodes</em>) – parents</p></li>
<li><p><strong>list_of_nforks</strong> (<em>list of floats</em>) – The list of number of forks experienced is:
1 if direct descendent of one of the root node’s children,
where no node had more than one child.
12 if the root child had 4 children, one of which had 3 children.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="ultranest.netiter.PointPile">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">PointPile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">udim</span></em>, <em class="sig-param"><span class="n">pdim</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#PointPile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.PointPile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A in-memory linearized storage of point coordinates.</p>
<p>TreeNodes only store the logL value and id,
which is the index in the point pile. The point pile stores
the point coordinates.</p>
<p>Set up point pile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>udim</strong> (<em>int</em>) – number of parameters, dimension of unit cube points</p></li>
<li><p><strong>pdim</strong> (<em>int</em>) – number of physical (and derived) parameters</p></li>
<li><p><strong>chunksize</strong> (<em>int</em>) – the point pile grows as needed, in these intervals.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.netiter.PointPile.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">newpointu</span></em>, <em class="sig-param"><span class="n">newpointp</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#PointPile.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.PointPile.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Save point <cite>newpointu</cite> (cube) / <cite>newpointp</cite> (parameters).</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.PointPile.getu">
<code class="sig-name descname">getu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#PointPile.getu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.PointPile.getu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get cube point(s) with index(indices) <cite>i</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.PointPile.getp">
<code class="sig-name descname">getp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#PointPile.getp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.PointPile.getp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameter point(s) with index(indices) <cite>i</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.PointPile.make_node">
<code class="sig-name descname">make_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">p</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#PointPile.make_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.PointPile.make_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Save point <cite>u</cite> (cube) / <cite>p</cite> (parameters), return a tree node.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.netiter.SingleCounter">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">SingleCounter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#SingleCounter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.SingleCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Evidence log(Z) and posterior weight summation for a Nested Sampling tree.</p>
<p>Initialise counter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>random</strong> (<em>bool</em>) – if False, use mean estimator for volume shrinkage
if True, draw a random sample</p>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.netiter.SingleCounter.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#SingleCounter.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.SingleCounter.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset counters and integration.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.SingleCounter.logZremain">
<em class="property">property </em><code class="sig-name descname">logZremain</code><a class="headerlink" href="#ultranest.netiter.SingleCounter.logZremain" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conservatively the logZ of the current tail (un-opened nodes).</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.SingleCounter.passing_node">
<code class="sig-name descname">passing_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">parallel_nodes</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#SingleCounter.passing_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.SingleCounter.passing_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate node to the integration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#ultranest.netiter.TreeNode" title="ultranest.netiter.TreeNode"><em>TreeNode</em></a>) – breadth-first removed node</p></li>
<li><p><strong>parallel_nodes</strong> (<em>list</em>) – nodes active next to node</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.netiter.MultiCounter">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">MultiCounter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nroots</span></em>, <em class="sig-param"><span class="n">nbootstraps</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">check_insertion_order</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#MultiCounter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.MultiCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Like SingleCounter, but bootstrap capable.</p>
<p><strong>Attributes</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">logZ</span></code>, <code class="docutils literal notranslate"><span class="pre">logZerr</span></code>, <code class="docutils literal notranslate"><span class="pre">logVolremaining</span></code>: main estimator
<code class="docutils literal notranslate"><span class="pre">logZerr</span></code> is probably not reliable, because it needs <code class="docutils literal notranslate"><span class="pre">nlive</span></code>
to convert <code class="docutils literal notranslate"><span class="pre">H</span></code> to <code class="docutils literal notranslate"><span class="pre">logZerr</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Lmax</span></code>: highest loglikelihood currently known</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">logZ_bs</span></code>, <code class="docutils literal notranslate"><span class="pre">logZerr_bs</span></code>: bootstrapped logZ estimate</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">logZremain</span></code>, <code class="docutils literal notranslate"><span class="pre">remainder_ratio</span></code>: weight and fraction of the unexplored remainder</p></li>
</ul>
<p>Each of the following has as many entries as number of iterations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">all_H</span></code>, <code class="docutils literal notranslate"><span class="pre">all_logZ</span></code>, <code class="docutils literal notranslate"><span class="pre">all_logVolremaining</span></code>, <code class="docutils literal notranslate"><span class="pre">logweights</span></code>:
information for all instances
first entry is the main estimator, i.e., not bootstrapped</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">istail</span></code>: whether that node was a leaf.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nlive</span></code>: number of parallel arcs (“live points”)</p></li>
</ul>
<p>Initialise counter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nroots</strong> (<em>int</em>) – number of children the tree root has</p></li>
<li><p><strong>nbootstraps</strong> (<em>int</em>) – number of bootstrap rounds</p></li>
<li><p><strong>random</strong> (<em>bool</em>) – if False, use mean estimator for volume shrinkage
if True, draw a random sample</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.netiter.MultiCounter.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nentries</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#MultiCounter.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.MultiCounter.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset counters/integrator.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.MultiCounter.logZ_bs">
<em class="property">property </em><code class="sig-name descname">logZ_bs</code><a class="headerlink" href="#ultranest.netiter.MultiCounter.logZ_bs" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate logZ from the bootstrap ensemble.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.MultiCounter.logZerr_bs">
<em class="property">property </em><code class="sig-name descname">logZerr_bs</code><a class="headerlink" href="#ultranest.netiter.MultiCounter.logZerr_bs" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate logZ error from the bootstrap ensemble.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.MultiCounter.insertion_order_runlength">
<em class="property">property </em><code class="sig-name descname">insertion_order_runlength</code><a class="headerlink" href="#ultranest.netiter.MultiCounter.insertion_order_runlength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.MultiCounter.insertion_order_converged">
<em class="property">property </em><code class="sig-name descname">insertion_order_converged</code><a class="headerlink" href="#ultranest.netiter.MultiCounter.insertion_order_converged" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.netiter.MultiCounter.passing_node">
<code class="sig-name descname">passing_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rootid</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">rootids</span></em>, <em class="sig-param"><span class="n">parallel_values</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#MultiCounter.passing_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.MultiCounter.passing_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate node to the integration.</p>
<p>Breadth-first removed <cite>node</cite> and nodes active next to node (<cite>parallel_nodes</cite>).
rootid and rootids are needed to identify which bootstrap instance
should accumulate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rootid</strong> (<a class="reference internal" href="#ultranest.netiter.TreeNode" title="ultranest.netiter.TreeNode"><em>TreeNode</em></a>) – root node this <cite>node</cite> is from.</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="#ultranest.netiter.TreeNode" title="ultranest.netiter.TreeNode"><em>TreeNode</em></a>) – node being processed.</p></li>
<li><p><strong>rootids</strong> (<em>array of ints</em>) – for each parallel node, which root it belongs to.</p></li>
<li><p><strong>parallel_values</strong> (<em>float array</em>) – loglikelihood values of nodes passing <cite>node</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="ultranest.netiter.combine_results">
<code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">combine_results</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">saved_logl</span></em>, <em class="sig-param"><span class="n">saved_nodeids</span></em>, <em class="sig-param"><span class="n">pointpile</span></em>, <em class="sig-param"><span class="n">main_iterator</span></em>, <em class="sig-param"><span class="n">mpi_comm</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#combine_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.combine_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a sequence of likelihoods and nodes into a summary dictionary.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.netiter.logz_sequence">
<code class="sig-prename descclassname">ultranest.netiter.</code><code class="sig-name descname">logz_sequence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span></em>, <em class="sig-param"><span class="n">pointpile</span></em>, <em class="sig-param"><span class="n">nbootstraps</span><span class="o">=</span><span class="default_value">12</span></em>, <em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">onNode</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">check_insertion_order</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/netiter.html#logz_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.netiter.logz_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Run MultiCounter through tree <cite>root</cite>.</p>
<p>Keeps track of, and returns <code class="docutils literal notranslate"><span class="pre">(logz,</span> <span class="pre">logzerr,</span> <span class="pre">logv,</span> <span class="pre">nlive)</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="module-ultranest.ordertest">
<span id="ultranest-ordertest-module"></span><h2>ultranest.ordertest module<a class="headerlink" href="#module-ultranest.ordertest" title="Permalink to this headline">¶</a></h2>
<p>This implements the same idea as <a class="reference external" href="https://arxiv.org/abs/2006.03371">https://arxiv.org/abs/2006.03371</a>
except their KS test is problematic because the variable (insertion order)
is not continuous. Instead, this implements a Mann-Whitney-Wilcoxon
U test, which also is in practice more sensitive than the KS test.
A highly efficient implementation is achieved by keeping only
a histogram of the insertion orders and comparing those
to expectations from a uniform distribution.</p>
<p>To quantify the convergence of a run, one route is to apply this test
at the end of the run. Another approach is to reset the counters every
time the test exceeds a z-score of 3 sigma, and report the run lengths,
which quantify how many iterations nested sampling was able to proceed
without detection of a insertion order problem.</p>
<dl class="py function">
<dt id="ultranest.ordertest.infinite_U_zscore">
<code class="sig-prename descclassname">ultranest.ordertest.</code><code class="sig-name descname">infinite_U_zscore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sample</span></em>, <em class="sig-param"><span class="n">B</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/ordertest.html#infinite_U_zscore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.ordertest.infinite_U_zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Mann-Whitney-Wilcoxon U test for a
<em>sample</em> of integers to be uniformly distributed between 0 and <em>B</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>B</strong> (<em>int</em>) – maximum rank allowed.</p></li>
<li><p><strong>sample</strong> (<em>array of integers</em>) – values between 0 and B (inclusive).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>z-score (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="ultranest.ordertest.UniformOrderAccumulator">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.ordertest.</code><code class="sig-name descname">UniformOrderAccumulator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/ordertest.html#UniformOrderAccumulator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.ordertest.UniformOrderAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store orders (1 to N), for comparison with a uniform order.</p>
<dl class="py method">
<dt id="ultranest.ordertest.UniformOrderAccumulator.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/ordertest.html#UniformOrderAccumulator.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.ordertest.UniformOrderAccumulator.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all counts to zero.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.ordertest.UniformOrderAccumulator.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">N</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/ordertest.html#UniformOrderAccumulator.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.ordertest.UniformOrderAccumulator.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate rank <em>order</em> (0 to N).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – maximum rank allowed.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – rank between 0 and N (inclusive).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.ordertest.UniformOrderAccumulator.zscore">
<em class="property">property </em><code class="sig-name descname">zscore</code><a class="headerlink" href="#ultranest.ordertest.UniformOrderAccumulator.zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>Mann-Whitney-Wilcoxon U test z-score, against a uniform distribution.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.pathsampler">
<span id="ultranest-pathsampler-module"></span><h2>ultranest.pathsampler module<a class="headerlink" href="#module-ultranest.pathsampler" title="Permalink to this headline">¶</a></h2>
<p>MCMC-like step sampling on a trajectory.</p>
<p>These features are experimental.</p>
<dl class="py class">
<dt id="ultranest.pathsampler.SamplingPathSliceSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.pathsampler.</code><code class="sig-name descname">SamplingPathSliceSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathSliceSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.StepSampler" title="ultranest.stepsampler.StepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.StepSampler</span></code></a></p>
<p>Slice sampler, respecting the region, on the sampling path.</p>
<p>This first builds up a complete trajectory, respecting reflections.
Then, from the trajectory a new point is drawn with slice sampling.</p>
<p>The trajectory is built by doubling the length to each side and
checking if the point is still inside. If not, reflection is
attempted with the gradient (either provided or region-based estimate).</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathSliceSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathSliceSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathSliceSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose new initial direction according to region.transformLayer axes.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathSliceSampler.adjust_accept">
<code class="sig-name descname">adjust_accept</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">accepted</span></em>, <em class="sig-param"><span class="n">unew</span></em>, <em class="sig-param"><span class="n">pnew</span></em>, <em class="sig-param"><span class="n">Lnew</span></em>, <em class="sig-param"><span class="n">nc</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathSliceSampler.adjust_accept"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathSliceSampler.adjust_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we have been <em>accepted</em> at a new point after <em>nc</em> calls.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathSliceSampler.adjust_outside_region">
<code class="sig-name descname">adjust_outside_region</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathSliceSampler.adjust_outside_region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathSliceSampler.adjust_outside_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we have stepped out of region.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathSliceSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathSliceSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathSliceSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance by slice sampling on the path.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.pathsampler.SamplingPathStepSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.pathsampler.</code><code class="sig-name descname">SamplingPathStepSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nresets</span></em>, <em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">balance</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">nudge</span><span class="o">=</span><span class="default_value">1.1</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.StepSampler" title="ultranest.stepsampler.StepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.StepSampler</span></code></a></p>
<p>Step sampler on a sampling path.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nresets</strong> (<em>int</em>) – after this many iterations, select a new direction</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – how many steps to make in total</p></li>
<li><p><strong>scale</strong> (<em>float</em>) – initial step size</p></li>
<li><p><strong>balance</strong> (<em>float</em>) – acceptance rate to target
if below, scale is increased, if above, scale is decreased</p></li>
<li><p><strong>nudge</strong> (<em>float</em>) – factor for increasing scale (must be &gt;=1)
nudge=1 implies no step size adaptation.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start sampler, reset all counters.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.start_path">
<code class="sig-name descname">start_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.start_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.start_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Start new trajectory path.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.terminate_path">
<code class="sig-name descname">terminate_path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.terminate_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.terminate_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate current path, and reset path counting variable.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.set_gradient">
<code class="sig-name descname">set_gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grad_function</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.set_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.set_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Set gradient function.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">scale</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a random axis from region.transformLayer.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.adjust_accept">
<code class="sig-name descname">adjust_accept</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">accepted</span></em>, <em class="sig-param"><span class="n">unew</span></em>, <em class="sig-param"><span class="n">pnew</span></em>, <em class="sig-param"><span class="n">Lnew</span></em>, <em class="sig-param"><span class="n">nc</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.adjust_accept"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.adjust_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we have been <em>accepted</em> at a new point after <em>nc</em> calls.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.adjust_outside_region">
<code class="sig-name descname">adjust_outside_region</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.adjust_outside_region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.adjust_outside_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we landed outside region.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.adjust_scale">
<code class="sig-name descname">adjust_scale</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxlength</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.adjust_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.adjust_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust scale, but not above maxlength.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.movei">
<code class="sig-name descname">movei</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.movei"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.movei" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a move and return the proposed index.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance move.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.reflect">
<code class="sig-name descname">reflect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reflpoint</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.reflect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect at <em>reflpoint</em> going in direction <em>v</em>. Return new direction.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.SamplingPathStepSampler.get_point">
<code class="sig-name descname">get_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inew</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#SamplingPathStepSampler.get_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.SamplingPathStepSampler.get_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get point corresponding to index <em>inew</em>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.pathsampler.OtherSamplerProxy">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.pathsampler.</code><code class="sig-name descname">OtherSamplerProxy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nnewdirections</span></em>, <em class="sig-param"><span class="n">sampler</span><span class="o">=</span><span class="default_value">'steps'</span></em>, <em class="sig-param"><span class="n">nsteps</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">balance</span><span class="o">=</span><span class="default_value">0.9</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">nudge</span><span class="o">=</span><span class="default_value">1.1</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#OtherSamplerProxy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.OtherSamplerProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Proxy for ClockedSamplers.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnewdirections</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>sampler</strong> (<em>str</em>) – which sampler to use</p></li>
<li><p><strong>nsteps</strong> – number of steps in sampler</p></li>
<li><p><strong>balance</strong> – acceptance rate to target</p></li>
<li><p><strong>scale</strong> – initial proposal scale</p></li>
<li><p><strong>nudge</strong> – adjustment factor for scale when acceptance rate is too low or high.
must be &gt;=1.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.pathsampler.OtherSamplerProxy.accumulate_statistics">
<code class="sig-name descname">accumulate_statistics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#OtherSamplerProxy.accumulate_statistics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.OtherSamplerProxy.accumulate_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate statistics at end of step sequence.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.OtherSamplerProxy.adjust_scale">
<code class="sig-name descname">adjust_scale</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxlength</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#OtherSamplerProxy.adjust_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.OtherSamplerProxy.adjust_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal scale, but not above maxlength.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.OtherSamplerProxy.startup">
<code class="sig-name descname">startup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">us</span></em>, <em class="sig-param"><span class="n">Ls</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#OtherSamplerProxy.startup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.OtherSamplerProxy.startup" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a new random starting point.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.OtherSamplerProxy.start_direction">
<code class="sig-name descname">start_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#OtherSamplerProxy.start_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.OtherSamplerProxy.start_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a new random direction.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.pathsampler.OtherSamplerProxy.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/pathsampler.html#OtherSamplerProxy.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.pathsampler.OtherSamplerProxy.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sampler statistics.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.plot">
<span id="ultranest-plot-module"></span><h2>ultranest.plot module<a class="headerlink" href="#module-ultranest.plot" title="Permalink to this headline">¶</a></h2>
<p>Plotting utilities.</p>
<dl class="py function">
<dt id="ultranest.plot.runplot">
<code class="sig-prename descclassname">ultranest.plot.</code><code class="sig-name descname">runplot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">results</span></em>, <em class="sig-param"><span class="n">span</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">logplot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">kde</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">nkde</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">color</span><span class="o">=</span><span class="default_value">'blue'</span></em>, <em class="sig-param"><span class="n">plot_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">label_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lnz_error</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">lnz_truth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">truth_color</span><span class="o">=</span><span class="default_value">'red'</span></em>, <em class="sig-param"><span class="n">truth_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_x_ticks</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">max_y_ticks</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">use_math_text</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">mark_final_live</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fig</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#runplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.runplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot live points, ln(likelihood), ln(weight), and ln(evidence) vs. ln(prior volume).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>results</strong> (<em>dynesty.results.Results instance</em>) – dynesty.results.Results instance from a nested
sampling run.</p></li>
<li><p><strong>span</strong> (<em>iterable with shape</em><em> (</em><em>4</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – <p>A list where each element is either a length-2 tuple containing
lower and upper bounds <em>or</em> a float from <cite>(0., 1.]</cite> giving the
fraction below the maximum. If a fraction is provided,
the bounds are chosen to be equal-tailed. An example would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">span</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">),</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="p">(</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">)]</span>
</pre></div>
</div>
<p>Default is <cite>(0., 1.05 * max(data))</cite> for each element.</p>
</p></li>
<li><p><strong>logplot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to plot the evidence on a log scale. Default is <cite>False</cite>.</p></li>
<li><p><strong>kde</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use kernel density estimation to estimate and plot
the PDF of the importance weights as a function of log-volume
(as opposed to the importance weights themselves). Default is
<cite>True</cite>.</p></li>
<li><p><strong>nkde</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of grid points used when plotting the kernel density
estimate. Default is <cite>1000</cite>.</p></li>
<li><p><strong>color</strong> (<em>str</em><em> or </em><em>iterable with shape</em><em> (</em><em>4</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A <cite>~matplotlib</cite>-style color (either a single color or a different
value for each subplot) used when plotting the lines in each subplot.
Default is <cite>‘blue’</cite>.</p></li>
<li><p><strong>plot_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be passed to <cite>plot</cite>.</p></li>
<li><p><strong>label_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be sent to the
<cite>~matplotlib.axes.Axes.set_xlabel</cite> and
<cite>~matplotlib.axes.Axes.set_ylabel</cite> methods.</p></li>
<li><p><strong>lnz_error</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to plot the 1, 2, and 3-sigma approximate error bars
derived from the ln(evidence) error approximation over the course
of the run. Default is True.</p></li>
<li><p><strong>lnz_truth</strong> (<em>float</em><em>, </em><em>optional</em>) – A reference value for the evidence that will be overplotted on the
evidence subplot if provided.</p></li>
<li><p><strong>truth_color</strong> (<em>str</em><em> or </em><em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A <cite>~matplotlib</cite>-style color used when plotting <cite>lnz_truth</cite>.
Default is <cite>‘red’</cite>.</p></li>
<li><p><strong>truth_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be used for plotting
<cite>lnz_truth</cite>.</p></li>
<li><p><strong>max_x_ticks</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of ticks allowed for the x axis. Default is <cite>8</cite>.</p></li>
<li><p><strong>max_y_ticks</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of ticks allowed for the y axis. Default is <cite>4</cite>.</p></li>
<li><p><strong>use_math_text</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the axis tick labels for very large/small exponents should be
displayed as powers of 10 rather than using <cite>e</cite>. Default is <cite>False</cite>.</p></li>
<li><p><strong>mark_final_live</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to indicate the final addition of recycled live points
(if they were added to the resulting samples) using
a dashed vertical line. Default is <cite>True</cite>.</p></li>
<li><p><strong>fig</strong> ((<cite>~matplotlib.figure.Figure</cite>, <cite>~matplotlib.axes.Axes</cite>), optional) – If provided, overplot the run onto the provided figure.
Otherwise, by default an internal figure is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>runplot</strong> – Output summary plot.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<cite>~matplotlib.figure.Figure</cite>, <cite>~matplotlib.axes.Axes</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.plot.cornerplot">
<code class="sig-prename descclassname">ultranest.plot.</code><code class="sig-name descname">cornerplot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">results</span></em>, <em class="sig-param"><span class="n">logger</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#cornerplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.cornerplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a corner plot with corner.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.plot.traceplot">
<code class="sig-prename descclassname">ultranest.plot.</code><code class="sig-name descname">traceplot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">results</span></em>, <em class="sig-param"><span class="n">span</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">quantiles</span><span class="o">=</span><span class="default_value">[0.025, 0.5, 0.975]</span></em>, <em class="sig-param"><span class="n">smooth</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">post_color</span><span class="o">=</span><span class="default_value">'blue'</span></em>, <em class="sig-param"><span class="n">post_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kde</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">nkde</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">trace_cmap</span><span class="o">=</span><span class="default_value">'plasma'</span></em>, <em class="sig-param"><span class="n">trace_color</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">trace_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">connect</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">connect_highlight</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">connect_color</span><span class="o">=</span><span class="default_value">'red'</span></em>, <em class="sig-param"><span class="n">connect_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_n_ticks</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">use_math_text</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">label_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">show_titles</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">title_fmt</span><span class="o">=</span><span class="default_value">'.2f'</span></em>, <em class="sig-param"><span class="n">title_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">truths</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">truth_color</span><span class="o">=</span><span class="default_value">'red'</span></em>, <em class="sig-param"><span class="n">truth_kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fig</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#traceplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.traceplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot traces and marginalized posteriors for each parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>results</strong> (<cite>~dynesty.results.Results</cite> instance) – A <cite>~dynesty.results.Results</cite> instance from a nested
sampling run. <strong>Compatible with results derived from</strong>
<a class="reference external" href="http://kylebarbary.com/nestle/">nestle</a>.</p></li>
<li><p><strong>span</strong> (<em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – <p>A list where each element is either a length-2 tuple containing
lower and upper bounds or a float from <cite>(0., 1.]</cite> giving the
fraction of (weighted) samples to include. If a fraction is provided,
the bounds are chosen to be equal-tailed. An example would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">span</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">),</span> <span class="mf">0.95</span><span class="p">,</span> <span class="p">(</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">)]</span>
</pre></div>
</div>
<p>Default is <cite>0.999999426697</cite> (5-sigma credible interval) for each
parameter.</p>
</p></li>
<li><p><strong>quantiles</strong> (<em>iterable</em><em>, </em><em>optional</em>) – A list of fractional quantiles to overplot on the 1-D marginalized
posteriors as vertical dashed lines. Default is <cite>[0.025, 0.5, 0.975]</cite>
(the 95%/2-sigma credible interval).</p></li>
<li><p><strong>smooth</strong> (<em>float</em><em> or </em><em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – The standard deviation (either a single value or a different value for
each subplot) for the Gaussian kernel used to smooth the 1-D
marginalized posteriors, expressed as a fraction of the span.
Default is <cite>0.02</cite> (2% smoothing). If an integer is provided instead,
this will instead default to a simple (weighted) histogram with
<cite>bins=smooth</cite>.</p></li>
<li><p><strong>post_color</strong> (<em>str</em><em> or </em><em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A <cite>~matplotlib</cite>-style color (either a single color or a different
value for each subplot) used when plotting the histograms.
Default is <cite>‘blue’</cite>.</p></li>
<li><p><strong>post_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be used for plotting the
marginalized 1-D posteriors.</p></li>
<li><p><strong>kde</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use kernel density estimation to estimate and plot
the PDF of the importance weights as a function of log-volume
(as opposed to the importance weights themselves). Default is
<cite>True</cite>.</p></li>
<li><p><strong>nkde</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of grid points used when plotting the kernel density
estimate. Default is <cite>1000</cite>.</p></li>
<li><p><strong>trace_cmap</strong> (<em>str</em><em> or </em><em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A <cite>~matplotlib</cite>-style colormap (either a single colormap or a
different colormap for each subplot) used when plotting the traces,
where each point is colored according to its weight. Default is
<cite>‘plasma’</cite>.</p></li>
<li><p><strong>trace_color</strong> (<em>str</em><em> or </em><em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A <cite>~matplotlib</cite>-style color (either a single color or a
different color for each subplot) used when plotting the traces.
This overrides the <cite>trace_cmap</cite> option by giving all points
the same color. Default is <cite>None</cite> (not used).</p></li>
<li><p><strong>trace_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be used for plotting the traces.</p></li>
<li><p><strong>connect</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to draw lines connecting the paths of unique particles.
Default is <cite>False</cite>.</p></li>
<li><p><strong>connect_highlight</strong> (<em>int</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – If <cite>connect=True</cite>, highlights the paths of a specific set of
particles. If an integer is passed, <code class="xref py py-data docutils literal notranslate"><span class="pre">connect_highlight</span></code>
random particle paths will be highlighted. If an iterable is passed,
then the particle paths corresponding to the provided indices
will be highlighted.</p></li>
<li><p><strong>connect_color</strong> (<em>str</em><em>, </em><em>optional</em>) – The color of the highlighted particle paths. Default is <cite>‘red’</cite>.</p></li>
<li><p><strong>connect_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments used for plotting particle paths.</p></li>
<li><p><strong>max_n_ticks</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of ticks allowed. Default is <cite>5</cite>.</p></li>
<li><p><strong>use_math_text</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the axis tick labels for very large/small exponents should be
displayed as powers of 10 rather than using <cite>e</cite>. Default is <cite>False</cite>.</p></li>
<li><p><strong>labels</strong> (<em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A list of names for each parameter. If not provided, the default name
used when plotting will follow <span class="math notranslate nohighlight">\(x_i\)</span> style.</p></li>
<li><p><strong>label_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be sent to the
<cite>~matplotlib.axes.Axes.set_xlabel</cite> and
<cite>~matplotlib.axes.Axes.set_ylabel</cite> methods.</p></li>
<li><p><strong>show_titles</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display a title above each 1-D marginalized posterior
showing the 0.5 quantile along with the upper/lower bounds associated
with the 0.025 and 0.975 (95%/2-sigma credible interval) quantiles.
Default is <cite>True</cite>.</p></li>
<li><p><strong>title_fmt</strong> (<em>str</em><em>, </em><em>optional</em>) – The format string for the quantiles provided in the title. Default is
<cite>‘.2f’</cite>.</p></li>
<li><p><strong>title_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be sent to the
<cite>~matplotlib.axes.Axes.set_title</cite> command.</p></li>
<li><p><strong>truths</strong> (<em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A list of reference values that will be overplotted on the traces and
marginalized 1-D posteriors as solid horizontal/vertical lines.
Individual values can be exempt using <cite>None</cite>. Default is <cite>None</cite>.</p></li>
<li><p><strong>truth_color</strong> (<em>str</em><em> or </em><em>iterable with shape</em><em> (</em><em>ndim</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – A <cite>~matplotlib</cite>-style color (either a single color or a different
value for each subplot) used when plotting <cite>truths</cite>.
Default is <cite>‘red’</cite>.</p></li>
<li><p><strong>truth_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra keyword arguments that will be used for plotting the vertical
and horizontal lines with <cite>truths</cite>.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print the values of the computed quantiles associated with
each parameter. Default is <cite>False</cite>.</p></li>
<li><p><strong>fig</strong> ((<cite>~matplotlib.figure.Figure</cite>, <cite>~matplotlib.axes.Axes</cite>), optional) – If provided, overplot the traces and marginalized 1-D posteriors
onto the provided figure. Otherwise, by default an
internal figure is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>traceplot</strong> – Output trace plot.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<cite>~matplotlib.figure.Figure</cite>, <cite>~matplotlib.axes.Axes</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="ultranest.plot.PredictionBand">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.plot.</code><code class="sig-name descname">PredictionBand</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">shadeargs</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">lineargs</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#PredictionBand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.PredictionBand" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Plot bands of model predictions as calculated from a chain.</p>
<p>call add(y) to add predictions from each chain point</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">band</span> <span class="o">=</span> <span class="n">PredictionBand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">:</span>
    <span class="n">band</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># add median line</span>
<span class="n">band</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="c1"># add 1 sigma quantile</span>
<span class="n">band</span><span class="o">.</span><span class="n">shade</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="c1"># add wider quantile</span>
<span class="n">band</span><span class="o">.</span><span class="n">shade</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>array</em>) – The independent variable</p>
</dd>
</dl>
<p>Initialise with independent variable <em>x</em>.</p>
<dl class="py method">
<dt id="ultranest.plot.PredictionBand.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#PredictionBand.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.PredictionBand.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a possible prediction <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.plot.PredictionBand.set_shadeargs">
<code class="sig-name descname">set_shadeargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#PredictionBand.set_shadeargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.PredictionBand.set_shadeargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set matplotlib style for shading.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.plot.PredictionBand.set_lineargs">
<code class="sig-name descname">set_lineargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#PredictionBand.set_lineargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.PredictionBand.set_lineargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set matplotlib style for line.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.plot.PredictionBand.get_line">
<code class="sig-name descname">get_line</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#PredictionBand.get_line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.PredictionBand.get_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Over prediction space x, get quantile <em>q</em>. Default is median.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.plot.PredictionBand.shade">
<code class="sig-name descname">shade</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">0.341</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#PredictionBand.shade"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.PredictionBand.shade" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a shaded region between 0.5-q and 0.5+q. Default is 1 sigma.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.plot.PredictionBand.line">
<code class="sig-name descname">line</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/plot.html#PredictionBand.line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.plot.PredictionBand.line" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the median curve.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.samplingpath">
<span id="ultranest-samplingpath-module"></span><h2>ultranest.samplingpath module<a class="headerlink" href="#module-ultranest.samplingpath" title="Permalink to this headline">¶</a></h2>
<p>Sparsely sampled, virtual sampling path.</p>
<p>Supports reflections at unit cube boundaries, and regions.</p>
<dl class="py function">
<dt id="ultranest.samplingpath.nearest_box_intersection_line">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">nearest_box_intersection_line</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ray_origin</span></em>, <em class="sig-param"><span class="n">ray_direction</span></em>, <em class="sig-param"><span class="n">fwd</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#nearest_box_intersection_line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.nearest_box_intersection_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute intersection of a line (ray) and a unit box (0:1 in all axes).</p>
<p>Based on
<a class="reference external" href="http://www.iquilezles.org/www/articles/intersectors/intersectors.htm">http://www.iquilezles.org/www/articles/intersectors/intersectors.htm</a></p>
<p>To continue forward traversing at the reflection point use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># update current point x</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">box_line_intersection</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># change direction</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ray_origin</strong> (<em>vector</em>) – starting point of line</p></li>
<li><p><strong>ray_direction</strong> (<em>vector</em>) – line direction vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>p</strong> (<em>vector</em>) – intersection point</p></li>
<li><p><strong>t</strong> (<em>float</em>) – intersection point distance from ray_origin in units in ray_direction</p></li>
<li><p><strong>i</strong> (<em>int</em>) – axes which change direction at pN</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.box_line_intersection">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">box_line_intersection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ray_origin</span></em>, <em class="sig-param"><span class="n">ray_direction</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#box_line_intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.box_line_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Find intersections of a line with the unit cube, in both sides.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>left</strong> (<em>nearest_box_intersection_line return value</em>) – from negative direction</p></li>
<li><p><strong>right</strong> (<em>nearest_box_intersection_line return value</em>) – from positive direction</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.linear_steps_with_reflection">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">linear_steps_with_reflection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ray_origin</span></em>, <em class="sig-param"><span class="n">ray_direction</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">wrapped_dims</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#linear_steps_with_reflection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.linear_steps_with_reflection" title="Permalink to this definition">¶</a></dt>
<dd><p>Go <cite>t</cite> steps in direction <cite>ray_direction</cite> from <cite>ray_origin</cite>.</p>
<p>Reflect off the unit cube if encountered, respecting wrapped dimensions.
In any case, the distance should be <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">*</span> <span class="pre">ray_direction</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>new_point</strong> (<em>vector</em>) – end point</p></li>
<li><p><strong>new_direction</strong> (<em>vector</em>) – new direction.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.get_sphere_tangent">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">get_sphere_tangent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sphere_center</span></em>, <em class="sig-param"><span class="n">edge_point</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#get_sphere_tangent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.get_sphere_tangent" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tangent at sphere surface point.</p>
<p>Assume a sphere centered at sphere_center with radius
so that edge_point is on the surface. At edge_point, in
which direction does the normal vector point?</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tangent</strong> – vector pointing to the sphere center.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.get_sphere_tangents">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">get_sphere_tangents</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sphere_center</span></em>, <em class="sig-param"><span class="n">edge_point</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#get_sphere_tangents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.get_sphere_tangents" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tangent at sphere surface point.</p>
<p>Assume a sphere centered at sphere_center with radius
so that edge_point is on the surface. At edge_point, in
which direction does the normal vector point?</p>
<p>This function is vectorized and handles arrays of arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tangent</strong> – vector pointing to the sphere center.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.reflect">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">reflect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">normal</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#reflect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect vector <code class="docutils literal notranslate"><span class="pre">v</span></code> off a <code class="docutils literal notranslate"><span class="pre">normal</span></code> vector, return new direction vector.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.distances">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">distances</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">o</span></em>, <em class="sig-param"><span class="n">r</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#distances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sphere-line intersection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> (<em>vector</em>) – direction vector (line starts at 0)</p></li>
<li><p><strong>o</strong> (<em>vector</em>) – center of sphere (coordinate vector)</p></li>
<li><p><strong>r</strong> (<em>float</em>) – radius of sphere</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tpos, tneg</strong> – the positive and negative coordinate along the <cite>l</cite> vector where <cite>r</cite> is intersected.
If no intersection, throws AssertError.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>floats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.isunitlength">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">isunitlength</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vec</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#isunitlength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.isunitlength" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that <cite>vec</cite> is of unit length.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.angle">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">angle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute dot product between vectors <cite>a</cite> and <cite>b</cite>.</p>
<p>The arccos of the return value would give an actual angle.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.extrapolate_ahead">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">extrapolate_ahead</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dj</span></em>, <em class="sig-param"><span class="n">xj</span></em>, <em class="sig-param"><span class="n">vj</span></em>, <em class="sig-param"><span class="n">contourpath</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#extrapolate_ahead"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.extrapolate_ahead" title="Permalink to this definition">¶</a></dt>
<dd><p>Make <cite>di</cite> steps of size <cite>vj</cite> from <cite>xj</cite>.</p>
<p>Reflect off unit cube if necessary.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.samplingpath.interpolate">
<code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">fwd_possible</span></em>, <em class="sig-param"><span class="n">rwd_possible</span></em>, <em class="sig-param"><span class="n">contourpath</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a point on the path indicated by <cite>points</cite>.</p>
<p>Given a sparsely sampled track (stored in .points),
potentially encountering reflections,
extract the corrdinates of the point with index <cite>i</cite>.
That point may not have been evaluated yet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> (<em>int</em>) – position on track to return.</p></li>
<li><p><strong>points</strong> (<em>list of tuples</em><em> (</em><em>index</em><em>, </em><em>coordinate</em><em>, </em><em>direction</em><em>, </em><em>loglike</em><em>)</em>) – points on the path</p></li>
<li><p><strong>fwd_possible</strong> (<em>bool</em>) – whether the path could be extended in the positive direction.</p></li>
<li><p><strong>rwd_possible</strong> (<em>bool</em>) – whether the path could be extended in the negative direction.</p></li>
<li><p><strong>contourpath</strong> (<em>ContourPath</em>) – Use region to reflect. Not used at the moment.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="ultranest.samplingpath.SamplingPath">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">SamplingPath</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">v0</span></em>, <em class="sig-param"><span class="n">L0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#SamplingPath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.SamplingPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Path described by a (potentially sparse) sequence of points.</p>
<p>Convention of the stored point tuple <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">x,</span> <span class="pre">v,</span> <span class="pre">L)</span></code>:
<cite>i</cite>: index (0 is starting point)
<cite>x</cite>: point
<cite>v</cite>: direction
<cite>L</cite>: loglikelihood value</p>
<p>Initialise with path starting point.</p>
<p>Starting point (<cite>x0</cite>), direction (<cite>v0</cite>) and
loglikelihood value (<cite>L0</cite>) of the path. Is given index 0.</p>
<dl class="py method">
<dt id="ultranest.samplingpath.SamplingPath.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">xi</span></em>, <em class="sig-param"><span class="n">vi</span></em>, <em class="sig-param"><span class="n">Li</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#SamplingPath.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.SamplingPath.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add point <cite>xi</cite>, direction <cite>vi</cite> and value <cite>Li</cite> with index <cite>i</cite> to the path.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.samplingpath.SamplingPath.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">v0</span></em>, <em class="sig-param"><span class="n">L0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#SamplingPath.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.SamplingPath.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset path, start from <code class="docutils literal notranslate"><span class="pre">x0,</span> <span class="pre">v0,</span> <span class="pre">L0</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.samplingpath.SamplingPath.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#SamplingPath.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.SamplingPath.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the current path.</p>
<p>Only uses first two dimensions.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.samplingpath.SamplingPath.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#SamplingPath.interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.SamplingPath.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate point with index <cite>i</cite> on path.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.samplingpath.SamplingPath.extrapolate">
<code class="sig-name descname">extrapolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#SamplingPath.extrapolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.SamplingPath.extrapolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance beyond the current path, extrapolate from the end point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<em>int</em>) – index on path.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coords</strong> – coordinates of the new point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>vector</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.samplingpath.ContourSamplingPath">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.samplingpath.</code><code class="sig-name descname">ContourSamplingPath</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samplingpath</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#ContourSamplingPath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.ContourSamplingPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Region-aware form of the sampling path.</p>
<p>Uses region points to guess a likelihood contour gradient.</p>
<p>Initialise with <cite>samplingpath</cite> and <cite>region</cite>.</p>
<dl class="py method">
<dt id="ultranest.samplingpath.ContourSamplingPath.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">L</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#ContourSamplingPath.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.ContourSamplingPath.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add point <cite>xi</cite>, direction <cite>vi</cite> and value <cite>Li</cite> with index <cite>i</cite> to the path.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.samplingpath.ContourSamplingPath.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#ContourSamplingPath.interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.ContourSamplingPath.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate point with index <cite>i</cite> on path.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.samplingpath.ContourSamplingPath.extrapolate">
<code class="sig-name descname">extrapolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#ContourSamplingPath.extrapolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.ContourSamplingPath.extrapolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance beyond the current path, extrapolate from the end point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<em>int</em>) – index on path.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coords</strong> – coordinates of the new point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.samplingpath.ContourSamplingPath.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reflpoint</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/samplingpath.html#ContourSamplingPath.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.samplingpath.ContourSamplingPath.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute gradient approximation.</p>
<p>Finds spheres enclosing the <cite>reflpoint</cite>, and chooses their mean
as the direction to go towards. If no spheres enclose the
reflpoint, use nearest sphere.</p>
<p>v is not used, because that would break detailed balance.</p>
<dl class="simple">
<dt>Considerations:</dt><dd><ul class="simple">
<li><p>in low-d, we want to focus on nearby live point spheres
The border traced out is fairly accurate, at least in the
normal away from the inside.</p></li>
<li><p>in high-d, reflpoint is contained by all live points,
and none of them point to the center well. Because the
sampling is poor, the “region center” position
will be very stochastic.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reflpoint</strong> (<em>vector</em>) – point outside the likelihood contour, reflect there</p></li>
<li><p><strong>v</strong> (<em>vector</em>) – previous direction vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>gradient</strong> – normal of ellipsoid</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>vector</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.solvecompat">
<span id="ultranest-solvecompat-module"></span><h2>ultranest.solvecompat module<a class="headerlink" href="#module-ultranest.solvecompat" title="Permalink to this headline">¶</a></h2>
<p>Drop-in replacement for pymultinest.solve.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ultranest.solvecompat</span> <span class="kn">import</span> <span class="n">pymultinest_solve_compat</span> <span class="k">as</span> <span class="n">solve</span>

<span class="c1"># is a drop-in replacement for</span>

<span class="kn">from</span> <span class="nn">pymultinest.solve</span> <span class="kn">import</span> <span class="n">solve</span>
</pre></div>
</div>
<dl class="py function">
<dt id="ultranest.solvecompat.pymultinest_solve_compat">
<code class="sig-prename descclassname">ultranest.solvecompat.</code><code class="sig-name descname">pymultinest_solve_compat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">LogLikelihood</span></em>, <em class="sig-param"><span class="n">Prior</span></em>, <em class="sig-param"><span class="n">n_dims</span></em>, <em class="sig-param"><span class="n">paramnames</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">outputfiles_basename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">resume</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_live_points</span><span class="o">=</span><span class="default_value">400</span></em>, <em class="sig-param"><span class="n">evidence_tolerance</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">wrapped_params</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">speed</span><span class="o">=</span><span class="default_value">'safe'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/solvecompat.html#pymultinest_solve_compat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.solvecompat.pymultinest_solve_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>Run nested sampling analysis.</p>
<p>Disadvantages compared to using ReactiveNestedSampler directly:
cannot resume easily, cannot plot interactively.
Limited results.</p>
</dd></dl>

</div>
<div class="section" id="module-ultranest.stepsampler">
<span id="ultranest-stepsampler-module"></span><h2>ultranest.stepsampler module<a class="headerlink" href="#module-ultranest.stepsampler" title="Permalink to this headline">¶</a></h2>
<p>MCMC-like step sampling within a region.</p>
<p>The classes implemented here are generators that, in each iteration,
only make one likelihood call. This allows keeping a population of
samplers that have the same execution time per call, even if they
do not terminate at the same number of iterations.</p>
<dl class="py function">
<dt id="ultranest.stepsampler.generate_random_direction">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">generate_random_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#generate_random_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.generate_random_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw uniform direction vector in unit cube space of length <cite>scale</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> (<em>MLFriends object</em>) – current region (not used)</p></li>
<li><p><strong>scale</strong> (<em>float:</em>) – length of direction vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.stepsampler.generate_cube_oriented_direction">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">generate_cube_oriented_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#generate_cube_oriented_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.generate_cube_oriented_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a unit direction vector in direction of a random unit cube axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> (<em>MLFriends object</em>) – current region (not used)</p></li>
<li><p><strong>scale</strong> (<em>float:</em>) – length of direction vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.stepsampler.generate_region_oriented_direction">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">generate_region_oriented_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">tscale</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#generate_region_oriented_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.generate_region_oriented_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a random direction vector in direction of one of the <cite>region</cite> axes.</p>
<p>The vector length is <cite>scale</cite> (if given).
If not, the vector length in transformed space is <cite>tscale</cite>.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.stepsampler.generate_region_random_direction">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">generate_region_random_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#generate_region_random_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.generate_region_random_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a direction vector in a random direction of the region.</p>
<p>The vector length is <cite>scale</cite> (in unit cube space).</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.stepsampler.generate_mixture_random_direction">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">generate_mixture_random_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">uniform_weight</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#generate_mixture_random_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.generate_mixture_random_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw from a mix of a ball proposal and a region-shaped proposal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> (<a class="reference internal" href="#id6" title="ultranest.mlfriends.MLFriends"><em>MLFriends</em></a>) – region</p></li>
<li><p><strong>uniform_weight</strong> (<em>float</em>) – sets the weight for the equal-axis ball contribution</p></li>
<li><p><strong>scale</strong> (<em>float</em>) – length of the vector.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.stepsampler.inside_region">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">inside_region</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">unew</span></em>, <em class="sig-param"><span class="n">uold</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#inside_region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.inside_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <cite>unew</cite> is inside region.</p>
</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.StepSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">StepSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for a simple step sampler, staggering around.</p>
<p>Scales proposal towards a 50% acceptance rate.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sampler statistics.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move around ui. Stub to be implemented.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.adjust_outside_region">
<code class="sig-name descname">adjust_outside_region</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.adjust_outside_region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.adjust_outside_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we landed outside region.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.adjust_accept">
<code class="sig-name descname">adjust_accept</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">accepted</span></em>, <em class="sig-param"><span class="n">unew</span></em>, <em class="sig-param"><span class="n">pnew</span></em>, <em class="sig-param"><span class="n">Lnew</span></em>, <em class="sig-param"><span class="n">nc</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.adjust_accept"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.adjust_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we have been <cite>accepted</cite> at a new point after <cite>nc</cite> calls.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.adapt_nsteps">
<code class="sig-name descname">adapt_nsteps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.adapt_nsteps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.adapt_nsteps" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapt the number of steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>region</strong> (<em>MLFriends object</em>) – current region</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.finalize_chain">
<code class="sig-name descname">finalize_chain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Lmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Ls</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.finalize_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.finalize_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Store chain statistics and adapt proposal.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.new_chain">
<code class="sig-name descname">new_chain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.new_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.new_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a new path, reset statistics.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.StepSampler.region_changed">
<code class="sig-name descname">region_changed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ls</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#StepSampler.region_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.StepSampler.region_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>React to change of region.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.CubeMHSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">CubeMHSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeMHSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeMHSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.StepSampler" title="ultranest.stepsampler.StepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.StepSampler</span></code></a></p>
<p>Simple step sampler, staggering around in cube space.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.CubeMHSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeMHSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeMHSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move in cube space.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.RegionMHSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">RegionMHSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionMHSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionMHSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.StepSampler" title="ultranest.stepsampler.StepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.StepSampler</span></code></a></p>
<p>Simple step sampler, staggering around in transformLayer space.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.RegionMHSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionMHSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionMHSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move in transformLayer space.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.CubeSliceSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">CubeSliceSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeSliceSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.StepSampler" title="ultranest.stepsampler.StepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.StepSampler</span></code></a></p>
<p>Slice sampler, respecting the region.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.CubeSliceSampler.new_chain">
<code class="sig-name descname">new_chain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeSliceSampler.new_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeSliceSampler.new_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a new path, reset slice.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.CubeSliceSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeSliceSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeSliceSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Start in a new direction, by choosing a random parameter.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.CubeSliceSampler.adjust_accept">
<code class="sig-name descname">adjust_accept</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">accepted</span></em>, <em class="sig-param"><span class="n">unew</span></em>, <em class="sig-param"><span class="n">pnew</span></em>, <em class="sig-param"><span class="n">Lnew</span></em>, <em class="sig-param"><span class="n">nc</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeSliceSampler.adjust_accept"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeSliceSampler.adjust_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we have been <cite>accepted</cite> at a new point after <cite>nc</cite> calls.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.CubeSliceSampler.adjust_outside_region">
<code class="sig-name descname">adjust_outside_region</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeSliceSampler.adjust_outside_region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeSliceSampler.adjust_outside_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust proposal given that we landed outside region.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.CubeSliceSampler.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">ndraw</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#CubeSliceSampler.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.CubeSliceSampler.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the slice sampling move.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.RegionSliceSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">RegionSliceSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionSliceSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.CubeSliceSampler" title="ultranest.stepsampler.CubeSliceSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.CubeSliceSampler</span></code></a></p>
<p>Slice sampler, randomly picking region axes.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.RegionSliceSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionSliceSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionSliceSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a random axis from region.transformLayer.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.RegionSequentialSliceSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">RegionSequentialSliceSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionSequentialSliceSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionSequentialSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.CubeSliceSampler" title="ultranest.stepsampler.CubeSliceSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.CubeSliceSampler</span></code></a></p>
<p>Slice sampler, sequentially iterating region axes.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.RegionSequentialSliceSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionSequentialSliceSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionSequentialSliceSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose from region.transformLayer the next axis iteratively.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.BallSliceSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">BallSliceSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#BallSliceSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.BallSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.CubeSliceSampler" title="ultranest.stepsampler.CubeSliceSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.CubeSliceSampler</span></code></a></p>
<p>Hit &amp; run sampler. Choose random directions in space.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.BallSliceSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#BallSliceSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.BallSliceSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a isotropically random direction from region.transformLayer.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.RegionBallSliceSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">RegionBallSliceSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">adaptive_nsteps</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_nsteps</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">region_filter</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionBallSliceSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionBallSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.CubeSliceSampler" title="ultranest.stepsampler.CubeSliceSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.CubeSliceSampler</span></code></a></p>
<p>Hit &amp; run sampler. Choose random directions according to region.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – initial proposal size</p></li>
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
<li><p>’proposal-distance’: mean square distance of
proposed vectors exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’proposal-total-distances-NN’: mean distance
of chain points from starting point exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-NN’: summed distances
between chain points exceeds mean distance
between pairs of live points.</p></li>
<li><p>’proposal-summed-distances-min-NN’: smallest distance
between chain points exceeds mean distance
between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.RegionBallSliceSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#RegionBallSliceSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.RegionBallSliceSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a isotropically random direction from region.transformLayer.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.SpeedVariableRegionSliceSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">SpeedVariableRegionSliceSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">step_matrix</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#SpeedVariableRegionSliceSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.SpeedVariableRegionSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.CubeSliceSampler" title="ultranest.stepsampler.CubeSliceSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.CubeSliceSampler</span></code></a></p>
<p>Slice sampler, in region axes.</p>
<p>Updates only some dimensions at a time, completely user-definable.</p>
<p>Initialise sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>step_matrix</strong> (<em>matrix</em><em> or </em><em>list of slices</em>) – <p><strong>if a bool matrix of shape (n_steps, n_dims):</strong></p>
<p>Each row of the matrix indicates which parameters
should be updated.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]]</span>
</pre></div>
</div>
<p>This would update the first parameter 1/3 times, and the second
parameters every time. Three steps are made until the point
is considered independent.</p>
<p>For a full update in every step, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>if a list of slices:</strong></p>
<p>Each entry indicates which parameters should be updated.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
<p>This would update the first parameter 1/3 times, parameters
2-9 2/3 times and parameter 5-9 in every step.
Three steps are made until the point is considered independent.</p>
</p>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.SpeedVariableRegionSliceSampler.generate_direction">
<code class="sig-name descname">generate_direction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#SpeedVariableRegionSliceSampler.generate_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.SpeedVariableRegionSliceSampler.generate_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a slice sampling direction, using only some of the axes.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="ultranest.stepsampler.ellipsoid_bracket">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">ellipsoid_bracket</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">ellipsoid_center</span></em>, <em class="sig-param"><span class="n">ellipsoid_inv_axes</span></em>, <em class="sig-param"><span class="n">ellipsoid_radius_square</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#ellipsoid_bracket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.ellipsoid_bracket" title="Permalink to this definition">¶</a></dt>
<dd><p>For a line from ui in direction v through an ellipsoid
centered at ellipsoid_center with axes matrix ellipsoid_inv_axes,
return the lower and upper intersection parameter.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.stepsampler.crop_bracket_at_unit_cube">
<code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">crop_bracket_at_unit_cube</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">left</span></em>, <em class="sig-param"><span class="n">right</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#crop_bracket_at_unit_cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.crop_bracket_at_unit_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>A line segment from <em>ui</em> in direction <em>v</em> from t between <em>left</em> &lt;= 0 &lt;= <em>right</em>
will be truncated by the unit cube. Returns newleft, newright, cropped_left, cropped_right,
i.e., the new end parameters and whether cropping was applied.</p>
</dd></dl>

<dl class="py class">
<dt id="ultranest.stepsampler.AHARMSampler">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.stepsampler.</code><code class="sig-name descname">AHARMSampler</code><span class="sig-paren">(</span><em class="sig-param">nsteps</em>, <em class="sig-param">adaptive_nsteps=False</em>, <em class="sig-param">max_nsteps=1000</em>, <em class="sig-param">region_filter=False</em>, <em class="sig-param">log=False</em>, <em class="sig-param">direction=&lt;function generate_region_random_direction&gt;</em>, <em class="sig-param">orthogonalise=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#AHARMSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.AHARMSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.stepsampler.StepSampler" title="ultranest.stepsampler.StepSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.stepsampler.StepSampler</span></code></a></p>
<p>Accelerated hit-and-run/slice sampler, vectorised.</p>
<p>Uses region ellipsoid to propose a sequence of points
on a randomly drawn line.</p>
<p>Initialise vectorised hit-and-run/slice sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsteps</strong> (<em>int</em>) – number of accepted steps until the sample is considered independent.</p></li>
<li><p><strong>adaptive_nsteps</strong> (<em>False</em><em>, </em><em>'proposal-distance'</em><em>, </em><em>'move-distance'</em>) – <p>Select a strategy to adapt the number of steps. The strategies
make sure that:</p>
<ul>
<li><p>’move-distance’ (recommended): distance between
start point and final position exceeds the mean distance
between pairs of live points.</p></li>
<li><p>’move-distance-midway’: distance between
start point and position in the middle of the chain
exceeds the mean distance between pairs of live points.</p></li>
</ul>
</p></li>
<li><p><strong>max_nsteps</strong> (<em>int</em>) – Maximum number of steps the adaptive_nsteps can reach.</p></li>
<li><p><strong>region_filter</strong> (<em>bool</em>) – if True, use region to check if a proposed point can be inside
before calling likelihood.</p></li>
<li><p><strong>direction</strong> (<em>function</em>) – function that draws slice direction given a point and
the current region.</p></li>
<li><p><strong>orthogonalise</strong> (<em>bool</em>) – If true, make subsequent proposed directions orthogonal
to each other.</p></li>
<li><p><strong>log</strong> (<em>file</em>) – log file for sampler statistics, such as acceptance rate,
proposal scale, number of steps, jump distance and distance
between live points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ultranest.stepsampler.AHARMSampler.region_changed">
<code class="sig-name descname">region_changed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ls</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#AHARMSampler.region_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.AHARMSampler.region_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>React to change of region.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.AHARMSampler.finalize_chain">
<code class="sig-name descname">finalize_chain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">region</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Lmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Ls</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#AHARMSampler.finalize_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.AHARMSampler.finalize_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Store chain statistics and adapt proposal.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.stepsampler.AHARMSampler.generate_new_interval">
<code class="sig-name descname">generate_new_interval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ui</span></em>, <em class="sig-param"><span class="n">region</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/stepsampler.html#AHARMSampler.generate_new_interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.stepsampler.AHARMSampler.generate_new_interval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.store">
<span id="ultranest-store-module"></span><h2>ultranest.store module<a class="headerlink" href="#module-ultranest.store" title="Permalink to this headline">¶</a></h2>
<p>Storage for nested sampling points.</p>
<p>The information stored is a table with</p>
<ul class="simple">
<li><p>the likelihood threshold drawn from</p></li>
<li><p>the likelihood, prior volume coordinates and physical coordinates of the point</p></li>
</ul>
<dl class="py class">
<dt id="ultranest.store.NullPointStore">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.store.</code><code class="sig-name descname">NullPointStore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ncols</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#NullPointStore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.NullPointStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>No storage.</p>
<p>Mock initialisation.</p>
<dl class="py method">
<dt id="ultranest.store.NullPointStore.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#NullPointStore.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.NullPointStore.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.store.NullPointStore.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#NullPointStore.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.NullPointStore.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.store.NullPointStore.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#NullPointStore.flush"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.NullPointStore.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.store.NullPointStore.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">row</span></em>, <em class="sig-param"><span class="n">ncalls</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#NullPointStore.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.NullPointStore.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Increases the number of “stored” points.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.store.NullPointStore.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Lmin</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#NullPointStore.pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.NullPointStore.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return no point (None, None).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.store.FilePointStore">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.store.</code><code class="sig-name descname">FilePointStore</code><a class="reference internal" href="_modules/ultranest/store.html#FilePointStore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.FilePointStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for storing points in a file.</p>
<dl class="py method">
<dt id="ultranest.store.FilePointStore.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#FilePointStore.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.FilePointStore.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset stack to loaded data.</p>
<p>Useful when Lmin is not reset to a lower value.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.store.FilePointStore.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#FilePointStore.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.FilePointStore.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close file.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.store.FilePointStore.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#FilePointStore.flush"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.FilePointStore.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush file to disk.</p>
</dd></dl>

<dl class="py method">
<dt id="ultranest.store.FilePointStore.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Lmin</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#FilePointStore.pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.FilePointStore.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Request from the storage a point sampled from &lt;= Lmin with L &gt; Lmin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – index of the point, None if no point exists</p></li>
<li><p><strong>point</strong> (<em>array</em>) – point values, None if no point exists</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.store.TextPointStore">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.store.</code><code class="sig-name descname">TextPointStore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath</span></em>, <em class="sig-param"><span class="n">ncols</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#TextPointStore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.TextPointStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.store.FilePointStore" title="ultranest.store.FilePointStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.store.FilePointStore</span></code></a></p>
<p>Storage in a text file.</p>
<p>Stores previously drawn points above some likelihood contour,
so that they can be reused in another run.</p>
<p>The format is a tab separated text file.
Through the fmt and delimiter attributes the output can be altered.</p>
<p>Load and append to storage at <em>filepath</em>.</p>
<p>The file should contain <em>ncols</em> columns (Lmin, L, and others).</p>
<dl class="py method">
<dt id="ultranest.store.TextPointStore.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">row</span></em>, <em class="sig-param"><span class="n">ncalls</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#TextPointStore.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.TextPointStore.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add data point <em>row</em> = [Lmin, L, *otherinfo] to storage.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ultranest.store.HDF5PointStore">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.store.</code><code class="sig-name descname">HDF5PointStore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath</span></em>, <em class="sig-param"><span class="n">ncols</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">h5_file_args</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#HDF5PointStore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.HDF5PointStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ultranest.store.FilePointStore" title="ultranest.store.FilePointStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ultranest.store.FilePointStore</span></code></a></p>
<p>Storage in a HDF5 file.</p>
<p>Stores previously drawn points above some likelihood contour,
so that they can be reused in another run.</p>
<p>The format is a HDF5 file, which grows as needed.</p>
<p>Load and append to storage at filepath.</p>
<p>File contains <em>ncols</em> columns in ‘points’ dataset (Lmin, L, and others).
h5_file_args are passed on to hdf5.File.</p>
<dl class="py attribute">
<dt id="ultranest.store.HDF5PointStore.FILES_OPENED">
<code class="sig-name descname">FILES_OPENED</code><em class="property"> = []</em><a class="headerlink" href="#ultranest.store.HDF5PointStore.FILES_OPENED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ultranest.store.HDF5PointStore.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">row</span></em>, <em class="sig-param"><span class="n">ncalls</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/store.html#HDF5PointStore.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.store.HDF5PointStore.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add data point row = [Lmin, L, <em>otherinfo</em> to storage.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ultranest.utils">
<span id="ultranest-utils-module"></span><h2>ultranest.utils module<a class="headerlink" href="#module-ultranest.utils" title="Permalink to this headline">¶</a></h2>
<p>Utility functions for logging and statistics.</p>
<dl class="py function">
<dt id="ultranest.utils.create_logger">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">create_logger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module_name</span></em>, <em class="sig-param"><span class="n">log_dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">20</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#create_logger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.create_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the logging channel <cite>module_name</cite>.</p>
<p>Append to <code class="docutils literal notranslate"><span class="pre">debug.log</span></code> in <cite>log_dir</cite> (if not <code class="docutils literal notranslate"><span class="pre">None</span></code>).
Write to stdout with output level <cite>level</cite>.</p>
<p>If logging handlers are already registered, no new handlers are
registered.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.make_run_dir">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">make_run_dir</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">log_dir</span></em>, <em class="sig-param"><span class="n">run_num</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append_run_num</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#make_run_dir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.make_run_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a new numbered directory for this run to store output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>log_dir</strong> (<em>str</em>) – base path</p></li>
<li><p><strong>run_num</strong> (<em>int</em>) – folder to add to path, such as prefix/1/</p></li>
<li><p><strong>append_run_num</strong> (<em>bool</em>) – If true, set run_num to next unused number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>dictionary of folder paths for different purposes.</em></p></li>
<li><p><em>Keys are “run_dir” (the path), “info”, “results”, “chains”, “plots”.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.vectorize">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">vectorize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#vectorize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.vectorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorize likelihood or prior_transform function.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.resample_equal">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">resample_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">weights</span></em>, <em class="sig-param"><span class="n">rstate</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#resample_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.resample_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the samples so that the final samples all have equal weight.</p>
<p>Each input sample appears in the output array either
<cite>floor(weights[i] * N)</cite> or <cite>ceil(weights[i] * N)</cite> times, with
<cite>floor</cite> or <cite>ceil</cite> randomly selected (weighted by proximity).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<cite>~numpy.ndarray</cite>) – Unequally weight samples returned by the nested sampling algorithm.
Shape is (N, …), with N the number of samples.</p></li>
<li><p><strong>weights</strong> (<cite>~numpy.ndarray</cite>) – Weight of each sample. Shape is (N,).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>equal_weight_samples</strong> – Samples with equal weights, same shape as input samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>~numpy.ndarray</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nestle</span><span class="o">.</span><span class="n">resample_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="go">array([[ 1.,  1.],</span>
<span class="go">       [ 1.,  1.],</span>
<span class="go">       [ 1.,  1.],</span>
<span class="go">       [ 3.,  3.]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Implements the systematic resampling method described in
<a class="reference external" href="http://people.isy.liu.se/rt/schon/Publications/HolSG2006.pdf">this PDF</a>.
Another way to sample according to weights would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="n">new_samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">weights</span><span class="p">)]</span>
</pre></div>
</div>
<p>However, the method used in this function is less “noisy”.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.listify">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">listify</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#listify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.listify" title="Permalink to this definition">¶</a></dt>
<dd><p>concatenate args, which are (made to be) lists</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<em>iterable</em>) – Lists to concatenate.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Concatenation of the lists in args.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.quantile">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#quantile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute (weighted) quantiles from an input set of samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>~numpy.ndarray</cite> with shape (nsamps,)) – Input samples.</p></li>
<li><p><strong>q</strong> (<cite>~numpy.ndarray</cite> with shape (nquantiles,)) – The list of quantiles to compute from <cite>[0., 1.]</cite>.</p></li>
<li><p><strong>weights</strong> (<cite>~numpy.ndarray</cite> with shape (nsamps,), optional) – The associated weight from each sample.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>quantiles</strong> – The weighted sample quantiles computed at <cite>q</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>~numpy.ndarray</cite> with shape (nquantiles,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.vol_prefactor">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">vol_prefactor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#vol_prefactor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.vol_prefactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume constant for an <cite>n</cite>-dimensional sphere.</p>
<p>for <cite>n</cite> even:  $$    (2pi)^(n    /2) / (2 * 4 * … * n)$$
for <cite>n</cite> odd :  $$2 * (2pi)^((n-1)/2) / (1 * 3 * … * n)$$</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.is_affine_transform">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">is_affine_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#is_affine_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.is_affine_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>checks if one group of points <em>a</em> is an affine transform
of another group of points <em>b</em>.</p>
<p>The implementation currently returns False for rotations.</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.normalised_kendall_tau_distance">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">normalised_kendall_tau_distance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">values1</span></em>, <em class="sig-param"><span class="n">values2</span></em>, <em class="sig-param"><span class="n">i</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">j</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#normalised_kendall_tau_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.normalised_kendall_tau_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalised Kendall tau distance between two arrays,
<em>values1</em> and <em>values2</em>, both of length N.</p>
<p>see <a class="reference external" href="https://en.wikipedia.org/wiki/Kendall_tau_distance">https://en.wikipedia.org/wiki/Kendall_tau_distance</a></p>
<p>You can optionally pass precomputed indices:
i, j = np.meshgrid(np.arange(N), np.arange(N))</p>
</dd></dl>

<dl class="py function">
<dt id="ultranest.utils.verify_gradient">
<code class="sig-prename descclassname">ultranest.utils.</code><code class="sig-name descname">verify_gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ndim</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="n">loglike</span></em>, <em class="sig-param"><span class="n">gradient</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">combination</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/utils.html#verify_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.utils.verify_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>check with numerical differentiation if the gradient function
is plausibly correct. Raises AssertError otherwise.</p>
<p>All functions are vectorized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ndim</strong> (<em>int</em>) – dimensionality</p></li>
<li><p><strong>transform</strong> (<em>function</em>) – transform unit cube parameters to physical parameters, vectorized</p></li>
<li><p><strong>loglike</strong> (<em>function</em>) – loglikelihood function, vectorized</p></li>
<li><p><strong>gradient</strong> (<em>function</em>) – computes gradient of loglike to unit cube parameters.
Takes a single point and returns a single vector.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – whether to show intermediate test results</p></li>
<li><p><strong>combination</strong> (<em>bool</em>) – if true, the gradient function should return a tuple of:
(transformed parameters, loglikelihood, gradient) for a
given unit cube point.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ultranest.viz">
<span id="ultranest-viz-module"></span><h2>ultranest.viz module<a class="headerlink" href="#module-ultranest.viz" title="Permalink to this headline">¶</a></h2>
<p>Visual impression of current exploration.</p>
<dl class="py function">
<dt id="ultranest.viz.round_parameterlimits">
<code class="sig-prename descclassname">ultranest.viz.</code><code class="sig-name descname">round_parameterlimits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">plo</span></em>, <em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">paramlimitguess</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/viz.html#round_parameterlimits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.viz.round_parameterlimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the current parameter range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plo</strong> (<em>array of floats</em>) – for each parameter, current minimum value</p></li>
<li><p><strong>phi</strong> (<em>array of floats</em>) – for each parameter, current maximum value</p></li>
<li><p><strong>paramlimitguess</strong> (<em>array of float tuples</em>) – for each parameter, guess of parameter range if available</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>plo_rounded</strong> (<em>array of floats</em>) – for each parameter, rounded minimum value</p></li>
<li><p><strong>phi_rounded</strong> (<em>array of floats</em>) – for each parameter, rounded maximum value</p></li>
<li><p><strong>formats</strong> (<em>array of float tuples</em>) – for each parameter, string format for representing it.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.viz.nicelogger">
<code class="sig-prename descclassname">ultranest.viz.</code><code class="sig-name descname">nicelogger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">info</span></em>, <em class="sig-param"><span class="n">region</span></em>, <em class="sig-param"><span class="n">transformLayer</span></em>, <em class="sig-param"><span class="n">region_fresh</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/viz.html#nicelogger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.viz.nicelogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Log current live points and integration progress to stdout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>dict with keys &quot;u&quot;</em><em>, </em><em>&quot;p&quot;</em><em>, </em><em>&quot;logl&quot;</em>) – live points (u: cube coordinates, p: transformed coordinates,
logl: loglikelihood values)</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – <p>integration information. Keys are:</p>
<ul>
<li><p>paramlims (optional): parameter ranges</p></li>
<li><p>logvol: expected volume at this iteration</p></li>
</ul>
</p></li>
<li><p><strong>region</strong> (<a class="reference internal" href="#id6" title="ultranest.mlfriends.MLFriends"><em>MLFriends</em></a>) – Current region.</p></li>
<li><p><strong>transformLayer</strong> (<em>ScaleLayer</em><em> or </em><a class="reference internal" href="#id0" title="ultranest.mlfriends.AffineLayer"><em>AffineLayer</em></a>) – Current transformLayer (for clustering information).</p></li>
<li><p><strong>region_fresh</strong> (<em>bool</em>) – Whether the region was just updated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="ultranest.viz.isnotebook">
<code class="sig-prename descclassname">ultranest.viz.</code><code class="sig-name descname">isnotebook</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/viz.html#isnotebook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.viz.isnotebook" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if running in a Jupyter notebook.</p>
</dd></dl>

<dl class="py class">
<dt id="ultranest.viz.LivePointsWidget">
<em class="property">class </em><code class="sig-prename descclassname">ultranest.viz.</code><code class="sig-name descname">LivePointsWidget</code><a class="reference internal" href="_modules/ultranest/viz.html#LivePointsWidget"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.viz.LivePointsWidget" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Widget for ipython and jupyter notebooks.</p>
<p>Shows where the live points are currently in parameter space.</p>
<p>Initialise. To draw, call .initialize().</p>
<dl class="py method">
<dt id="ultranest.viz.LivePointsWidget.initialize">
<code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">paramnames</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/viz.html#LivePointsWidget.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.viz.LivePointsWidget.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up and display widget.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>paramnames</strong> (<em>list of str</em>) – Parameter names</p></li>
<li><p><strong>width</strong> (<em>int</em>) – number of html table columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="ultranest.viz.get_default_viz_callback">
<code class="sig-prename descclassname">ultranest.viz.</code><code class="sig-name descname">get_default_viz_callback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ultranest/viz.html#get_default_viz_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ultranest.viz.get_default_viz_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Get default callback.</p>
<p>LivePointsWidget for Jupyter notebook, nicelogger otherwise.</p>
</dd></dl>

</div>
<div class="section" id="module-ultranest">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ultranest" title="Permalink to this headline">¶</a></h2>
<p>Performs nested sampling to calculate the Bayesian evidence and posterior samples
Some parts are from the Nestle library by Kyle Barbary (<a class="reference external" href="https://github.com/kbarbary/nestle">https://github.com/kbarbary/nestle</a>)
Some parts are from the nnest library by Adam Moss (<a class="reference external" href="https://github.com/adammoss/nnest">https://github.com/adammoss/nnest</a>)</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="issues.html" class="btn btn-neutral float-right" title="Frequently Asked Questions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modules.html" class="btn btn-neutral float-left" title="API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2014-2020, Johannes Buchner

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>